.\"Copyright (C) 2009-2014 Kaz Kylheku <kaz@kylheku.com>.
.\"All rights reserved.
.\"
.\"BSD License:
.\"
.\"Redistribution and use in source and binary forms, with or without
.\"modification, are permitted provided that the following conditions
.\"are met:
.\"
.\"  1. Redistributions of source code must retain the above copyright
.\"     notice, this list of conditions and the following disclaimer.
.\"  2. Redistributions in binary form must reproduce the above copyright
.\"     notice, this list of conditions and the following disclaimer in
.\"     the documentation and/or other materials provided with the
.\"     distribution.
.\"  3. The name of the author may not be used to endorse or promote
.\"     products derived from this software without specific prior
.\"     written permission.
.\"
.\"THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
.\"IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
.\"WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

.TH "TXR" 1 2014-08-14 "Utility Commands" "TXR Text Processing Language" "Kaz Kylheku"
.SH NAME
txr \- text processing language (version 96)
.SH SYNOPSIS
.B txr [ options ] query-file { data-file }*
.sp
.SH DESCRIPTION
.B TXR
is a language oriented toward processing text from files or streams, using
multiple programming paradigms.

A
.B TXR
script is called a query, and it specifies a pattern which matches (a prefix
of) an entire file, or multiple files.  Patterns can consists of large
chunks of multi-line free-form text, which is matched literally
against material in the input sources. Free variables occurring in the pattern
(denoted by the @ symbol) are bound to the pieces of text occurring in the
corresponding positions. If the overall match is successful, then
.B TXR
can do one of two things: it can report the list of variables which were bound,
in the form of a set of variable assignments which can be evaluated by the
.B eval
command of the POSIX shell language, or generate a custom report according
to special directives in the query. Patterns can be arbitrarily complex,
and can be broken down into named pattern functions, which may be mutually
recursive. TXR patterns can work horizontally (characters within a line)
or vertically (spanning multiple lines). Multiple lines can be treated
as a single line.


In addition to embedded variables which implicitly match text, the
.B TXR
query language supports a number of directives, for matching text using regular
expressions, for continuing a match in another file, for searching through a
file for the place where an entire sub-query matches, for collecting lists, and
for combining sub-queries using logical conjunction, disjunction and negation,
and numerous others.  

Furthermore, embedded within TXR is a powerful Lisp dialect.  TXR Lisp supports
functional and imperative programming, and provides data types such as symbols,
strings, vectors, hash tables with weak reference support, lazy lists, and
arbitrary-precision (bignum integers).

.SH ARGUMENTS AND OPTIONS

Options which don't take an argument may be combined together.
The -v and -q options are mutually exclusive. Of these two, the one which
occurs in the rightmost position in the argument list dominates.
The -c and -f options are also mutually exclusive; if both are specified,
it is a fatal error.

.IP -Dvar=value
Bind the variable
.IR var
to the value
.IR value
prior to processing the query. The name is in scope over the entire
query, so that all occurrence of the variable are substituted and
match the equivalent text.  If the value contains commas, these
are interpreted as separators, which give rise to a list value.
For instance -Da,b,c creates a list of the strings "a", "b" and "c".
(See Collect Directive bellow). List variables provide a multiple
match. That is to say, if a list variable occurs in a query, a successful
match occurs if any of its values matches the text. If more than one
value matches the text, the first one is taken.

.IP -Dvar
Binds the variable
.IR var
to an empty string value prior to processing the query.

.IP -q
Quiet operation during matching. Certain error messages are not reported on the
standard error device (but the if the situations occur, they still fail the
query). This option does not suppress error generation during the parsing
of the query, only during its execution.

.IP -d
Invoke the interactive txr debugger. See the DEBUGGER section.

.IP -v
Verbose operation. Detailed logging is enabled.

.IP -b
This is a deprecated option, which is silently ignored. In TXR versions
prior to 90, the printing of variable bindings (see -B option) was
implicit behavior which was automatically suppressed in certain situations.
The -b option suppressed it unconditionally.

.IP -B
If the query is successful, print the variable bindings as a sequence
of assignments in shell syntax can be eval-ed by a POSIX shell.
If the query fails, print the word "false". Evaluation of this word
by the shell has the effect of producing an unsuccessful termination
status from the eval command.

.IP "-l or --lisp-bindings"
This option implies -B. Print the variable bindings in Lisp syntax instead of
shell syntax.

.IP "-a num"
This option implies -B. The decimal integer argument specifies the maximum
number of array dimensions to use for list-valued variable bindings.
The default is 1. Additional dimensions are expressed using numeric suffixes
in the generated variable names.
For instance, consider the three-dimensional list arising out of a triply
nested collect: ((("a" "b") ("c" "d")) (("e" "f") ("g" "h"))).
Suppose this is bound to a variable V.  With -a 1, this will be
reported as:

  V_0_0[0]="a"
  V_0_1[0]="b"
  V_1_0[0]="c"
  V_1_1[0]="d"
  V_0_0[1]="e"
  V_0_1[1]="f"
  V_1_0[1]="g"
  V_1_1[1]="h"

The leftmost bracketed index is the most major index. That is to say,
the dimension order is: NAME_m_m+1_..._n[1][2]...[m-1].

.IP "-c query"
Specifies the query in the form of a command line argument. If this option is
used, the query-file argument is omitted. The first non-option argument,
if there is one, now specifies the first input source rather than a query.
Unlike queries read from a file, (non-empty) queries specified as arguments
using -c do not have to properly end in a newline. Internally, TXR
adds the missing newline before parsing the query. Thus -c "@a"
is a valid query which matches a line.

Example:

  # read two lines "1" and "2" from standard input,
  # binding them to variables a and b. Standard
  # input is specified as - and the data
  # comes from shell "here document" redirection.

  txr -B -c "@a
  @b" - <<!
  1
  2
  !

  Output:
  a=1
  b=2

The @; comment syntax can be used for better formatting:

  txr -B -c "@;
  @a
  @b"

.IP "-f query-file"
Specifies the file from which the query is to be read, instead of the
query-file argument. This is useful in #! scripts. (See Hash Bang Support
below).

.IP "-e expression"
Evaluates a TXR Lisp expression for its side effects, without printing
its value. Can be specified more than once. The query-file argument becomes
optional if -e is used at least once.

.IP "-p expression"
Evaluates a TXR Lisp expression and prints its value.  Can be specified more
than once. The query-file argument becomes optional if -p is used at least
once.

.IP --help
Prints usage summary on standard output, and terminates successfully.

.IP --license
Prints the software license. This depends on the software being
installed such that the LICENSE file is in the data directory.
Use of txr implies agreement with the liability disclaimer in the license.

.IP --version
Prints program version standard output, and terminates successfully.

.IP --args
The --args option provides a way to encode multiple arguments as a single
argument, which is useful on some systems which have limitations in
their implementation of the "hash bang" mechanism. See Hash Bang Support
below.

.IP --
Signifies the end of the option list. This option does not combine with others,
so for instance -b- does not mean -b --, but is an error.

.IP -
This argument is not interpreted as an option, but treated as a filename
argument. After the first such argument, no more options are recognized. Even
if another argument looks like an option, it is treated as a name.
This special argument - means "read from standard input" instead of a file.
The query file, or any of the data files, may be specified using this option.
If two or more files are specified as -, the behavior is system-dependent.
It may be possible to indicate EOF from the interactive terminal, and
then specify more input which is interpreted as the second file, and so forth.

.PP
After the options, the remaining arguments are files. The first file argument
specifies the query, and is mandatory.  A file argument consisting of a single
- means to read the standard input instead of opening a file. A file argument
which begins with an exclamation symbol means that the rest of the argument is
a shell command which is to be run as a coprocess, and its output read like a
file.

.PP
.B TXR
begins by reading the query. The entire query is scanned, internalized
and then begins executing, if it is free of syntax errors.  The reading of
data, on the other hand, is lazy.  A file isn't opened until the query demands
material from that file, and then the contents are read on demand, not all at
once.

If no files arguments are specified on the command line, it is up to the
query to open a file, pipe or standard input via the @(next) directive
prior to attempting to make a match. If a query attempts to match text,
but has run out of files to process, the match fails.

.SH STATUS AND ERROR REPORTING
.B TXR
sends errors and verbose logs to the standard error device. The following
paragraphs apply when
.B TXR
is run without enabling verbose mode with -v, or the printing of variable
bindings with -B or -a.

If the command line arguments are incorrect, or the query has a malformed
syntax,
.B TXR
issues an error diagnostic and terminates with a failed status.

If the query fails due to a mismatch,
.B TXR
terminates with a failed status. No diagnostics are issued.

If the query is well-formed, and matches, then
.B TXR
issues no diagnostics, and terminates with a successful status.

In verbose mode (-v),
.B TXR
issues diagnostics on the standard error device even in situations which are
not erroneous.

In bindings-printing mode (-B or -a),
.B TXR
prints the word "false" if the query fails, and exits with a failed
termination status. If the query succeeds, the variable bindings, if any,
are output on standard output.

.SH BASIC QUERY SYNTAX AND SEMANTICS

.SS Comments

A query may contain comments which are delimited by the sequence @; and
extend to the end of the line. No whitespace can occur between the @ and ;.
A comment which begins on a line swallows that entire line, as well as the
newline which terminates it. In essence, the entire comment disappears.
If the comment follows some material in a line, then it does not consume
the newline. Thus, the following two queries are equivalent:

 1.  @a@; comment: match whole line against variable @a
     @; this comment disappears entirely
     @b

 2.  @a
     @b

The comment after the @a does not consume the newline, but the
comment which follows does. Without this intuitive behavior,
line comment would give rise to empty lines that must match empty
lines in the data, leading to spurious mismatches.

Instead of the ; character, the # character can be used. This is
an obsolescent feature.


.SS Hash Bang Support

TXR has several features which support use of the "hash bang" convention
for creating apparently stand-alone executable programs.

If the first line of a query begins with the characters #!,
that entire line is deleted from the query. This allows
for TXR queries to be turned into standalone executable programs in the POSIX
environment.

Shell example: create a simple executable program called "twoline.txr" and
run it. This assumes txr is installed in /usr/bin.

  $ cat > hello.txr
  #!/usr/bin/txr
  @(bind a "Hey")
  @(output)
  Hello, world!
  @(end)
  $ chmod a+x hello.txr
  $ ./hello.txr
  Hello, world!

When this plain hash bang line is used, txr receives the name of the script
as an argument.  Therefore, it is not possible to pass additional options
to txr.  For instance, if the above script is invoked like this

  $ ./hello.txr -B

the -B option isn't processed by txr, but treated as an additional argument,
just as if "txr <scriptname> -B" had been executed directly.

This behavior is useful if the script author wants not to expose the txr
options to the user of the script.

However, the hash bang line can use the -f option:

  #!/usr/bin/txr -f

Now, the name of the script is passed as an argument to the -f option,
and TXR will look for more options after that, so that the resulting
program appears to accept TXR options. Now we can run

  $ ./hello.txr -B
  Hello, world!
  a="Hey"

The -B option is honored.

On some operating systems, it is not possible to pass more than one
argument through the hash bang mechanism. That is to say, this will
not work.

  #!/usr/bin/txr -B -f

To support systems like this, TXR supports special argument called
--args.  With --args, it is possible to encode multiple arguments
into one argument.  The --args option must be followed by a separator
character, chosen by the programmer. The characters after that are
split into multiple arguments on the separator character. The --args
option is then removed from the argument list and replaced with these
arguments, which are processed in its place.

Example:

  #!/usr/bin/txr --args:-B:-f

The above has the same behavior as

  #!/usr/bin/txr -B -f

on a system which supports multiple arguments in hash bang.
The separator character is the colon, and so the remainder
of that argument, -B:-f, is split into the two arguments -B -f.

.SS Whitespace

Outside of directives, whitespace is significant in TXR queries, and represents
a pattern match for whitespace in the input.  An extent of text consisting of
an undivided mixture of tabs and spaces is a whitespace token.  

Whitespace tokens match a precisely identical piece of whitespace in the input,
with one exception: a whitespace token consisting of precisely one space has a
special meaning. It is equivalent to the regular expression @/[ ]+/: match
an extent of one or more spaces (but not tabs!)

Thus, the query line "a b" (one space) matches texts like "a b", "a   b", et
cetera (arbitrary number of tabs and spaces between a and b).  However "a  b"
(two spaces) matches only "a  b" (two spaces).

For matching a single space, the syntax @\e can be used (backslash-escaped
space).

It is more often necessary to match multiple spaces, than to exactly
match one space, so this rule simplifies many queries and adds inconvenience
to only few.

In output clauses, string and character literals and quasiliterals, a space
token denotes a space.

.SS Text

Query material which is not escaped by the special character @ is
literal text, which matches input character for character. Text which occurs at
the beginning of a line matches the beginning of a line.  Text which starts in
the middle of a line, other than following a variable, must match exactly at
the current position, where the previous match left off. Moreover, if the text
is the last element in the line, its match is anchored to the end of the line.

An empty query line matches an empty line in the input. Note that an
empty input stream does not contain any lines, and therefore is not matched
by an empty line. An empty line in the input is represented by a newline
character which is either the first character of the file, or follows
a previous newline-terminated line.  

Input streams which end without terminating their last line with a newline are
tolerated, and are treated as if they had the terminator.

Text which follows a variable has special semantics, discussed in the
section Variables below.

A query may not leave unmatched material in a line which is covered by the
query.  However, a query may leave unmatched lines.

In the following example, the query matches the text, even though
the text has an extra line.

 Query:         Four score and seven
                years ago our

 Text:          Four score and seven
                years ago our
                forefathers

In the following example, the query
.B fails
to match the text, because the text has extra material on one
line.

 Query:         I can carry nearly eighty gigs
                in my head

 Text:          I can carry nearly eighty gigs of data
                in my head

Needless to say, if the text has insufficient material relative
to the query, that is a failure also.

To match arbitrary material from the current position to the end
of a line, the "match any sequence of characters, including empty"
regular expression @/.*/ can be used. Example:

 Query:         I can carry nearly eighty gigs@/.*/

 Text:          I can carry nearly eighty gigs of data

In this example, the query matches, since the regular expression
matches the string "of data". (See Regular Expressions section below).

Another way to do this is:

 Query:         I can carry nearly eighty gigs@(skip)


.SS Special Characters in Text

Control characters may be embedded directly in a query (with the exception of
newline characters). An alternative to embedding is to use escape syntax.
The following escapes are supported:

.IP @\e<newline>
A backslash immediately followed by a newline introduces a physical line
break without breaking up the logical line. Material following this sequence
continues to be interpreted as a continuation of the previous line, so
that indentation can be introduced to show the continuation without appearing
in the data.
.IP @\e<space>
A backslash followed by a space encodes a space. This is useful in line
continuations when it is necessary for leading spaces to be preserved.
For instance the two line sequence

   abcd@\
     @\e  efg

is equivalent to the line

  abcd  efg

The two spaces before the @\e in the second line are consumed. The
spaces after are preserved.

.IP @\ea
Alert character (ASCII 7, BEL).
.IP @\eb
Backspace (ASCII 8, BS).
.IP @\et
Horizontal tab (ASCII 9, HT).
.IP @\en
Line feed (ASCII 10, LF). Serves as abstract newline on POSIX systems.
.IP @\ev
Vertical tab (ASCII 11, VT).
.IP @\ef
Form feed (ASCII 12, FF). This character clears the screen on many
kinds of terminals, or ejects a page of text from a line printer.
.IP @\er
Carriage return (ASCII 13, CR).
.IP @\ee
Escape (ASCII 27, ESC)
.IP @\exHEX
A @\ex followed by a sequence of hex digits is interpreted as a hexadecimal
numeric character code. For instance @\ex41 is the ASCII character A.
.IP @\eOCTAL
A @\e followed by a sequence of octal digits (0 through 7) is interpreted
as an octal character code. For instance @\e010 is character 8, same as @\eb.
.PP

Note that if a newline is embedded into a query line with @\en, this
does not split the line into two; it's embedded into the line and
thus cannot match anything. However, @\en may be useful in the @(cat)
directive and in @(output).

.SS Character Handling and International Characters

.B TXR
represents text internally using wide characters, which are used to represent
Unicode code points. The query language, as well as all data sources, are
assumed to be in the UTF-8 encoding.  In the query language, extended
characters can be used directly in comments, literal text, string literals,
quasiliterals and regular expressions.  Extended characters can also be
expressed indirectly using hexadecimal or octal escapes.
On some platforms, wide characters may be restricted to 16 bits, so that
.B TXR
can only work with characters in the BMP (Basic Multilingual Plane)
subset of Unicode.

.B TXR
does not use the localization features of the system library;
its handling of extended characters is not affected by environment variables
like LANG and L_CTYPE. The program reads and writes only the UTF-8 encoding.

If
.B TXR
encounters an invalid bytes in the UTF-8 input, what happens depends on the
context in which this occurs. In a query, comments are read without regard
for encoding, so invalid encoding bytes in comments are not detected. A comment
is simply a sequence of bytes terminated by a newline.  In lexical elements
which represent text, such as string literals, invalid or unexpected encoding
bytes are treated as syntax errors. The scanner issues an error message,
then discards a byte and resumes scanning.  Certain sequences pass through the
scanner without triggering an error, namely some UTF-8 overlong sequences.
These are caught when when the lexeme is subject to UTF-8 decoding, and treated
in the same manner as other UTF-8 data, described in the following paragraph.

Invalid bytes in data are treated as follows. When an invalid byte is
encountered in the middle of a multibyte character, or if the input
ends in the middle of a multibyte character, or if a character is extracted
which is encoded as an overlong form, the UTF-8 decoder returns to the starting
byte of the ill-formed multibyte character, and extracts just that byte,
mapping it to the Unicode character range U+DC00 through U+DCFF.  The decoding
resumes afresh at the following byte, expecting that byte to be the start
of a UTF-8 code.

Furthermore, because TXR internally uses a null-terminated character
representation of strings which easily interoperates with C language
interfaces, when a null character is read from a stream, TXR converts it to
the code U+DC00. On output, this code converts back to a null byte,
as explained in the previous paragraph. By means of this representational
trick, TXR can handle textual data containing null bytes.

.SS Regular Expression Directives

In place of a piece of text (see section Text above), a regular expression
directive may be used, which has the following syntax:

  @/RE/

where the RE part enclosed in slashes represents regular expression
syntax (described in the section Regular Expressions below).

Long regular expressions can be broken into multiple lines using a
backslash-newline sequence.  Whitespace before the sequence or after the
sequence is not significant, so the following two are equivalent:

  @/reg \e
    ular/

  @/regular/

There may not be whitespace between the backslash and newline.

Whereas literal text simply represents itself, regular expression denotes a
(potentially infinite) set of texts.  The regular expression directive
matches the longest piece of text (possibly empty) which belongs to the set
denoted by the regular expression. The match is anchored to the current
position; thus if the directive is the first element of a line, the match is
anchored to the start of a line. If the regular expression directive is the
last element of a line, it is anchored to the end of the line also: the regular
expression must match the text from the current position to the end of the
line.

Even if the regular expression matches the empty string, the match will fail if
the input is empty, or has run out of data. For instance suppose the third line
of the query is the regular expression @/.*/, but the input is a file which has
only two lines. This will fail: the data has line for the regular expression to
match. A line containing no characters is not the same thing as the absence of
a line, even though both abstractions imply an absence of characters.

Like text which follows a variable, a regular expression directive which
follows a variable has special semantics, discussed in the section Variables
below.

.SS Variables

Much of the query syntax consists of arbitrary text, which matches file data
character for character. Embedded within the query may be variables and
directives which are introduced by a @ character.  Two consecutive @@
characters encode a literal @.

A variable matching or substitution directive is written in one of several
ways:

  @NAME
  @{NAME}
  @*NAME
  @*{NAME}
  @{NAME /RE/}
  @{NAME (FUN [ ARGS ... ])}
  @{NAME NUMBER}

The forms with an * indicate a long match, see Longest Match below.
The last two forms with the embedded regexp /RE/ or number have special
semantics, see Positive Match below.

The identifier t cannot be used as a name; it is a reserved symbol which
denotes the value true. An attempt to use the variable @t will result
in an exception.  The symbol nil can be used as a variable name,
but it has special semantics, described in a section below.

When the @NAME form is used, the name itself may consist of any combination of
one or more letters, numbers, and underscores. It may not look like a number,
so that for instance 123 is not a valid name, but 12A is valid.  Case is
sensitive, so that @FOO is different from @foo, which is different from @Foo.

The braces around a name can be used when material which follows would
otherwise be interpreted as being part of the name. When a name is enclosed in
braces, the following additional characters may be used as part of the name:

 ! $ % & * + - < = > ? \e ^ _ ~

The rule holds that a name cannot look like a number so +123 is not a name,
but these are valid names: a->b, *xyz*, foo-bar.

The syntax @FOO_bar introduces the name "FOO_bar", whereas @{FOO}_bar means the
variable named "FOO" followed by the text "_bar".   There may be whitespace
between the @ and the name, or opening brace. Whitespace is also allowed in the
interior of the braces. It is not significant.

If a variable has no prior binding, then it specifies a match. The
match is determined from some current position in the data: the
character which immediately follows all that has been matched previously.
If a variable occurs at the start of a line, it matches some text
at the start of the line. If it occurs at the end of a line, it matches
everything from the current position to the end of the line.

.SS Negative Match

If a variable is one of the plain forms @NAME, @{NAME},  @*NAME or @*{NAME},
then this is a "negative match".  The extent of the matched text (the text
bound to the variable) is determined by looking at what follows the variable,
and ranges from the current position to some position where the following
material finds a match. This is why this is called a "negative match": the
spanned text which ends up bound to the variable is that in which the match for
the trailing material did not occur.

A variable may be followed by a piece of text, a regular expression directive,
a function call, a directive, another variable, or nothing (i.e.  occurs at the
end of a line). These cases are discussed in detail below.

.SS Variable Followed by Nothing

If the variable is followed by nothing, the negative match extends from the
current position in the data, to the end of the line.  Example:

  pattern:      "a b c @FOO"
  data:         "a b c defghijk"
  result:       FOO="defghijk"

.SS Variable Followed by Text

For the purposes of determining the negative match, text is defined as a
sequence of literal text and regular expressions, not divided by a directive.
So for instance in this example:

  @a:@/foo/bcd e@(maybe)f@(end)

the variable @a is considered to be followed by ":@/foo/bcd e".

If a variable is followed by text, then the extent of the negative match is
determined by searching for the first occurrence of that text within the line,
starting at the current position. 

The variable matches everything between the current position and the matching
position (not including the matching position). Any whitespace which follows
the variable (and is not enclosed inside braces that surround the variable
name) is part of the text. For example:

  pattern:      "a b @FOO e f"
  data:         "a b c d e f"
  result:       FOO="c d"

In the above example, the pattern text "a b " matches the
data "a b ". So when the @FOO variable is processed, the data being
matched is the remaining "c d e f". The text which follows @FOO
is " e f". This is found within the data "c d e f" at position 3
(counting from 0).  So positions 0-2 ("c d") constitute the matching
text which is bound to FOO.

.SS Variable Followed by a Function Call or Directive

If the variable is followed by a function call, or a directive, the extent is
determined by scanning the text for the first position where a match occurs
for the entire remainder of the line. (For a description of functions,
see FUNCTIONS.)

For example:

  @foo@(bind a "abc")xyz

Here, foo will match the text from the current position to where "xyz"
occurs, even though there is a @(bind) directive. Furthermore, if
more material is added after the xyz, it is part of the search.
Note the difference between the following two:

  @foo@/abc/@(func)
  @foo@(func)@/abc/

In the first example, the variable foo matches the text from the current
position until the match for the regular expression abc. @(func) is not
considered when processing @foo.  In the second example, the variable foo
matches the text from the current position until the position whcih matches
the function call, followed by a match for the regular expression.
The entire sequence @(func)@/abc/ is considered.

.SS Consecutive Variables

If an unbound variable specified a fixed-width match or a regular expression,
then the issue of consecutive variables does not arise. Such a variable
consumes text regardless of any context which follows it.

However, what if an unbound variable with no modifier is followed by another
variable? The behavior depends on the nature of the other variable.

If the other variable also has no modifier, this is a semantic error which
will cause the query to fail.  A diagnostic message will be issued, unless
operating in quiet mode via -q.  The reason is that there is no way to bind two
consecutive variables to an extent of text; this is an ambiguous situation,
since there is no matching criterion for dividing the text between two
variables.  (In theory, a repetition of the same variable, like @FOO@FOO, could
find a solution by dividing the match extent in half, which would work only in
the case when it contains an even number of characters.  This behavior seems to
have dubious value).

An unbound variable may be followed by one which is bound. The bound
variable is replaced by the text which it denotes, and the logic proceeds
accordingly.  Variables are never bound to regular expressions, so
the regular expression match does not arise in this case.
The @* syntax for longest match is available. Example:

  pattern:      "@FOO:@BAR@FOO"
  data:         "xyz:defxyz"
  result:       FOO=xyz, BAR=def

Here, FOO is matched with "xyz", based on the delimiting around the
colon. The colon in the pattern then matches the colon in the data,
so that BAR is considered for matching against "defxyz".
BAR is followed by FOO, which is already bound to "xyz".
Thus "xyz" is located in the "defxyz" data following "def",
and so BAR is bound to "def".

If an unbound variable is followed by a variable which is bound to a list, or
nested list, then each character string in the list is tried in turn to produce
a match. The first match is taken.

An unbound variable may be followed by another unbound variable which specifies
a regular expression or function call match. This is a special case called a
"double variable match".  What happens is that the text is searched using the
regular expression or function.  If the search fails, than neither variable is
bound: it is a matching failure.  If the search succeeds, than the first
variable is bound to the text which is skipped by the search.  The second
variable is bound to the text matched by the regular expression or function.
Examples:

  pattern:      "@foo@{bar /abc/}"
  data:         "xyz@#abc"
  result:       foo="xyz@#", BAR="abc"


.SS Consecutive Variables Via Directive

Two variables can be de facto consecutive in a manner shown in the
following example:

  @var1@(all)@var2@(end)

This is treated just like the variable followed by directive. No semantic
error is identified, even if both variables are unbound. Here, @var2
@var2 matches everything at the current position, and so @var1 ends up
bound to the empty string.

Example 1: b matches at position 0 and a gets nothing:

  pattern:      "@a@(all)@b@(end)"
  data:         "abc"
  result:       a=""
                b="abc"

Example 2: *a specifies longest match (see Longest Match below), and so a gets
everything:

  pattern:      "@*a@(all)@b@(end)"
  data:         "abc"
  result:       a="abc"
                b=""



.SS Longest Match

The closest-match behavior for the negative match can be overridden to longest
match behavior. A special syntax is provided for this: an asterisk between the
@ and the variable, e.g:

  pattern:      "a @*{FOO}cd"
  data:         "a b cdcdcdcd"
  result:       FOO="b cdcdcd"

  pattern:      "a @{FOO}cd"
  data:         "a b cdcdcd"
  result:       FOO="b "

In the former example, the match extends to the rightmost occurrence of "cd",
and so FOO receives "b cdcdcd".  In the latter example, the *
syntax isn't used, and so a leftmost match takes place. The extent
covers only the "b ", stopping at the first "cd" occurrence.

.SS Positive Match

There are syntax variants of variable syntax which have an embedded expression
enclosed with the variable in braces:

 @{NAME /RE/}
 @{NAME (FUN [ARGS ...])}
 @{NAME NUMBER}

These specify a variable binding that is driven by a positive match derived
from a regular expression, function or character count, rather than from
trailing material (which is regarded as a "negative" match, since the
variable is bound to material which is
.B skipped
in order to match the trailing material). In the /RE/ form, the match
extends over all characters from the current position which match
the regular expression RE. (see Regular Expressions section below).
In the (FUN [ARGS ...]) form, the match extends over characters which
are matched by the call to the function, if the call
succeeds. Thus @{x (y z w)} is just like @(y z w), except that the region of
text skipped over by @(y z w) is also bound to the variable x.
See FUNCTIONS below.

In the NUMBER form, the match processes a field of text which
consists of the specified number of characters, which must be non-negative
number.  If the data line doesn't have that many characters starting at the
current position, the match fails. A match for zero characters produces an
empty string.  The text which is actually matched by this construct
is all text within the specified field, but excluding leading and
trailing whitespace. If the field contains only spaces, then an empty
string is extracted.

This syntax is processed without consideration of what other
syntax follows.  A positive match may be directly followed by an unbound
variable.

.SS Symbol nil as a Variable

If the symbol nil is used as a variable, it behaves like a variable which
has no binding. Furthermore, no binding is created. @nil allows the
variable matching syntax to be used to skip material, in ways different
from and complementary to @(skip).

.SS Regular Expressions

Regular expressions are a language for specifying sets of character strings.
Through the use of pattern matching elements, regular expression is
able to denote an infinite set of texts.
.B TXR
contains an original implementation of regular expressions, which
supports the following syntax:
.IP .
(period) is a "wildcard" that matches any character.
.IP []
Character class: matches a single character, from the set specified by
special syntax written between the square brackets.
Supports basic regexp character class syntax; no POSIX
notation like [:digit:]. The regex tokens \es, \ed and \ew are
permitted in character classes, but not their complementing counterparts.
These tokens simply contribute their characters to the class.
The class [a-zA-Z] means match an uppercase
or lowercase letter; the class [0-9a-f] means match a digit or
a lowercase letter; the class [^0-9] means match a non-digit, et cetera.
There are no locale-specific behaviors in TXR regular expressions;
[A-Z] denotes an ASCII/Unicode range of characters.
The class [\ed.] means match a digit or the period character.
A ] or - can be used within a character class, but must be escaped
with a backslash. A ^ in the first position denotes a complemented
class, unless it is escaped by backslash. In any other position, it denotes
itself.  Two backslashes code for one backslash. So for instance
[\e[\e-] means match a [ or - character, [^^] means match any character other
than ^, and [\e^\e\e] means match either a ^ or a backslash. Regex operators
such as *, + and & appearing in a character class represent ordinary
characters. The characters -, ] and ^ occurring outside of a character class
are ordinary. Unescaped / characters can appear within a character class. The
empty character class [] matches no character at all, and its complement [^]
matches any character, and is treated as a synonym for the . (period) wildcard
operator.
.IP "\es, \ew and \ed"
These regex tokens each match a single character. 
The \es regex token matches a wide variety of ASCII whitespace characters
and Unicode spaces. The \ew token matches alphabetic word characters; it
is equivalent to the character class [A-Za-z_]. The \ed token matches
a digit, and is equivalent to [0-9].
.IP "\eS, \eW and \eD"
These regex tokens are the complemented counterparts of \es, \ew and \ed.
The \eS token matches all those characters which \es does not match,
\eW matches all characters that \ew does not match and \eD matches nondigits.
.IP empty
An empty expression is a regular expression. It represents the set of strings
consisting of the empty string; i.e. it matches just the empty string. The
empty regex can appear alone as a full regular expression (for instance the
.B TXR
syntax @// with nothing between the slashes)
and can also be passed as a subexpression to operators, though this
may require the use of parentheses to make the empty regex explicit.  For
example, the expression a| means: match either a, or nothing.  The forms
* and (*)  are syntax errors; though not useful, the correct way to match the
empty expression zero or more times is the syntax ()*.
.IP nomatch
The nomatch regular expression represents the
empty set: it matches no strings at all, not even the empty string.
There is no dedicated syntax to directly express nomatch in the regex language.
However, the empty character class [] is equivalent to nomatch, and may be
considered to be a notation for it. Other representations of nomatch are
possible: for instance, the regex ~.* which is the complement of the regex that
denotes the set of all possible strings, and thus denotes the empty set. A
nomatch has uses; for instance, it can be used to temporarily "comment out"
regular expressions. The regex ([]abc|xyz) is equivalent to (xyz), since the
[]abc branch cannot match anything. Using [] to "block" a subexpression allows
you to leave it in place, then enable it later by removing the "block".
.IP (R)
If R is a regular expression, then so is (R).
The contents of parentheses denote one regular expression unit, so that for
instance in (RE)*, the * operator applies to the entire parenthesized group.
The syntax () is valid and equivalent to the empty regular expression.
.IP R?
optionally match the preceding regular expression R.
.IP R*
match the expression R zero or more times. This
operator is sometimes called the "Kleene star", or "Kleene closure".
The Kleene closure favors the longest match. Roughly speaking, if there are two
or more ways in which R1*R2 can match, than that match occurs in which
R1* matches the longest possible text.
.IP R+
match the preceding expression R one or more times.
Like R*, this favors the longest possible match: R+ is equivalent to RR*.
.IP R1%R2
match R1 zero or more times, then match R2. If this match can occur in
more than one way, then it occurs such that R1 is matched the fewest
number of times, which is opposite from the behavior of R1*R2.
Repetitions of R1 terminate at the earliest
point in the text where a non-empty match for R2 occurs. Because
it favors shorter matches, % is termed a non-greedy operator.  If R2 is the
empty expression, or equivalent to it, then R1%R2 reduces to R1*.  So for
instance (R%) is equivalent to (R*), since the missing right operand is
interpreted as the empty regex. Note that whereas the expression
(R1*R2) is equivalent to (R1*)R2, the expression (R1%R2) is 
.B not
equivalent to (R1%)R2.
.IP ~R
match the opposite of the following expression R; i.e. match exactly
those texts that R does not match. This operator is called complement,
or logical not.
.IP R1R2
Two consecutive regular expressions denote catenation:
the left expression must match, and then the right.
.IP R1|R2
match either the expression R1 or R2. This operator is known by
a number of names: union, logical or, disjunction, branch, or alternative.
.IP R1&R2
match both the expression R1 and R2 simultaneously; i.e. the
matching text must be one of the texts which are in the intersection of the set
of texts matched by R1 and the set matched by R2. This operator is called
intersection, logical and, or conjunction.

.PP
Any escaped character which does not fall into the above escaping conventions,
or any unescaped character which is not a regular expression operator, denotes
one-position match of that character itself.

Any of the special characters, including the delimiting /,  can be escaped with
a backslash to suppress its meaning and denote the character itself.

Furthermore, all of the same escapes as are described in the section Special
Characters in Text above are supported - the difference is that in regular
expressions, the @ character is not required, so for example a tab is coded as
\et rather than @\et. Octal and hex character escapes can be optionally
terminated by a semicolon, which is useful if the following characters are
octal or hex digits not intended to be part of the escape.

Precedence table, highest to lowest:
.TS
tab(!);
l l l.
operators!class!associativity
(R) []!primary!
R? R+ R* R%...!postfix!left-to-right
R1R2!catenation!left-to-right
~R ...%R!unary!right-to-left
R1&R2!intersection!left-to-right
R1|R2!union!left-to-right
.TE

The % operator is like a postfix operator with respect to its left
operand, but like a unary operator with respect to its right operand.
Thus a~b%c~d  is a(~(b%(c(~d)))), demonstrating right-to-left associativity,
where all of b% may be regarded as a unary operator being applied to c~d. 
Similarly, a?*+%b  means (((a?)*)+)%b, where the trailing %b behaves
like a postfix operator.

In
.B TXR,
regular expression matches do not span multiple lines. The regex language has
no feature for multi-line matching. However, the @(freeform) directive
allows the remaining portion of the input to be treated as one string
in which line terminators appear as explicit characters. Regular expressions
may freely match through this sequence.

It's possible for a regular expression to match an empty string.
For instance, if the next input character is z, facing a
the regular expression /a?/, there is a zero-character match:
the regular expression's state machine can reach an acceptance
state without consuming any characters. Examples:

  pattern:      @A@/a?/@/.*/
  data:         zzzzz
  result:       A=""

  pattern:      @{A /a?/}@B
  data:         zzzzz
  result:       A="", B="zzzz"

  pattern:      @*A@/a?/
  data:         zzzzz
  result:       A="zzzzz"

In the first example, variable @A is followed by a regular expression
which can match an empty string. The expression faces the letter "z"
at position 0 in the data line. A zero-character match occurs there,
therefore the variable A takes on the empty string. The @/.*/ regular
expression then consumes the line.

Similarly, in the second example, the /a?/ regular expression faces
a "z", and thus yields an empty string which is bound to A. Variable
@B consumes the entire line.

The third example requests the longest match for the variable binding.
Thus, a search takes place for the rightmost position where the
regular expression matches. The regular expression matches anywhere,
including the empty string after the last character, which is
the rightmost place. Thus variable A fetches the entire line.

For additional information about the advanced regular expression
operators, NOTES ON EXOTIC REGULAR EXPRESSIONS below.

.SS Directives

The general syntax of a directive is:

  @EXPR

where expr is a parenthesized list of subexpressions. A subexpression
is a symbol, number, string literal, character literal, quasiliteral, regular
expression, or a parenthesized expression.  So, examples of syntactically valid
directives are:

  @(banana)

  @(a b c (d e f))

  @(  a (b (c d) (e  ) ))

  @("apple" #\eb #\espace 3)

  @(a #/[a-z]*/ b)

  @(_ `@file.txt`)

A symbol is lexically the same thing as a variable name (the type enclosed
in braces in the @{NAME} syntax) and the same rules apply: it can consist
of all the same characters, and must not look like a number. Tokens that look
like numbers are treated as numbers.

.SS Special Symbols

Just like in the programming language Lisp, the names nil and t cannot be used
as variables. They always represent themselves, and have many uses, internal to
the program as well as externally visible. The nil symbol stands for the empty
list object, an object which marks the end of a list, and boolean false. It is
synonymous with the syntax () which may be used interchangeably with nil in
most constructs.

.SS Keyword Symbols

Names whose names begin with the : character are keyword symbols.  These also
may not be used as variables either and stand for themselves. Keywords are
useful for labeling information and situations. 

.SS Character Literals

Character literals are introduced by the #\e syntax, which is either
followed by a character name, the letter x followed by hex digits,
the letter o followed by octal digits, or a single character. Valid character
names are: nul, alarm, backspace, tab, linefeed, newline, vtab, page, return,
esc, space and pnul. This convention for character literals is similar to that
of the Scheme language.  Note that #\elinefeed and #\enewline are the same
character. The #\epnul character is specific to TXR and denotes the U+DC00
code in Unicode; the name stands for "pseudo-null", which is related to
its special function. For more information about this, see the section
"Character Handling and International Characters".

.SS String Literals

String literals are delimited by double quote respectively.
A double quote within a string literal is encoded using \e"
and a backslash is encoded as \e\e. Backslash escapes like \en and \et
are recognized, as are hexadecimal escapes like \exFF or \exxabc and octal
escapes like \e123.  Ambiguity between an escape and subsequent
text can be resolved by using trailing semicolon delimiter: "\exabc;d" is a
string consisting of the character U+0ABC followed by "d". The semicolon
delimiter disappears. To write a literal semicolon immediately after a hex
or octal escape, write two semicolons, the first of which will be interpreted
as a delimiter. Thus, "\ex21;;" represents "!;".

If the line ends in the middle of a literal, it is an error, unless the
last character is a backslash. This backslash is a special escape which does
not denote a character; rather, it indicates that the string literal continues
on the next line.  The backslash is deleted, along with whitespace which
immediately precedes it, as well as leading whitespace in the following line.
The escape sequence "\e " (backslash space) can be used to encode a
significant space.

Example:

   "foo   \e
    bar"

   "foo   \e
   \ bar"

   "foo\  \e
    bar"

The first string literal is the string "foobar". The second two are "foo bar".

.SS Word List Literals

A word list literal (WLL) provides a convenient way to write a list of strings
when such a list can be given as whitespace-delimited words.

There are two flavors of the WLL: the regular WLL which begins with #" (hash,
double-quote) and the splicing list literal which begins with #*" (hash, star,
double-quote).

Both types are terminated by a double quote, which may be escaped
as \e" in order to include it as a character. All the escaping conventions
used in string literals can be used in word literals.

Unlike in string literals, whitespace (tabs, spaces and newlines) is not
significant in word literals: it separates words.  Whitespace may be
escaped with a backslash in order to include it as a literal character.


Example:

  #"abc def ghi"  --> notates ("abc" "def" "ghi")

  #"abc   def
  ghi"            --> notates ("abc" "def" "ghi")

  #"abc\ def ghi" --> notates ("abc def" "ghi")

A splicing word literal differs from a word literal in that it does not
produce a list of string literals, but rather it produces a sequence of string
literals that is merged into the surrounding syntax.

Example:

  (1 2 3 #*"abc def" 4 5 #"abc def")

  --> (1 2 3 "abc" "def" 4 5 ("abc" "def"))

The regular WLL produced a single list object, but the splicing
WLL expanded into multiple string literal objects.

.SS String Quasiliterals

Quasiliterals are similar to string literals, except that they may
contain variable references denoted by the usual @ syntax. The quasiliteral
represents a string formed by substituting the values of those variables
into the literal template. If a is bound to "apple" and b to "banana",
the quasiliteral `one @a and two @{b}s` represents the string
"one apple and two bananas". A backquote escaped by a backslash represents
itself, and two consecutive @ characters code for a literal @.
There is no \e@ escape.  Quasiliterals support the full output variable
syntax. Expressions within variables substitutions follow the evaluation rules
of TXR Lisp when the quasiliteral occurs in TXR Lisp, and the rules of
the TXR pattern language when the quasiliteral occurs in the pattern language.

Quasiliterals can be split into multiple lines in the same way as ordinary
string literals.

.SS Quasiword List Literals

The quasiword list literals (QLL-s) are to quasiliterals what WLL-s are to
ordinary literals. (See the above section Word List Literals.)

A QLL combines the convenience of the WLL
with the power of quasistrings.

Just as in the case of WLL-s, there are two flavors of the
QLL: the regular QLL which begins with #`
(hash, backquote) and the splicing list literal which begins with #*` (hash,
star, backquote).

Both types are terminated by a backquote, which may be escaped
as \e` in order to include it as a character. All the escaping conventions
used in quasiliterals can be used in QLL.

Unlike in quasiliterals, whitespace (tabs, spaces and newlines) is not
significant in QLL: it separates words.  Whitespace may be
escaped with a backslash in order to include it as a literal character.

Note that the delimiting into words is done before the variable
substitution. If the variable a contains spaces, then #`@a` nevertheless
expands into a list of one item: the string derived from a.

Example:

  #`abc @a ghi`  --> notates (`abc` `@a` `ghi`)

  #`abc   @d@e@f
  ghi`            --> notates (`abc` `@d@e@f` `ghi`)

  #`@a\ @b @c` --> notates (`@a @b` `@c`)

A splicing QLL differs from an ordinary QLL in that it does not produce a list
of quasiliterals, but rather it produces a sequence of quasiliterals that is
merged into the surrounding syntax.

.SS Numbers

TXR supports integers and floating-point numbers. 

An integer constant is made up of digits 0 through 9, optionally preceded by a
+ or - sign.

Examples:

  123
  -34
  +0
  -0
  +234483527304983792384729384723234

An integer constant can also be specified in hexadecimal using the prefix
#x followed by an optional sign, followed by hexadecimal digits: 0 through 9
and the upper or lower case letters A through F:

  #xFF    ;; 255
  #x-ABC  ;; -2748

Similarly, octal numbers are supported with the prefix #o followed by 
octal digits:

  #o777   ;; 511

and binary numbers can be written with a #b prefix:

  #b1110  ;; 14

A floating-point constant is marked by the inclusion of a decimal point, the
exponential "e notation", or both. It is an optional sign, followed
by a mantissa consisting of digits, a decimal point, more digits, and then an
optional exponential notation consisting of the letter "e" or "E", an optional
"+" or "-" sign, and then digits indicating the exponent value.
In the mantissa, the digits are not optional. At least one digit must either
precede the decimal point or follow. That is to say, a decimal point by itself
is not a floating-point constant.

Examples:

  .123
  123.
  1E-3
  20E40
  .9E1
  9.E19
  -.5
  +3E+3

Examples which are not floating-point constant tokens:

  .       (consing dot)
  123E    (the symbol 123E)
  1.0E-   (syntax error: invalid floating point constant)
  1.0E    (syntax error: invalid floating point constant)
  1.E     (1; consing dot; symbol E)
  .e      (consing dot followed by symbol e)

In TXR there is a special "dotdot" token consisting of two consecutive periods.
An integer constant followed immediately by dotdot is recognized as such; it is
not treated as a floating constant followed by a dot. That is to say,
123.. does not mean 123. . (floating point 123.0 value followed by dot token).
It means 123 .. (integer 123 followed by .. token).

Dialect note: unlike in Common Lisp, 123. is not an integer, but the same as
123.0.

.SS Comments

Comments of the form @; were already covered. Inside directives,
comments are introduced just by a ; character.

Example:

  @(foo  ; this is a comment
    bar  ; this is another comment 
    )

This is equivalent to @(foo bar).

.SS Directives-driven Syntax

Some directives not only denote an expression, but are also involved in
surrounding syntax. For instance, the directive

  @(collect)

not only denotes an expression, but it also introduces a syntactic phrase which
requires a matching @(end) directive. So in other words, @(collect) is not only
an expression, but serves as a kind of token in a higher level phrase structure
grammar.

Usually if this type of "syntactic directive" occurs alone in a line, not
preceded or followed by other material, it is involved in a "vertical" (or line
oriented) syntax.

If such a directive is embedded in a line (has preceding or trailing material)
then it is in a horizontal syntactic and semantic context (character-oriented).

There is an exception: the definition of a horizontal function looks like this:

  @(define name (arg))body material@(end)

Yet, this is considered one vertical item, which means that it does not match
a line of data. (This is necessary because all horizontal syntax matches
something within a line of data.)

Many directives have a horizontal and vertical syntax, with different but
closely related semantics. A few are still "vertical only", and some are
horizontal only but in future releases, these exceptions will be minimized.

A summary of the available directives follows:

.IP @(eof)
Explicitly match the end of file. Fails if unmatched data remains in
the input stream.

.IP @(eol)
Explicitly match the end of line. Fails if the current position is not the
end of a line. Also fails if no data remains (there is no current line).

.IP @(next)
Continue matching in another file or other data source.

.IP @(block)
Groups together a sequence of directives into a logical name block,
which can be explicitly terminated from within using
the @(accept) and @(fail) directives.
Blocks are discussed in the section BLOCKS below.

.IP @(skip)
Treat the remaining query as a subquery unit, and search the lines (or
characters) of the input file until that subquery matches somewhere.  A skip is
also an anonymous block.

.IP @(trailer)
Treat the remaining query or subquery as a match for a trailing context. That
is to say, if the remainder matches, the data position is not advanced.

.IP @(freeform)
Treat the remainder of the input as one big string, and apply the following
query line to that string. The newline characters (or custom separators) appear
explicitly in that string.

.IP @(fuzz)
The fuzz directive, inspired by the patch utility, specifies a partial
match for some lines.

.IP @(some)
Multiple clauses are each applied to the same input. Succeeds if at least one
of the clauses matches the input. The bindings established by earlier
successful clauses are visible to the later clauses.

.IP @(all)
Multiple clauses are applied to the same input. Succeeds if and only if each
one of the clauses matches. The clauses are applied in sequence, and evaluation
stops on the first failure. The bindings established by earlier successful
clauses are visible to the later clauses.

.IP @(none)
Multiple clauses are applied to the same input. Succeeds if and only if none of
them match. The clauses are applied in sequence, and evaluation stops on the
first success. No bindings are ever produced by this construct.

.IP @(maybe)
Multiple clauses are applied to the same input. No failure occurs if none of
them match.  The bindings established by earlier successful clauses are visible
to the later clauses.

.IP @(cases)
Multiple clauses are applied to the same input. Evaluation stops on the
first successful clause.

.IP @(require)
The require directive is similar to the do directive: it evaluates one or more
TXR Lisp expressions.  If the result of the rightmost expression is nil,
then require triggers a match failure.  See the TXR LISP section far below.

.IP "@(if), @(elif), @(else)"
The if directive with optional elif and else clauses is a syntactic sugar
which translates to a combination of @(cases) and @(require)

.IP @(choose)
Multiple clauses are applied to the same input. The one whose effect persists
is the one which maximizes or minimizes the length of a particular variable.

.IP @(empty)
The @(empty) directive matches the empty string. It is useful in certain
situations, such as expressing an empty match in a directive that doesn't
accept an empty clause. The @(empty) syntax has another meaning in
@(output) clauses, in conjunction with @(repeat).

.IP "@(define NAME ( ARGUMENTS ...))"
Introduces a function. Functions are discussed in the FUNCTIONS section below.

.IP @(gather)
Searches text for matches for multiple clauses which may occur in arbitrary
order. For convenience, lines of the first clause are treated as separate
clauses.

.IP @(collect)
Search the data for multiple matches of a clause. Collect the
bindings in the clause into lists, which are output as array variables.
The @(collect) directive is line oriented. It works with a multi-line
pattern and scans line by line. A similar directive called @(coll)
works within one line.

A collect is an anonymous block.

.IP @(and)
Separator of clauses for @(some), @(all), @(none), @(maybe) and @(cases).
Equivalent to @(or). Choice is stylistic.

.IP @(or)
Separator of clauses for @(some), @(all), @(none), @(maybe) and @(cases).
Equivalent to @(and). Choice is stylistic.

.IP @(end)
Required terminator for @(some), @(all), @(none), @(maybe), @(cases), @(if),
@(collect), @(coll), @(output), @(repeat), @(rep), @(try), @(block) and @(define).

.IP @(fail)
Terminate the processing of a block, as if it were a failed match.
Blocks are discussed in the section BLOCKS below.

.IP @(accept)
Terminate the processing of a block, as if it were a successful match.
What bindings emerge may depend on the kind of block: collect
has special semantics.  Blocks are discussed in the section BLOCKS below.

.IP @(try)
Indicates the start of a try block, which is related to exception
handling, discussed in the EXCEPTIONS section below.

.IP "@(catch), @(finally)"
Special clauses within @(try). See EXCEPTIONS below.

.IP "@(defex), @(throw)"
Define custom exception types; throw an exception.  See EXCEPTIONS below.

.IP @(assert)
The assert directive requires the following material to match, otherwise
it throws an exception. It is useful for catching mistakes or omissions
in parts of a query that are sure-fire matches.

.IP @(flatten)
Normalizes a set of specified variables to one-dimensional lists. Those
variables which have scalar value are reduced to lists of that value.
Those which are lists of lists (to an arbitrary level of nesting) are converted
to flat lists of their leaf values.

.IP @(merge)
Binds a new variable which is the result of merging two or more
other variables. Merging has somewhat complicated semantics.

.IP @(cat)
Decimates a list (any number of dimensions) to a string, by catenating its
constituent strings, with an optional separator string between all of the
values.

.IP @(bind)
Binds one or more variables against a value using a structural
pattern match. A limited form of unification takes place which can cause a
match to fail.

.IP @(set)
Destructively assigns one or more existing variables using a structural
pattern, using syntax similar to bind. Assignment to unbound
variables triggers an error.

.IP @(rebind)
Evaluates an expression in the current binding environment, and
then creates new bindings for the variables in the structural pattern.
Useful for temporarily overriding variable values in a scope.

.IP @(forget)
Removes variable bindings.

.IP @(local)
Synonym of @(forget).

.IP @(output)
A directive which encloses an output clause in the query. An output section
does not match text, but produces text. The directives above are not
understood in an output clause.

.IP @(repeat)
A directive understood within an @(output) section, for repeating multi-line
text, with successive substitutions pulled from lists. The directive @(rep)
produces iteration over lists horizontally within one line.

.IP @(deffilter)
This directive is used for defining named filters, which are useful
for filtering variable substitutions in output blocks. Filters are useful
when data must be translated between different representations that
have different special characters or other syntax, requiring escaping
or similar treatment. Note that it is also possible to use a function
as a filter. See Function Filters below.

.IP @(filter)
The filter directive passes one or more variables through a given
filter or chain or filters, updating them with the filtered values.

.IP @(load)
The load directive loads another TXR file and interprets its contents.

.IP @(do)
The do directive is used to evaluate TXR Lisp expressions, discarding their
result values. See the TXR LISP section far below.

.PP

.SH INPUT SCANNING AND DATA MANIPULATION

.SS The Next Directive

The next directive indicates that the remainder of the query is to be applied
to a new input source.

It can only occur by itself as the only element in a query line,
and takes various arguments, according to these possibilities:

  @(next)
  @(next SOURCE)
  @(next SOURCE :nothrow)
  @(next :args)
  @(next :env)
  @(next :list EXPR)
  @(next :string EXPR)

The lone @(next) without arguments switches to the next file in the
argument list which was passed to the
.B TXR
utility. However, "switch to the next file" means in a pattern matching
way, not in an imperative way. It is possible for the pattern matching
logic to implicitly backtrack to the previous file.

If SOURCE is given, it must be text-valued expression which denotes an
input source; it may be a string literal, quasiliteral or a variable.
For instance, if variable A contains the text "data", then

  @(next A)

means switch to the file called "data", and

  @(next `@A.txt`)

means to switch to the file "data.txt".

If the input source cannot be opened for whatever reason,
.B TXR
throws an exception (see EXCEPTIONS below). An unhandled exception will
terminate the program.  Often, such a drastic measure is inconvenient;
if @(next) is invoked with the :nothrow keyword, then if the input
source cannot be opened, the situation is treated as a simple
match failure.

The variant @(next :args) means that the remaining command line arguments are to
be treated as a data source. For this purpose, each argument is considered to
be a line of text. If an argument is currently being processed as an input
source, that argument is included at the front of the list.  As the arguments
are matched, they are consumed. This means that if a @(next) directive without
arguments is executed in the scope of @(next :args), it opens the file named
by the first unconsumed argument.  

To process arguments, and then continue with the original file and argument
list, wrap the argument processing in a @(block).

The variant @(next :env) means that the list of process environment variables
is treated as a source of data. It looks like a text file stream
consisting of lines of the form "name=value".  If this feature is not available
on a given platform, an exception is thrown.

The syntax @(next :list EXPR) treats the expression as a source of
text. The value of the expression is flattened to a list in a way similar
to the @(flatten) directive.  The resulting list is treated as if it were the
lines of a text file: each element of the list is a line. If the lines
happen contain embedded newline characters, they are a visible constituent
of the line, and do not act as line separators.

The syntax @(next :string EXPR) treats the expression as a source of
text. The value of the expression must be a string. Newlines in the string are
interpreted as line terminators. 

A string which is not terminated by
a newline is tolerated, so that:

  @(next :string "abc")
  @a

binds a to "abc".  Likewise, this is also the case with input files and other
streams whose last line is not terminated by a newline.

However, watch out for empty strings, which are analogous to a correctly formed
empty file which contains no lines:

  @(next :string "")
  @a

This will not bind a to ""; it is a matching failure.  The behavior of :list is
different. The query

  @(next :list "")
  @a

binds a to "".  The reason is that under :list the string "" is flattened to
the list ("") which is not an empty input stream, but a stream consisting of
one empty line.

Note that "remainder of the query" which is applied to the stream opened
by @(next) refers to the subquery in which the next directive appears, not
necessarily the entire query.  For example, the following query looks for the
line starting with "xyz" at the top of the file "foo.txt", within a some
directive.  After the @(end) which terminates the @(some), the "abc" is matched
in the previous file again.

  @(some)
  @(next "foo.txt")
  xyz@suffix
  @(end) abc

However, if the @(some) subquery successfully matched "xyz@suffix" within the
file foo.text,  there is now a binding for the suffix variable, which
is visible to the remainder of the entire query. The variable bindings
survive beyond the clause, but the data stream does not.

The @(next) directive supports the file name conventions as the command
line. The name - means standard input. Text which starts with a ! is
interpreted as a shell command whose output is read like a file.  These
interpretations are applied after variable substitution. If the file is
specified as @a, but the variable a expands to "!echo foo", then the output of
the "echo foo" command will be processed.

.SS The Skip Directive

The skip directive considers the remainder of the query as a search
pattern. The remainder is no longer required to strictly match at the
current line in the current file. Rather, the current file is searched,
starting with the current line, for the first line where the entire remainder
of the query will successfully match. If no such line is found, the skip
directive fails. If a matching position is found, the remainder of
the query is understood to be processed there.

Of course, the remainder of the query can itself contain skip directives.
Each such directive performs a recursive subsearch.

Skip comes in vertical and horizontal flavors. For instance, skip and match the
last line:

  @(skip)
  @last
  @(eof)

Skip and match the last character of the line:

  @(skip)@{last 1}@(eol)

The skip directive has two optional arguments. If the first argument is a
number, its value limits the range of lines scanned for a match. Judicious use
of this feature can improve the performance of queries.

Example: scan until "size: @SIZE" matches, which must happen within
the next 15 lines:

  @(skip 15)
  size: @SIZE

Without the range limitation skip will keep searching until it consumes
the entire input source. While sometimes this is what is intended,
often it is not. Sometimes a skip is nested within a collect, or
following another skip. For instance, consider:

  @(collect)
  begin @BEG_SYMBOL
  @(skip)
  end @BEG_SYMBOL
  @(end)

The collect iterates over the entire input. But, potentially, so does
the skip. Suppose that "begin x" is matched, but the data has no
matching "end x". The skip will search in vain all the way to the end of the
data, and then the collect will try another iteration back at the
beginning, just one line down from the original starting point.  If it is a
reasonable expectation that an "end x" occurs 15 lines of a "begin x", this can
be written instead:

  @(collect)
  begin @BEG_SYMBOL
  @(skip 15)
  end @BEG_SYMBOL
  @(end)

If the symbol nil is used in place of a number, it means to scan
an unlimited range of lines; thus, @(skip nil) is equivalent to @(skip).

If the symbol :greedy is used, it changes the semantics of the skip
to longest match semantics, like the regular expression * operator.
For instance, match the last three space-separated tokens of the line:

  @(skip :greedy) @a @b @c

Without :greedy, the variable @c will can match multiple tokens,
and end up with spaces in it, because nothing follows @c and
so it matches from any position which follows a space to the
end of the line.  Also note the space in front of @a. Without this
space, @a will get an empty string.

A line oriented example of greedy skip: match the last line without
using @eof:

  @(skip :greedy)
  @last_line

There may be a second numeric argument. This specifies a minimum
number of lines to skip before looking for a match. For instance,
skip 15 lines and then search indefinitely for "begin ...":

  @(skip nil 15)
  begin @BEG_SYMBOL

The two arguments may be used together. For instance, the following
matches if, and only if, the 15th line of input starts with "begin ":

  @(skip 1 15)
  begin @BEG_SYMBOL

Essentially, @(skip 1 <n>) means "hard skip by <n>" lines, then
match the query without scanning.  @(skip 1 0) is the same as @(skip 1), which
is a noop, because it means: "the remainder of the query must match starting on
the very next line", or, more briefly, "skip exactly zero lines", which is the
behavior if the skip directive is omitted altogether.

Here is one trick for grabbing the fourth line from the bottom of the input:

  @(skip)
  @fourth_from_bottom
  @(skip 1 3)
  @(eof)

Or using greedy skip:

  @(skip :greedy)
  @fourth_from_bottom
  @(skip 1 3)

Nongreedy skip with the @(eof) has a slight advantage because the greedy skip
will keep scanning even though it has found the correct match, then backtrack
to the last good match once it runs out of data. The regular skip with explicit
@(eof) will stop when the @(eof) matches.

.SS Reducing Backtracking with Blocks

Skip can consume considerable CPU time when multiple skips are nested.
Consider:

  @(skip)
  A
  @(skip)
  B
  @(skip)
  C

This is actually nesting: the second a third skips occur within the body of the
first one, and thus this creates nested iteration. TXR is searching for the
combination of skips which find match the pattern of lines A, B and C, with
backtracking behavior. The outermost skip marches through the data until it
finds A, followed by a pattern match for the second skip. The second skip
iterates within to find B, followed by the third skip, and the third skip
iterates to find C. If there is only one line A, and one B, then this is
reasonably fast. But suppose there are many lines matching A and B,
giving rise to a large number combinations of skips which match A and B, and
yet no match for C, triggering backtracking. The nested stepping which tries
the combinations of A and B can give rise to a considerable running time.

One way to deal with the problem is to unravel the nesting with the help of
blocks. For example:

  @(block)
  @  (skip)
  A
  @(end)
  @(block)
  @  (skip)
  B
  @(end)
  @(skip)
  C

Now the scope of each skip is just the remainder of the block in which it
occurs. The first skip finds A, and then the block ends. Control passes to the
next block, and backtracking will not take place to a block which completed
(unless all these blocks are enclosed in some larger construct which
backtracks, causing the blocks to be re-executed.

Of course, this rewrite is not equivalent, and cannot be used for instance
in backreferencing situations such as:

  @;
  @; Find some three lines which are the same.
  @;
  @(skip)
  @line
  @(skip)
  @line
  @(skip)
  @line

This example depends on the nested search-within-search semantics.

.SS The Trailer Directive

The trailer directive introduces a trailing portion of a query or subquery
which matches input material normally, but in the event of a successful match,
does not advance the current position. This can be used, for instance, to
cause @(collect) to match partially overlapping regions.

Example:

  @(collect)
  @line
  @(trailer)
  @(skip)
  @line
  @(end)

This script collects each line which has a duplicate somewhere later
in the input. Without the @(trailer) directive, this does not work properly
for inputs like:

  111
  222
  111
  222

Without @(trailer), the first duplicate pair constitutes a match which
spans over the 222. After that pair is found, the matching continues
after the second 111.

With the @(trailer) directive in place, the collect body, on each
iteration, only consumes the lines matched prior to @(trailer).

.SS The Freeform Directive

The freeform directive provides a useful alternative to
.B TXR's
line-oriented matching discipline. The freeform directive treats all remaining
input from the current input source as one big line. The query line which
immediately follows freeform is applied to that line.

The syntax variations are:

  @(freeform)
  ... query line ..

  @(freeform NUMBER)
  ... query line ..

  @(freeform STRING)
  ... query line ..

  @(freeform NUMBER STRING)
  ... query line ..

The string and numeric arguments, if both are present, may be given in either
order.

If a numeric argument is given, it limits the range of lines which are combined
together. For instance @(freeform 5) means to only consider the next five lines
to to be one big line. Without a numeric argument, freeform is "bottomless". It
can match the entire file, which creates the risk of allocating a large amount
of memory.

If a string argument is given, it specifies a custom line terminator. The
default terminator is "\en". The terminator does not have to be one character
long.

Freeform does not convert the entire remainder of the input into one big line
all at once, but does so in a dynamic, lazy fashion, which takes place as the
data is accessed. So at any time, only some prefix of the data exists as a flat
line in which newlines are replaced by the terminator string, and the remainder
of the data still remains as a list of lines.

After the subquery is applied to the virtual line, the unmatched remainder
of that line is broken up into multiple lines again, by looking for and
removing all occurrences of the terminator string within the flattened portion.

Care must be taken if the terminator is other than the default "\en". All
occurrences of the terminator string are treated as line terminators in
the flattened portion of the data, so extra line breaks may be introduced.
Likewise, in the yet unflattened portion, no breaking takes place, even if
the text contains occurrences of the terminator string. The extent of data which
is flattened, and the amount of it which remains, depends entirely on the
query line underneath @(flatten).

In the following example, lines of data are flattened using $ as the line
terminator.

  Query:        @(freeform "$")
                @a$@b:
                @c
                @d

  Data:         1
                2:3
                4

  Output (-B):  a="1"
                b="2"
                c="3"
                d="4"

The data is turned into the virtual line 1$2:3$4$.  The @a$@b: subquery matches
the 1$2: portion, binding a to 1, and b to 2.  The remaining portion 3$4$ is
then split into separate lines again according to the line terminator $:

                3
                4

Thus the remainder of the query

                @c
                @d

faces these lines, binding c to 3 and d to 4. Note that since the data
does not contain dollar signs, there is no ambiguity; the meaning may be
understood in terms of the entire data being flattened and split again.

In the following example, freeform is used to solve a tokenizing problem.  The
Unix password file has fields separated by colons. Some fields may be empty.
Using freeform, we can join the password file using ":" as a terminator.
By restricting freeform to one line, we can obtain each line of the password
file with a terminating ":", allowing for a simple tokenization, because
now the fields are colon-terminated rather than colon-separated.

Example:

  @(next "/etc/passwd")
  @(collect)
  @(freeform 1 ":")
  @(coll)@{token /[^:]*/}:@(end)
  @(end)

.SS The Fuzz Directive

The fuzz directive allows for an imperfect match spanning a set number of
lines. It takes two arguments, both expressions that should evaluate
to integers:

  @(fuzz m n)
  ...

This expresses that over the next n query lines, the matching strictness
is relaxed a little bit. Only m out of those n lines have to match.
Afterward, the rest of the query follows normal, strict processing.

In the degenerate situation that there are fewer than n query lines following
the fuzz directive, then m of them must succeed nevertheless. (If there
are fewer than m, then this is impossible.)

.SS The Some, All, None, Maybe, Cases and Choose directives

These directives, called the parallel directives, combine multiple subqueries,
which are applied at the same input position, rather than to consecutive input.

They come in vertical (line mode) and horizontal (character mode) flavors.

In horizontal mode, the current position is understood to be a character
position in the line being processed. The clauses advance this character
position by moving it to the right.  In vertical mode, the current position is
understood to be a line of text within the stream. A clause advances the
position by some whole number of lines.

The syntax of these parallel directives follows this example:

  @(some)
  subquery1
  .
  .
  .
  @(and)
  subquery2
  .
  .
  .
  @(and)
  subquery3
  .
  .
  .
  @(end)

And in horizontal mode:

  @(some)subquery1...@(and)subquery2...@(and)subquery3...@(end)

Long horizontal lines can be broken up with line continuations, allowing the
above example to be written like this, which is considered a single logical
line:

  @(some)@\
     subquery1...@\
  @(and)@\
     subquery2...@\
  @(and)@\
     subquery3...@\
  @(end)

The @(some), @(all), @(none), @(maybe), @(cases) or @(choose) must be followed
by at least one subquery clause, and be terminated by @(end). If there are two
or more subqueries, these additional clauses are indicated by @(and) or @(or),
which are interchangeable.  The separator and terminator directives also must
appear as the only element in a query line.

The choose directive requires keyword arguments. See below.

The syntax supports arbitrary nesting. For example:

  QUERY:            SYNTAX TREE:

  @(all)            all -+
  @  (skip)              +- skip -+
  @  (some)              |        +- some -+
  it                     |        |        +- TEXT
  @  (and)               |        |        +- and
  @    (none)            |        |        +- none -+
  was                    |        |        |        +- TEXT
  @    (end)             |        |        |        +- end
  @  (end)               |        |        +- end
  a dark                 |        +- TEXT
  @(end)                 *- end

nesting can be indicated using whitespace between @ and the
directive expression. Thus, the above is an @(all) query containing a @(skip)
clause which applies to a @(some) that is followed by the text line "a dark".
The @(some) clause combines the text line "it", and a @(none) clause which
contains just one clause consisting of the line "was".

The semantics of the parallel directives is:

.IP @(all)
Each of the clauses is matched at the current position. If any of the
clauses fails to match, the directive fails (and thus does not produce
any variable bindings). Clauses following the failed directive are not
evaluated. Bindings extracted by a successful clause are visible to the clauses
which follow, and if the directive succeeds, all of the combined bindings
emerge.

.IP "@(some [ :resolve (vars ...) ])"
Each of the clauses is matched at the current position. If any of the clauses
succeed, the directive succeeds, retaining the bindings accumulated by the
successfully matching clauses.  Evaluation does not stop on the first successful
clause. Bindings extracted by a successful clause are visible to the clauses
which follow.

The :resolve parameter is for situations when the @(some) directive has
multiple clauses that need to bind some common variables to different
values: for instance, output parameters in functions. Resolve takes
a list of variable name symbols as an argument.  This is called the
resolve set. If the clauses of @(some) bind variables in the resolve
set, those bindings are not visible to later clauses.  However, those
bindings do emerge out of the @(some) directive as a whole.
This creates a conflict: what if two or more clauses introduce
non-matching bindings for a variable in the resolve set?
This is why it is called the resolve set: conflicts for variables in the
resolve set are automatically resolved in favor of later directives.

Example:

  @(some :resolve (x))
  @  (bind a "a")
  @  (bind x "x1")
  @(or)
  @  (bind b "b")
  @  (bind x "x2")
  @(end)

Here, the two clauses both introduce a binding for x.  Without the :resolve
parameter, this would mean that the second clause fails, because x comes in
with the value "x1", which does not bind with "x2".  But because x is placed
into the resolve set, the second clause does not see the "x1" binding. Both
clauses establish their bindings independently creating a conflict over x.
The conflict is resolved in favor of the second clause, and so the bindings
which emerge from the directive are:

  a="a"
  b="b"
  x="x2"

.IP @(none)
Each of the clauses is matched at the current position. The
directive succeeds only if all of the clauses fail. If
any clause succeeds, the directive fails, and subsequent clauses are not
evaluated. Thus, this directive never produces variable bindings, only matching
success or failure.

.IP @(maybe)
Each of the clauses is matched at the current position.  The directive always
succeeds, even if all of the clauses fail.  Whatever bindings are found in any
of the clauses are retained. Bindings extracted by any successful clause are
visible to the clauses which follow.

.IP @(cases)
Each of the clauses is matched at the current position.
The clauses are matched, in order, at the current position.
If any clause matches, the matching stops and the bindings
collected from that clause are retained. Any remaining clauses
after that one are not processed. If no clause matches, the
directive fails, and produces no bindings.

.IP "@(choose [ :longest <var> | :shortest <var> ])"
Each of the clauses is matched at the current position in order. In this
construct, bindings established by an earlier clause are not visible to later
clauses.  Although any or all of the clauses can potentially match, the clause
which succeeds is the one which maximizes or minimizes the length of the
text bound to the specified variable. The other clauses have no effect.

For all of the parallel directives other than @(none) and @(choose), the query
advances the input position by the greatest number of lines that match in any
of the successfully matching subclauses that are evaluated.  The @(none)
directive does not advance the input position.

For instance if there are two subclauses, and one of them matches three lines,
but the other one matches five lines, then the overall clause is considered to
have made a five line match at its position. If more directives follow, they
begin matching five lines down from that position.

.SS The Require Directive

The syntax of @(require) is:

  @(require <lisp-expression>)

The require directive evaluates a TXR Lisp expression. (See TXR LISP far
below.) If the expression yields a true value, then it succeeds, and matching
continues with the directives which follow. Otherwise the directive fails.

In the context of the @(require) directive, should not be delimited by an @.

Example:

  @# require that 4 is greater than 3
  @# This succeeds; therefore, @a is processed
  @(require (> (+ 2 2) 3))
  @a


.SS The If Directive

The syntax of the directive can be exemplified as follows

  @(if <lisp-expr>)
  .
  .
  .
  @(elif <lisp-expr>)
  .
  .
  .
  @(elif <lisp-expr>)
  .
  .
  .
  @(else)
  .
  .
  .
  @(end)

The @(elif) and @(else) clauses are all optional. If @(else) is present, it must be
last, before @(end), after any @(elif) clauses. Any of the clauses may be empty.

See the TXR Lisp section about TXR Lisp expressions. In this directive, TXR Lisp
expressions are not introduced by the @ symbol.

For example:

  @(if (> (length str) 42))
  foo: @a @b
  @(else)
  {@c}
  @(end)

In this example, if the length of the variable str is greater than 42, then
matching continues with "foo: @a b", otherwise it proceeds with {@c}.

The if directive is actually a syntactic sugar which is translated to @(cases)
and @(require).  That is to say, the following pattern:

  @(cases)
  @(require <lisp-expr-1>)
  A
  @(or)
  @(require <lisp-expr-2>)
  B
  @(or)
  C
  @(end)

corresponds to the somewhat shorter and clearer:

  @(if <lisp-expr-1>)
  A
  @(elsif <lisp-expr-2>)
  B
  @(else)
  C
  @(end)

.SS The Gather Directive

Sometimes text is structured as items that can appear in an arbitrary order.
When multiple matches need to be extracted, there is a combinatorial explosion
of possible orders, making it impractical to write pattern matches for all
the possible orders.

The gather directive is for these situations. It specifies multiple clauses
which all have to match somewhere in the data, but in any order.

For further convenience, the lines of the first clause of the gather directive
are implicitly treated as separate clauses.

The syntax follows this pattern

  @(gather)
  one-line-query1
  one-line-query2
  .
  .
  .
  one-line-queryN
  @(and)
  multi
  line
  query1
  .
  .
  .
  @(and)
  multi
  line
  query2
  .
  .
  .
  @(end)

Of course the multi-line clauses are optional.   The gather directive takes
keyword parameters, see below.

Similarly to @(collect), @(gather) has an optional until/last clause:

  @(gather)
  ...
  @(until)
  ...
  @(end)

How gather works is that the text is searched for matches for the single line
and multi-line queries. The clauses are applied in the order in which they appear.
Whenever one of the clauses matches, any bindings it produces are retained and
it is removed from further consideration. Multiple clauses can match at the
same text position.  The position advances by the longest match from among the
clauses which matched.  If no clauses match, the position advances by one line.
The search stops when all clauses are eliminated, and then the cumulative
bindings are produced.  If the data runs out, but unmatched clauses remain, the
directive fails.

Example: extract several environment variables, which do not appear in a particular
order:

  @(next :env)
  @(gather)
  USER=@USER
  HOME=@HOME
  SHELL=@SHELL
  @(end)

If the until or last clause is present and a match occurs, then the matches
from the other clauses are discarded and the gather terminates. The difference
between until and last is that any bindings bindings established in last are
retained, and the input position is advanced past the matched material.
The until/last clause has visibility to bindings established in the
previous clauses in that same iteration, even though those bindings
end up thrown away.

.SS Gather Keyword Parameters

The gather directive accepts the keyword parameter :vars. The argument to vars is
a list of required and optional variables.  Optional variables are denoted by
the specification of a default value. Example:

  @(gather :vars (a b c (d "foo")))
  ...
  @(end)

Here, a, b, c and e are required variables, and d is optional.  Variable e is
required because its default value is the empty list (), same as the symbol
nil. 

The presence of vars changes the behavior in three ways.

Firstly, even if all the clauses in the gather match successfully and are
eliminated, the directive will fail if the required variables do not have
bindings. It doesn't matter whether the bindings are existing, or whether they
are established by the gather.

Secondly, if some of the clauses of the gather did not match, but all
of the required variables have bindings, then the directive succeeds.
Without the presence of :vars, it would fail in this situation.

Thirdly, if the gather succeeds (all required variables have bindings),
then all of the optional variables which do not have bindings are given
bindings to their default values.

.SS The Collect Directive

The syntax of the collect directive is:

  @(collect)
  ... lines of subquery
  @(end)

or with an until or last clause:

  @(collect)
  ... lines of subquery: main clause
  @(until)
  ... lines of subquery: until clause
  @(end)

  @(collect)
  ... lines of subquery: main clause
  @(last)
  ... lines of subquery: last clause
  @(end)

The repeat symbol may be specified instead of collect, which changes
the meaning, see below:

  @(repeat)
  ... lines of subquery
  @(end)

The subquery is matched repeatedly, starting at the current line.
If it fails to match, it is tried starting at the subsequent line.
If it matches successfully, it is tried at the line following the
entire extent of matched data, if there is one. Thus, the collected regions do
not overlap. (Overlapping behavior can be obtained: see the
@(trailer) directive).

Unless certain keywords are specified, or unless the collect is explicitly
failed with @(fail), it always succeeds, even if it collects nothing,
and even if the until/last clause never finds a match.

If no until/last clause is specified, and the collect is not limited
using parameters, the collect is unbounded. It consumes the entire data
file. If any query material follows such the collect clause, it will fail if it
tries to match anything in the current file; but of course, it is possible to
continue matching in another file by means of @(next).

If an until/last clause is specified, the collection stops when that clause
matches at the current position. 

If an until clause terminates collect, no bindings are collected at that
position, even if the main clause matches at that position also. Moreover, the
position is not advanced.  The remainder of the query begins matching at that
position.  

If a last clause terminates collect, the behavior is different. Any bindings
captured by the main clause are thrown away, just like with the until clause.
However, the bindings in the last clause itself survive, and the position is
advanced to skip over that material.

Example:

  Query:        @(collect)
                @a
                @(until)
                42
                @b
                @(end)
                @c

  Data:         1
                2
                3
                42
                5
                6

  Output (-B):  a[0]="1"
                a[1]="2"
                a[2]="3"
                c="42"

The line 42 is not collected, even though it matches @a. Furthermore,
the until does not advance the position, so variable c takes 42.

If the @(until) is changed to @(last) the output will be different:

  Output (-B):  a[0]="1"
                a[1]="2"
                a[2]="3"
                b=5
                c=6

The 42 is not collected into the a list, just like before. But now
the binding captured by @b emerges. Furthermore, the position advances
so variable now takes 6.

The binding variables within the clause of a collect are treated specially.
The multiple matches for each variable are collected into lists,
which then appear as array variables in the final output.

Example:

  Query:        @(collect)
                @a:@b:@c
                @(end)

  Data:         John:Doe:101
                Mary:Jane:202
                Bob:Coder:313

  Output (-B):
                a[0]="John"
                a[1]="Mary"
                a[2]="Bob"
                b[0]="Doe"
                b[1]="Jane"
                b[2]="Coder"
                c[0]="101"
                c[1]="202"
                c[2]="313"

The query matches the data in three places, so each variable becomes
a list of three elements, reported as an array.

Variables with list bindings may be referenced in a query. They denote a
multiple match. The -D command line option can establish a one-dimensional
list binding.

Collect clauses may be nested.   Variable matches collated into lists in an
inner collect, are again collated into nested lists in the outer collect.
Thus an unbound variable wrapped in N nestings of @(collect) will
be an N-dimensional list. A one dimensional list is a list of strings;
a two dimensional list is a list of lists of strings, etc.

It is important to note that the variables which are bound within the main
clause of a collect - i.e. the variables which are subject to
collection - appear, within the collect, as normal one-value bindings. The
collation into lists happens outside of the collect. So for instance in the
query:

 @(collect)
 @x=@x
 @(end)

The left @x establishes a binding for some material preceding an equal sign.
The right @x refers to that binding. The value of @x is different in each
iteration, and these values are collected. What finally comes out of the
collect clause is list variable called x which holds each value that
was ever instantiated under that name within the collect clause.

Also note that the until clause has visibility over the bindings
established in the main clause. This is true even in the terminating
case when the until clause matches, and the bindings of the main clause
are discarded.

.SS Collect Keyword Parameters

By default, collect searches the rest of the input indefinitely,
or until the @(until) clause matches. It skips arbitrary amounts of
nonmatching material before the first match, and between matches.

Within the @(collect) syntax, it is possible to specify some useful keyword
parameters for additional control of the behavior. For instance

  @(collect :maxgap 5)

means that the collect will terminate if it does not find a match within five
lines of the starting position, or if more than five lines are skipped since
any successful match. A :maxgap of 0 means that the collected regions must be
adjacent. For instance:

  @(collect :maxgap 0)
  M @a
  @(end)

means: from here, collect consecutive lines of the form "M ...". This will not
search for the first such line, nor will it skip lines which do not match this
form.

Other keywords are :mingap, and :gap.  The :mingap keyword specifies a minimum
gap between matches, but has no effect on the distance to the first match. The
:gap keyword specifies  :mingap and :maxgap  at the same time, and can only be
used if these other two are not used. Thus:

 @(collect :gap 1)
 @a
 @(end)

means collect every other line starting with the current line. Several
other supported keywords are :times, :mintimes, :maxtimes and :lines.
The shorthand :times N means the same thing as :mintimes N :maxtimes N.
These specify how many matches should be collected. If there are fewer
than mintimes matches, the collect fails. If maxtimes matches are collected,
collect stops collecting immediately. Example:

 @(collect :times 3)
 @a @b
 @(end)

This will collect a match for "@a @b" exactly three times. If three
matches are not found, it will fail.

The :lines parameter specifies the upper bound on how many lines
should be scanned by collect, measuring from the starting position.
The extent of the collect body is not counted. Example:

 @(collect :lines 2)
 foo: @a
 bar: @b
 baz: @c
 @(end)

The above collect will look for a match only twice: at the current position,
and one line down.

There is one more keyword, :vars, discussed in the following section.

.SS Specifying Variables in Collect

Normally, any variable for which a new binding occurs in a collect is
collected. A collect clause may be sloppy: it can neglect to collect some
variables on some iterations, or bind some variables which are intended
to behave like local temporaries, but end up collated into lists. Another issue
is that the collect clause might not match anything at all, and then none of
the variables are bound.

The :vars keyword allows the query writer to add discipline the collect body.

The argument to :vars is a list of variable specs. A variable spec is either a
symbol, or a (<symbol> <expression>) pair, where the expression specifies a
default value.

When a :vars list is specified, it means that only the given variables can
emerge from the successful collect. Any newly introduced bindings for other
variables do not propagate.

Furthermore, for any variable which is not specified with a default value, the
collect body, whenever it matches successfully, must bind that variable. If it
neglects to bind the variable, an exception of type query_error is thrown.
(If a collect body matches successfully, but produces no new bindings, then
this error is suppressed.)

For any variable which does have a default value, if the collect body neglects
to bind that variable, the behavior is as if the collect did bind that variable
to that default value.

The default values are expressions, and so can be quasiliterals.

Lastly, if in the event that the collect does not match anything, the variables
specified in vars (whether or not they have a default value) are all bound to
empty lists. (These bindings are established after the processing of the
until/last clause, if present.)

Example:

  @(collect :vars (a b (c "foo")))
  @a @c
  @(end)

Here, if the body "@a @c" matches, an error will be thrown because one of the
mandatory variables is b, and the body neglects to produce a binding for b.

Example:

  @(collect :vars (a (c "foo")))
  @a @b
  @(end)

Here, if "@a @b" matches, only a will be collected, but not b, because b is not
in the variable list. Furthermore, because there is no binding for c in the
body, a binding is created with the value "foo", exactly as if c matched
such a piece of text.

In the following example, the assumption is that THIS NEVER MATCHES
is not found anywhere in the input but the line THIS DOES MATCH is
found and has a successor which is bound to a. Because the body did not
match, the :vars a and b should be bound to empty lists. But a is bound
by the last clause to some text, so this takes precedence. Only b is bound to a
an empty list.

  @(collect :vars (a b))
  THIS NEVER MATCHES
  @(last)
  THIS DOES MATCH
  @a
  @(end)

The following means: do not allow any variables to propagate out of any
iteration of the collect and therefore collect nothing:

  @(collect :vars nil)
  ...
  @(end)

Instead of writing @(collect :vars nil), it is possible to write
@(repeat). @(repeat) takes all collect keywords, except for :vars.
There is a repeat directive used in @(output) clauses; that is
a different repeat directive.

.SS The Coll Directive

The coll directive is a kind of miniature version of the collect directive.
Whereas the collect directive works with multi-line clauses on line-oriented
material, coll works within a single line. With coll, it is possible to
recognize repeating regularities within a line and collect lists.

Regular-expression based Positive Match variables work well with coll.

Example: collect a comma-separated list, terminated by a space.

  pattern:  @(coll)@{A /[^, ]+/}@(until) @(end)@B
  data:     foo,bar,xyzzy blorch
  result:   A[0]="foo"
            A[1]="bar"
            A[2]="xyzzy"
            B=blorch

Here, the variable A is bound to tokens which match the regular
expression /[^, ]+/: non-empty sequence of characters other than commas or
spaces.

Like its big cousin, the coll directive searches for matches.  If no match
occurs at the current character position, it tries at the next character
position. Whenever a match occurs, it continues at the character position which
follows the last character of the match, if such a position exists.

If not bounded by an until clause, it will exhaust the entire line.  If the
until clause matches, then the collection stops at that position,
and any bindings from that iteration are discarded.
Like collect, coll also supports a last clause, which propagates variable
bindings and advances the position.

Coll clauses nest, and variables bound within a coll are available to clauses
within the rest of the coll clause, including the until clause, and appear as
single values. The final list aggregation is only visible after the coll clause.

The behavior of coll is troublesome, when delimited variables are used,
because in text file formats, the material which separates items is not
repeated after the last item. For instance, a comma-separated list usually does
not appear as "a,b,c," but rather "a,b,c". There might not be any explicit
termination - the last item might be at the very end of the line.

So for instance, the following result is not satisfactory:

  pattern:      @(coll)@a @(end)
  data:         1 2 3 4 5
  result:       a[0]="1"
                a[1]="2"
                a[2]="3"
                a[3]="4"

What happened to the 5? After matching "4 ", coll continues to look for
matches. It tries "5", which does not match, because it is not followed by a
space. Then the line is consumed.  So in this sequence, a valid item is either
followed by a space, or by nothing. So it is tempting to try this:

  pattern:      @(coll)@a@/ ?/@(end)
  data:         1 2 3 4 5
  result:       a[0]=""
                a[1]=""
                a[2]=""
                a[3]=""
                a[4]=""
                a[5]=""
                a[6]=""
                a[7]=""
                a[8]=""

however, the problem is that the regular expression / ?/ (match either a space
or nothing), matches at any position.  So when it is used as a variable
delimiter, it matches at the current position, which binds the empty string to
the variable, the extent of the match being zero. In this situation, the coll
directive proceeds character by character. The solution is to use
positive matching: specify the regular expression which matches the item,
rather than a trying to match whatever follows.  The collect directive will
recognize all items which match the regular expression.

  pattern:      @(coll)@{a /[^ ]+/}@(end)
  data:         1 2 3 4 5
  result:       a[0]="1"
                a[1]="2"
                a[2]="3"
                a[3]="4"
                a[4]="5"

The until clause can specify a pattern which, when recognized, terminates
the collection. So for instance, suppose that the list of items may
or may not be terminated by a semicolon. We must exclude
the semicolon from being a valid character inside an item, and
add an until clause which recognizes a semicolon:

  pattern:      @(coll)@{a /[^ ;]+/}@(until);@(end);

  data:         1 2 3 4 5;
  result:       a[0]="1"
                a[1]="2"
                a[2]="3"
                a[3]="4"
                a[4]="5"

Semicolon or not, the items are collected properly.

Note that the @(end) is followed by a semicolon. That's because
when the @(until) clause meets a match, the matching material
is not consumed.

Instead of regular expression hacks, this problem can be nicely
solved with cases:

  pattern:      @(coll)@(cases)@a @(or)@a@(end)@(end)
  data:         1 2 3 4 5
  result:       a[0]="1"
                a[1]="2"
                a[2]="3"
                a[3]="4"
                a[4]="5"

.SS Coll Keyword Parameters

The @(coll) directive takes most of the same parameters as @(collect).
See the section Collect Keyword Parameters above.
So for instance @(coll :gap 0) means that the collects must be
consecutive, and @(coll :maxtimes 2) means that at most two matches
will be collected.  The :lines keyword does not exist, but there is
an analogous :chars keyword.

.SS The Flatten Directive.

The flatten directive can be used to convert variables to one dimensional
lists. Variables which have a scalar value are converted to lists containing
that value. Variables which are multidimensional lists are flattened to
one-dimensional lists.

Example (without @(flatten))

  pattern:      @b
                @(collect)
                @(collect)
                @a
                @(end)
                @(end)

  data:         0
                1
                2
                3
                4
                5

  result:       b="0"
                a_0[0]="1"
                a_1[0]="2"
                a_2[0]="3"
                a_3[0]="4"
                a_4[0]="5"

Example (with flatten):

  pattern:      @b
                @(collect)
                @(collect)
                @a
                @(end)
                @(end)
                @(flatten a b)

  data:         0
                1
                2
                3
                4
                5

  result:       b[0]="0"
                a[0]="1"
                a[1]="2"
                a[2]="3"
                a[3]="4"
                a[4]="5"

.SS The Merge Directive

The merge directive provides a way of combining two or more variables
in a somewhat complicated but very useful way. 

To understand what merge does we first have to define a property called depth.
The depth of an atom such as a string is defined as 1. The depth of an empty
list is 0. The depth of a nonempty list is one plus the depth of its deepest
element. So for instance "foo" has depth 1, ("foo") has depth 2, and ("foo"
("bar")) has depth three.

We can now define the binary (two argument) merge operation as follows.  (merge
A B) first normalizes the values A and B such that they have equal depth.
1. A value which has depth zero is put into a one element list. 
2. If either value has a smaller depth than the other, it is wrapped
in a list as many times as needed to give it equal depth.
Finally, the values are appended together.

Merge takes more than two arguments. These are merged by a left reduction. The
leftmost two values are merged, and then this result is merged with the third
value, and so on.

Merge is useful for combining the results from collects at different
levels of nesting such that elements are at the appropriate depth.

.SS The Cat Directive

The @(cat) directive converts a list variable into a single
piece of text. The syntax is:

 @(cat VAR [ SEP ])

The SEP argument specifies a separating piece of text. If no separator
is specified, then a single space is used.

Example:

  pattern:      @(coll)@{a /[^ ]+/}@(end)
                @(cat a ":")
  data:         1 2 3 4 5
  result:       a="1:2:3:4:5"


.SS The Bind Directive

The syntax of the @(bind) directive is:

  @(bind pattern expression { keyword value }*)

The @(bind) directive is a kind of pattern match, which matches one or more
variables on the left hand side pattern to the value of a variable on the
right hand side.  The right hand side variable must have a binding, or else the
directive fails. Any variables on the left hand side which are unbound receive
a matching piece of the right hand side value. Any variables on the left which
are already bound must match their corresponding value, or the bind fails. Any
variables which are already bound and which do match their corresponding value
remain unchanged (the match can be inexact).

The simplest bind is of one variable against itself, for instance bind A
against A:

  @(bind A A)

This will fail if A is not bound, (and complain loudly). If A is bound, it
succeeds, since A matches A.

The next simplest bind binds one variable to another:

  @(bind A B)

Here, if A is unbound, it takes on the same value as B. If A is bound, it has
to match B, or the bind fails. Matching means that either
.IP -
A and B are the same text
.IP -
A is text, B is a list, and A occurs within B.
.IP -
vice versa: B is text, A is a list, and B occurs within A.
.IP -
A and B are lists and are either identical, or one is
found as substructure within the other.
.PP
The right hand side does not have to be a variable. It may be some other
object, like a string, quasiliteral, regexp, or list of strings, et cetera. For
instance

  @(bind A "ab\etc")

will bind the string "ab\etc" (the letter a, b, a tab character, and c)
to the variable A if A is unbound. If A is bound, this will fail unless
A already contains an identical string. However, the right hand side of a bind
cannot be an unbound variable, nor a complex expression that contains unbound
variables.

The left hand side of a bind can be a nested list pattern containing variables.
The last item of a list at any nesting level can be preceded by a dot, which
means that the variable matches the rest of the list from that position.

Example: suppose that the list A contains ("now" "now" "brown" "cow"). Then the
directive @(bind (H N . C) A), assuming that H, N and C are unbound variables,
will bind H to "how", N to "now", and C to the remainder of the list ("brown"
"cow").

Example: suppose that the list A is nested to two dimensions and  contains
(("how" "now") ("brown" "cow")). Then @(bind ((H N) (B C)) A)
binds H to "how", N to "now", B to "brown" and C to "cow".

The dot notation may be used at any nesting level. it must be preceded and
followed by a symbol: the forms (.) (. X) and (X .) are invalid.

The number of items in a left pattern match must match the number of items in
the corresponding right side object. So the pattern () only matches
an empty list. The notation () and nil means exactly the same thing.

The symbols nil, t and keyword symbols may be used on either side.
They represent themselves.  For example @(bind :foo :bar) fails,
but @(bind :foo :foo) succeeds since the two sides denote the same
keyword symbol object.

.SS Keywords in The Bind Directive

The Bind directive accepts these keywords:

.IP :lfilt
The argument to :lfilt is a filter specification. When the left side pattern
contains a binding which is therefore matched against its counterpart from the
right side expression, the left side is filtered through the filter specified
by :lfilt for the purposes of the comparison. For example:

  @(bind "a" "A" :lfilt :upcase)

produces a match, since the left side is the same as the right after
filtering through the :upcase filter.

.IP :rfilt
The argument to :rfilt is a filter specification. The specified filter is
applied to the right hand side material prior to matching it against
the left side. The filter is not applied if the left side is a variable
with no binding. It is only applied to determine a match. Binding takes
place the unmodified right hand side object.

Example, the following produces a match:

  @(bind "A" "a" :rfilt :upcase)

.IP :filter
This keyword is a shorthand to specify both filters to the same value.
So for instance :filter :upcase is equivalent to :lfilt :upcase :rfilt :upcase.

For a description of filters, see Output Filtering below.

Of course, compound filters like (:from_html :upcase) are supported with
all these keywords. The filters apply across arbitrary patterns and nested data.

Example:

  @(bind (a b c) ("A" "B" "C"))
  @(bind (a b c) (("z" "a") "b" "c") :rfilt :upcase)

Here, the first bind establishes the values for a, b and c, and the second bind
succeeds, because the value of a matches the second element of the list ("z"
"a") if it is upcased, and likewise b matches "b" and c matches "c" if these
are upcased.

.SS The Set Directive

The @(set) directive resembles bind, but is not a pattern match. It overwrites
the previous values of variables with new values from the right hand side.
Each variable that is assigned must have an existing binding.

Examples follow.

Store the value of A back into A, achieving nothing:

  @(set A A)

Exchange the values of A and B:

  @(set (A B) (B A))

Store a string into A:

  @(set A "text")

Store a list into A:

  @(set A ("line1" "line2"))

Destructuring assignment. D assumed to contain the list 

  @(bind D ("A" ("B1" "B2") "C1" "C2"))
  @(bind (A B C) (() () ()))
  @(set (A B . C) D)

A ends up with "A", B ends up with ("B1" "B2") and C gets ("C1" and "C2").

.SS The Rebind Directive

The @(rebind) directive resembles @(set) but it is not an assignment.
It combines the semantics of @(local), @(bind) and @(set).
The expression on the right hand side is evaluated in the current
environment. Then the variables in the pattern on the left are introduced
as new bindings, whose values come from the pattern.

Rebind makes it easy to create temporary bindings based on existing
bindings.

  @(define pattern-function (arg))
  @;; inside a pattern function:
  @(rebind recursion-level @(+ recursion-level 1))
  @;; ...
  @(end)

When the function terminates, the previous value of recursion-level
is restored. The effect is like the following, but much easier
to write and faster to execute:

  @(define pattern-function (arg))
  @;; inside a pattern function:
  @(local temp)
  @(set temp recursion-level)
  @(local recursion-level)
  @(set recursion-level @(+ temp 1))
  @;; ...
  @(end)

.SS The Forget Directive

The Forget Directive has two spellings @(forget) and @(local).

The arguments are one or more symbols, for example:

  @(forget a)
  @(local a b c)

this can be written

  @(local a)
  @(local a b c)

Directives which follow the forget or local directive no longer see
any bindings for the symbols mentioned in that directive, and
can establish new bindings.

It is not an error if the bindings do not exist.

It is strongly recommended to use @(local) spelling in functions,
because the forgetting action simulates local variables:
for the given symbols, the machine forgets any earlier variables
from outside of the function, and consequently, any new bindings
for those variables belong to the function. (Furthermore,
functions suppress the propagation of variables that are not
in their parameter list, so these locals will be automatically
forgotten when the function terminates.)

.SH BLOCKS

.SS Introduction

Blocks are sections of a query which are denoted by a name. Blocks denoted by
the name nil are understood as anonymous.

The @(block NAME) directive introduces a named block, except when the name is
the word nil.  The @(block) directive introduces an unnamed block, equivalent
to @(block nil).

The @(skip) and @(collect) directives introduce implicit anonymous blocks,
as do function bodies.

Blocks are useful for terminating parts of a pattern matching search
prematurely, and escaping to a higher level. This makes blocks not only
useful for simplifying the semantics of certain pattern matches,
but also an optimization tool. 

Judicious use of blocks and escapes can reduce or eliminate the amount of
backtracking that TXR performs.

.SS Block Scope

The names of blocks are in a distinct namespace from the variable binding
space. So @(block foo) has no interaction with the variable @foo.

A block extends from the @(block ...) directive which introduces it,
until the matching @(end), and may be empty.  For instance:

  @(some)
  abc
  @(block foo)
  xyz
  @(end)
  @(end)

Here, the block foo occurs in a @(some) clause, and so it extends to the @(end)
which terminates the block.  After that @(end), the name foo is not
associated with a block (is not "in scope"). The second @(end) terminates
the @(some) block. 

The implicit anonymous block introduced by @(skip) has the same scope
as the @(skip): it extends over all of the material which follows the skip,
to the end of the containing subquery.

.SS Block Nesting

Blocks may nest, and nested blocks may have the same names as blocks in
which they are nested. For instance:

  @(block)
  @(block)
  ...
  @(end)
  @(end)

is a nesting of two anonymous blocks, and

  @(block foo)
  @(block foo)
  @(end)
  @(end)

is a nesting of two named blocks which happen to have the same name.
When a nested block has the same name as an outer block, it creates
a block scope in which the outer block is "shadowed"; that is to say,
directives which refer to that block name within the nested block refer to the
inner block, and not to the outer one.

.SS Block Semantics

A block normally does nothing. The query material in the block is evaluated
normally. However, a block serves as a termination point for @(fail) and
@(accept) directives which are in scope of that block and refer to it.

The precise meaning of these directives is:

.IP "@(fail NAME)"

Immediately terminate the enclosing query block called NAME, as if that block
failed to match anything. If more than one block by that name encloses
the directive, the inner-most block is terminated. No bindings emerge from
a failed block.

.IP @(fail)

Immediately terminate the innermost enclosing anonymous block, as if
that block failed to match.

If the implicit block introduced by @(skip) is terminated in this manner,
this has the effect of causing the skip itself to fail. I.e. the behavior
is as if skip search did not find a match for the trailing material,
except that it takes place prematurely (before the end of the available
data source is reached).

If the implicit block associated with a @(collect)  is terminated this way,
then the entire collect fails. This is a special behavior, because a
collect normally does not fail, even if it matches and collects nothing!

To prematurely terminate a collect by means of its anonymous block, without
failing it, use @(accept).

.IP "@(accept NAME)"

Immediately terminate the enclosing query block called NAME, as if that block
successfully matched. If more than one block by that name encloses the
directive, the inner-most block is terminated.  Any bindings established within
that block until this point emerge from that block.

.IP @(accept)

Immediately terminate the innermost enclosing anonymous block, as if
that block successfully matched. Any bindings established within
that block until this point emerge from that block.

If the implicit block introduced by @(skip) is terminated in this manner,
this has the effect of causing the skip itself to succeed, as if
all of the trailing material successfully matched.

If the implicit block associated with a @(collect)  is terminated this way,
then the collection stops. All bindings collected in the current iteration of
the collect are discarded. Bindings collected in previous iterations are
retained, and collated into lists in accordance with the semantics of collect.

Example: alternative way to @(until) termination:

  @(collect)
  @  (maybe)
  ---
  @  (accept)
  @  (end)
  @LINE
  @(end)

This query will collect entire lines into a list called LINE. However,
if the line --- is matched (by the embedded @(maybe)), the collection
is terminated. Only the lines up to, and not including the --- line,
are collected. The effect is identical to:

  @(collect)
  @LINE
  @(until)
  ---
  @(end)

The difference (not relevant in these examples) is that the until clause has
visibility into the bindings set up by the main clause.

However, the following example has a different meaning:

  @(collect)
  @LINE
  @  (maybe)
  ---
  @  (accept)
  @  (end)
  @(end)

Now, lines are collected until the end of the data source, or until a line is
found which is followed by a --- line. If such a line is found,
the collection stops, and that line is not included in the collection!
The @(accept) terminates the process of the collect body, and so the
action of collecting the last @LINE binding into the list is not performed.

.SS Data Extent of Terminated Blocks

A query block may have matched some material prior to being terminated by
accept. In that case, it is deemed to have only matched that material,
and not any material which follows. This may matter, depending on the context
in which the block occurs.

Example:

  Query:        @(some)
                @(block foo)
                @first
                @(accept foo)
                @ignored
                @(end)
                @second

  Data:         1
                2
                3

  Output (-B):  first="1"
                second="2"

At the point where the accept occurs, the foo block has matched the first line,
bound the text "1" to the variable @first. The block is then terminated.
Not only does the @first binding emerge from this terminated block, but
what also emerges is that the block advanced the data past the first line to
the second line. So next, the @(some) directive ends, and propagates the
bindings and position. Thus the @second which follows then matches the second
line and takes the text "2".

In the following query, the foo block occurs inside a maybe clause.
Inside the foo block there is a @(some) clause. Its first subclause
matches variable @first and then terminates block foo. Since block foo is
outside of the @(some) directive, this has the effect of terminating the
@(some) clause:

  Query:        @(maybe)
                @(block foo)
                @  (some)
                @first
                @  (accept foo)
                @  (or)
                @one
                @two
                @three
                @four
                @  (end)
                @(end)
                @second

  Data:         1
                2
                3
                4
                5

  Output (-B):  first="1"
                second="2"

The second clause of the @(some) directive, namely:

  @one
  @two
  @three
  @four

is never processed. The reason is that subclauses are processed in top
to bottom order, but the processing was aborted within the
first clause the @(accept foo). The @(some) construct never had the
opportunity to match four lines.

If the @(accept foo) line is removed from the above query, the output
is different:

  Query:        @(maybe)
                @(block foo)
                @  (some)
                @first
                @#          <--  @(accept foo) removed from here!!!
                @  (or)
                @one
                @two
                @three
                @four
                @  (end)
                @(end)
                @second

  Data:         1
                2
                3
                4
                5

  Output (-B):  first="1"
                one="1"
                two="2"
                three="3"
                four="4"
                second="5"

Now, all clauses of the @(some) directive have the opportunity to match.
The second clause grabs four lines, which is the longest match.
And so, the next line of input available for matching is 5, which goes
to the @second variable.

.SS Interaction between Trailer and Accept Directives

If one of the clauses which follow a @(trailer) request a successful
termination to an outer block via @(accept), then @(trailer) intercepts
the transfer and adjusts the data extent to the position that it was given.

Example:

  Query:        @(block)
                @(trailer)
                @line1
                @line2
                @(accept)
                @(end)
                @line3

  Data:         1
                2
                3

  Output (-B):  line1="1"
                line2="2"
                line3="1"

The variable line3 is bound to 1 because although the @(accept) yields a data
position which is advanced to the third line, this is intercepted by @(trailer)
and adjusted back to the first line.

Directives other than @(trailer) have no such special interaction with accept.

.SH FUNCTIONS

.SS Introduction

.B TXR
functions allow a query to be structured to avoid repetition.
On a theoretical note, because
.B TXR
functions support recursion, functions enable TXR to match some
kinds of patterns which exhibit self-embedding, or nesting,
and thus cannot be matched by a regular language.

Functions in
.B TXR
are not exactly like functions in mathematics or functional languages, and are
not like procedures in imperative programming languages. They are not exactly
like macros either. What it means for a
.B TXR
function to take arguments and produce a result is different from
the conventional notion of a function.

A
.B TXR
function may have one or more parameters. When such a function is invoked, an
argument must be specified for each parameter.  However, a special behavior is
at play here. Namely, some or all of the argument expressions may be unbound
variables.  In that case, the corresponding parameters behave like unbound
variables also.  Thus
.B TXR
function calls can transmit the "unbound" state from argument to parameter.

It should be mentioned that functions have access to all bindings that are
visible in the caller; functions may refer to variables which are not
mentioned in their parameter list.

With regard to returning,
.B TXR
functions are also unconventional. If the function fails, then the function
call is considered to have failed. The function call behaves like a kind of
match; if the function fails, then the call is like a failed match.

When a function call succeeds, then the bindings emanating from that function
are processed specially. Firstly, any bindings for variables which do not
correspond to one of the function's parameters are thrown away. Functions may
internally bind arbitrary variables in order to get their job done, but only
those variables which are named in the function argument list may propagate out
of the function call.  Thus, a function with no arguments can only indicate
matching success or failure, but not produce any bindings. Secondly,
variables do not propagate out of the function directly, but undergo
a renaming. For each parameter which went into the function as an unbound
variable (because its corresponding argument was an unbound variable),
if that parameter now has a value, that value is bound onto the corresponding
argument.

Example:

  @(define collect_words (list))
  @(coll)@{list /[^ \et]+/}@(end)
  @(end)

The above function "collect_words" contains a query which collects words from a
line (sequences of characters other than space or tab), into the list variable
called "list".  This variable is named in the parameter list of the function,
therefore, its value, if it has one, is permitted to escape from the function
call.

Suppose the input data is:

  Fine summer day

and the function is called like this:

  @(collect_words wordlist)

The result with txr -B is:

  wordlist[0]=Fine
  wordlist[1]=summer
  wordlist[1]=day

How it works is that in the function call @(collect_words wordlist),
"wordlist" is an unbound variable. The parameter corresponding to that
unbound variable is the parameter "list". Therefore, that parameter
is unbound over the body of the function.  The function body collects the
words of "Fine summer day" into the variable "list", and then
yields the that binding.   Then the function call completes by
noticing that the function parameter "list" now has a binding, and
that the corresponding argument "wordlist" has no binding. The binding
is thus transferred to the "wordlist" variable.  After that, the
bindings produced by the function are thrown away. The only enduring
effects are:
.IP -
the function matched and consumed some input; and
.IP -
the function succeeded; and
.IP -
the wordlist variable now has a binding.
.PP
Another way to understand the parameter behavior is that function
parameters behave like proxies which represent their arguments.  If an argument
is an established value, such as a character string or bound variable, the
parameter is a proxy for that value and behaves just like that value. If an
argument is an unbound variable, the function parameter acts as a proxy
representing that unbound variable. The effect of binding the proxy is
that the variable becomes bound, an effect which is settled when the
function goes out of scope.

Within the function, both the original variable and the proxy are
visible simultaneously, and are independent.  What if a function binds both of
them? Suppose a function has a parameter called P, which is called
with an argument A, and then in the function @A and @P are bound.  This is
permitted, and they can even be bound to different values.  However, when the
function terminates, the local binding of A simply disappears (because,
remember, the symbol A is not a member of the list of parameters).
Only the value bound to P emerges, and is bound to A, which still appears
unbound at that point.

.SS Definition Syntax

Function definition syntax comes in two flavors: vertical and horizontal.
Horizontal definitions actually come in two forms, the distinction
between which is hardly noticeable, and the need for which is
made clear below.

A function definition begins with a @(define ...) directive. For vertical
functions, this is the only element in a line.

The define symbol must be followed by a symbol, which is the name of the
function being defined. After the symbol, there is a parenthesized optional
argument list. If there is no such list, or if the list is specified as () or
the symbol "nil" then the function has no parameters. Examples of valid define
syntax are:

  @(define foo)
  @(define bar ())
  @(define match (a b c))

If the define directive is followed by more material on the same line, then
it defines a horizontal function:

  @(define match_x)x@(end)

If the define is the sole element in a line, then it
is a vertical function, and the function definition continues below:

  @(define match_x)
  x
  @(end)

The difference between the two is that a horizontal function matches
characters within a line, whereas a vertical function matches lines
within a stream. The former match_x matches the character x, advancing
to the next character position.  The latter match_x matches a line consisting
of the character x, advancing to the next line.

Material between @(define) and @(end) is the function body.  The define
directive may be followed directly by the @(end) directive, in which case the
function has an empty body.

Functions may be nested within function bodies. Such local functions have
dynamic scope. They are visible in the function body in which they are defined,
and in any functions invoked from that body.

The body of a function is an anonymous block. (See BLOCKS above).

.SS Two Forms of The Horizontal Function

If a horizontal function is defined as the only element of a line,
it may not be followed by additional material. The following
construct is erroneous:

  @(define horiz (x))@foo:@bar@(end)lalala

This kind of definition is actually considered to be in the vertical context,
and like other directives that have special effects and that do not match
anything, it does not consume a line of input. If the above syntax were
allowed, it would mean that the line would not only define a function but also
match "lalala".  This would, in turn, would mean that the @(define)...@(end) is
actually in horizontal mode, and so it matches a span of zero characters within
a line (which means that is would require a line of input to match: a nasty
thing for a non-matching directive to do!) 

A horizontal function can be defined in an actual horizontal context. This
occurs if its is in a line where it is preceded by other material.
For instance:

  X@(define fun)...@(end)Y

This is a query line which must match the text XY. It also defines the function
fun. The main use of this form is for nested horizontal functions:

  @(define fun)@(define local_fun)...@(end)@(end)

.SS Vertical-Horizontal Overloading

A function of the same name may be defined as both vertical and horizontal.
Both functions are available at the same time. Which one is used by
a call is resolved by context. See the section Vertical Versus Horizontal Calls below.

.SS Call Syntax

A function is invoked by compound directive whose first symbol is the name of
that function. Additional elements in the directive are the arguments.
Arguments may be symbols, or other objects like string and character
literals, quasiliterals ore regular expressions.

Example:

  Query:         @(define pair (a b))
                 @a @b
                 @(end)
                 @(pair first second)
                 @(pair "ice" cream)

  Data:          one two
                 ice milk

  Output (-B)    first="one"
                 second="two"
                 cream="milk"

The first call to the function takes the line "one two". The parameter "a"
takes "one" and parameter b takes "two". These are rebound to the arguments
first and second. The second call to the function binds the a parameter
to the word "ice", and the b is unbound, because the
corresponding argument "cream" is unbound. Thus inside the function, @a
is forced to match "ice". Then a space is matched and @b collects the text
"milk". When the function returns, the unbound "cream" variable gets this value.

If a symbol occurs multiple times in the argument list, it constrains
both parameters to bind to the same value. That is to say, all parameters
which, in the body of the function, bind a value, and which are all derived
from the same argument symbol must bind to the same value. This is settled when
the function terminates, not while it is matching. Example:

  Query:         @(define pair (a b))
                 @a @b
                 @(end)
                 @(pair same same)
 
  Data:          one two

  Output:        [query fails, prints "false"]


.SS Vertical Versus Horizontal Calls

A function call which is the only element of the query line in
which it occurs is ambiguous. It can go either to a vertical
function or to the horizontal one. If both are defined, then
it goes to the vertical one.

Example:

  Query:          @(define which (x))@(bind x "horizontal")@(end)
                  @(define which (x))
                  @(bind x "vertical")
                  @(end)
                  @(which fun)

  Output (-B):    fun="vertical"

Not only does this call go to the vertical function, but
it is in a vertical context.

If only a horizontal function is defined, then that is the one which is called,
even if the call is the only element in the line. This takes place in a
horizontal character-matching context, which requires a line of input which can
be traversed:

Example:

  Query:          @(define which (x))@(bind x "horizontal")@(end)
                  @(which fun)

  Data:           ABC

  Output (-B):    false

The query failed. Why? Because since @(which fun) is in horizontal mode,
it matches characters in a line. Since the function body consists
of @(bind ...) which doesn't match any characters, the function
call requires an empty line to match. The line ABC is not empty,
and so there is a matching failure. The following
example corrects this:

Example:

  Query:          @(define which (x))@(bind x "horizontal")@(end)
                  @(which fun)

  Data:           <empty line>

  Output (-B):    fun="horizontal"

A call made in a clearly horizontal context will prefer the
horizontal function, and only fall back on the vertical one
if the horizontal one doesn't exist. (In this fall-back case,
the vertical function is called with empty data; it is useful
for calling vertical functions which process arguments and
produce values.)

In the next example, the call is followed by trailing material,
placing it in a horizontal context. Leading material will
do the same thing:

Example:

  Query:          @(define which (x))@(bind x "horizontal")@(end)
                  @(define which (x))
                  @(bind x "vertical")
                  @(end)
                  @(which fun)B

  Data:           B

  Output (-B):    fun="horizontal"

.SS Local Variables

As described earlier, variables bound in a function body which are not
parameters of the function are discarded when the function returns. However,
that, by itself, doesn't make these variables local, because pattern functions
have visibility to all variables in their calling environment. If a variable x
exists already when a function is called, then an attempt to bind it inside a
function may result in a failure.  The @(local) directive must be used in a
pattern function to list which variables are local. 

Example:

  @(define path (path))@\e
    @(local x y)@\e
    @(cases)@\e
      (@(path x))@(path y)@(bind path `(@x)@y`)@\e
    @(or)@\e
      @{x /[.,;'!?][^ \et\ef\ev]/}@(path y)@(bind path `@x@y`)@\e
    @(or)@\e
      @{x /[^ .,;'!?()\et\ef\ev]/}@(path y)@(bind path `@x@y`)@\e
    @(or)@\e
      @(bind path "")@\e
    @(end)@\e
  @(end)

This is a horizontal function which matches a path, which lands into four
recursive cases. A path can be parenthesized path followed by a path; it can be
a certain character followed by a path, or it can be empty

This function ensures that the variables it uses internally, x and y, 
do not have anything to do with any inherited bindings for x and y.

Note that the function is recursive, which cannot work without x and y being
local, even if no such bindings exist prior to the top-level invocation of the
function. The invocation @(path x) causes x to be bound, which is
visible inside the invocation @(path y), but that invocation needs
to have its own binding of x for local use.

.SS Nested Functions

Function definitions may appear in a function. Such definitions
are visible in all functions which are invoked from the body
(and not necessarily enclosed in the body). In other words, the
scope is dynamic, not lexical.  Inner definitions shadow outer
definitions. This means that a caller can redirect the function
calls that take place in a callee, by defining local functions
which capture the references.

Example:

  Query:        @(define which)
                @  (fun)
                @(end)
                @(define fun)
                @  (output)
                toplevel fun!
                @  (end)
                @(end)
                @(define callee)
                @  (define fun)
                @    (output)
                local fun!
                @    (end)
                @  (end)
                @  (which)
                @(end)
                @(callee)
                @(which)

   Output:      local fun!
                toplevel fun!

Here, the function "which" is defined which calls "fun".
A toplevel definition of "fun" is introduced which
outputs "toplevel fun!".  The function "callee" provides its own local
definition of "fun" which outputs "local fun!" before calling "which".  When
callee is invoked, it calls @(which), whose @(fun) call is routed to callee's
local definition.  When @(which) is called directly from the top level, its
@(fun) call goes to the toplevel definition.

.SH MODULARIZATION

.SS The Load Directive

The syntax of the load directive is:

  @(load EXPR)

Where EXPR evaluates to a string giving the path of the file to load.
Unless the path is absolute, it is interpreted relative to the directory of the
source file from which the @(load) form was read. If there was no such
source file (for instance, the script was read from standard input),
then it is resolved relative to the current working directory.

If the file cannot be opened, then the .txr suffix is added and another
attempt is made. Thus load expressions need not refer to the suffix.
In the future, additional suffixes may be searched (compiled versions
of a file).

Loading is performed at evaluation time; it is not a source file inclusion
mechanism.  A TXR script is read from beginning to end and parsed prior to
being evaluated.

See also: the *self-path* variable in TXR Lisp.

.SH OUTPUT

.SS Introduction

A
.B TXR
query may perform custom output. Output is performed by @(output) clauses,
which may be embedded anywhere in the query, or placed at the end.  Output
occurs as a side effect of producing a part of a query which contains an
@(output) directive, and is executed even if that part of the query ultimately
fails to find a match. Thus output can be useful for debugging.
An output clause specifies that its output goes to a file, pipe, or (by
default) standard output. If any output clause is executed whose destination is
standard output,
.B TXR
makes a note of this, and later, just prior to termination, suppresses the
usual printing of the variable bindings or the word false.

.SS The Output Directive

The syntax of the @(output) directive is:

  @(output [ <destination> ] { bool-keyword | keyword value }* )
  .
  . one or more output directives or lines
  .
  @(end)

The optional destination is a filename, the special name, - which
redirects to standard output, or a shell command preceded by the ! symbol.
In the first form, the destination may be specified as a variable
which holds text, a string literal or a quasiliteral

The keyword list consists of a mixture of boolean keywords which
do not have an argument, or keywords with arguments.

The following boolean keywords are supported:

.IP :nothrow

The output directive throws an exception if the output destination
cannot be opened, unless the :nothrow keyword is present, in which
case the situation is treated as a match failure.  

Note that since command pipes are processes that report errors
asynchronously, a failing command will not throw an immediate exception that
can be suppressed with :nothrow.   This is for synchronous errors, like
trying to open a destination file, but not having permissions, etc.

.IP :append

This keyword is meaningful for files, specifying append mode: the output is to
be added to the end of the file rather than overwriting the file.

The following value keywords are supported:

.IP :filter

The argument can be a symbol, which specifies a filter to be applied to
the variable substitutions occurring within the output clause.
The argument can also be a list of filter symbols, which specifies
that multiple filters are to be applied, in left to right order.

See the later sections Output Filtering below, and The Deffilter Directive.

.IP :into

The argument of :into is a symbol which denotes a variable.
The output will go into that variable.  If the variable is unbound,
it will be created. Otherwise, its contents are overwritten
unless the :append keyword is used. If :append is used, then
the new content will be appended to the previous content of
the variable, after flattening the content to a list,
as if by the @(flatten) directive.

.IP :named 

The argument of :named is a symbol which denotes a variable.
The file or pipe stream which is opened for the output is
stored in this variable, and is not closed at the end of the
output block. This allows a subsequent output block to continue
output on the same stream, which is possible using the
next two keywords, :continue or :finish.
A new binding is established for the variable, even if it
already has an existing binding.

.IP :continue

A destination should not be specified if :continue is used.  The argument of
:continue is an expression, such as a variable name, that must evaluates to a
stream object. That stream object is used for the output block.
At the end of the output block, the stream is flushed, but not
closed.  A usage example is given in the documentation for the Close Directive
below.

.IP :finish

A destination should not be specified if :finish is used.  The argument of
:finish is an expression, such as a variable name, that must evaluates to a
stream object. That stream object is used for the output block.
At the end of the output block, the stream is closed.
An example is given in the documentation for the Close Directive
below.

.SS Output Text

Text in an output clause is not matched against anything, but is output
verbatim to the destination file, device or command pipe.

.SS Output Variables

Variables occurring in an output clause do not match anything, but instead
their contents are output.

A variable being output can be any object. If it is of a type other
than a string, it will be converted to a string as if by the tostring
function in TXR Lisp.

A list is converted to a string in a special way: the elements are
individually converted to a string and then they are catenated together.
The default separator string is a single space: an alternate separation
can be specified as an argument in the brace substitution syntax.

Lists may be output within @(repeat) or @(rep) clauses. Each nesting of
these constructs removes one level of nesting from the list variables
that it contains.

In an output clause, the @{NAME NUMBER} variable syntax generates fixed-width
field, which contains the variable's text.  The absolute value of the
number specifies the field width. For instance -20 and 20 both specify a field
width of twenty.  If the text is longer than the field, then it overflows the
field. If the text is shorter than the field, then it is left-adjusted within
that field, if the width is specified as a positive number, and right-adjusted
if the width is specified as negative.

An output variable may specify a filter which overrides any filter established
for the output clause. The syntax for this is @{NAME :filter <filterspec>}.
The filter specification syntax is the same as in the output clause.
See Output Filtering below.

.SS Output Variables: Indexing

Additional syntax is supported in output variables that does not appear
in pattern matching variables.

A square bracket index notation may be used to extract elements or
ranges from a variable, which works with strings, vectors and lists.  Elements
are indexed from zero. This notation is only available in brace-enclosed
syntax, and looks like this:

.IP
@{NAME[expr]} 

Extract the element at the position given by expr.

.IP
@{NAME[expr1..expr2]}

Extract a range of elements from the position given by expr1, up to
one position less than the position given by expr2.

If the variable is a list, it is treated as a list substitution,
exactly as if it were the value of an unsubscripted list variable.
The elements of the list are converted to strings and catenated
together wit ha separator string between them, the default one being
a single space.

An alternate character may be given as a string argument in the brace
notation.

.TP
Example:

  @(bind a ("a" "b" "c" "d"))
  @(output)
  @{a[1..3] "," 10}
  @(end)

The above produces the text "b,c" in a field 10 spaces wide. The [1..3]
argument extracts a range of a; the "," argument specifies an alternate
separator string, and 10 specifies the field width.

.SS Output Substitutions

The brace syntax has another syntactic and semantic extension. In place
of the symbol, an expression may appear. The value of that expression
is substituted.

Example:

 @(bind a "foo")
 @(output)
 @{`@a:` -10}

Here, the quasiliteral expression `@a:` is evaluated, producing the string
"foo:". This string is printed right-adjusted in a 10 character field.

.SS The Repeat Directive

The repeat directive generates repeated text from a ``boilerplate'',
by taking successive elements from lists. The syntax of repeat is
like this:

  @(repeat)
  .
  .
  main clause material, required
  .
  .
  special clauses, optional
  .
  .
  @(end)

Repeat has four types of special clauses, any of which may be
specified with empty contents, or omitted entirely. They are described
below.

Repeat takes arguments, also described below.

All of the material in the main clause and optional clauses
is examined for the presence of variables.  If none of the variables
hold lists which contain at least one item, then no output is performed,
(unless the repeat specifies an @(empty) clause, see below).
Otherwise, among those variables which contain non-empty lists, repeat finds
the length of the longest list. This length of this list determines the number
of repetitions, R.

If the repeat contains only a main clause, then the lines of this clause is
output R times. Over the first repetition, all of the variables which, outside
of the repeat, contain lists are locally rebound to just their first item. Over
the second repetition, all of the list variables are bound to their second
item, and so forth. Any variables which hold shorter lists than the longest
list eventually end up with empty values over some repetitions.

Example: if the list A holds "1", "2" and "3"; the list B holds "A", "B";
and the variable C holds "X", then

  @(repeat)
  >> @C
  >> @A @B
  @(end)

will produce three repetitions (since there are two lists, the longest
of which has three items). The output is:

  >> X
  >> 1 A
  >> X
  >> 2 B
  >> X
  >> 3

The last line has a trailing space, since it is produced by "@A @B",
where @B has an empty value. Since C is not a list variable, it
produces the same value in each repetition.

The special clauses are:

.IP @(single)
If the repeat produces exactly one repetition, then the contents of this clause
are processed for that one and only repetition, instead of the main clause
or any other clause which would otherwise be processed.

.IP @(first)
The body of this clause specifies an alternative body to be used for the first
repetition, instead of the material from the main clause.

.IP @(last)
The body of this clause is used instead of the main clause for the last
repetition.

.IP @(empty)
If the repeat produces no repetitions, then the body of this clause is output.
If this clause is absent or empty, the repeat produces no output.

.IP "@(mod n m)"
The forms n and m are expressions that evaluate to integers. The value of
m should be nonzero. The clause denoted this way is active if the repetition
modulo m is equal to n. The first repetition is numbered zero.
For instance the clause headed by @(mod 0 2) will be used on repetitions 
0, 2, 4, 6, ...  and @(mod 1 2) will be used on repetitions 1, 3, 5, 7, ...

.IP "@(modlast n m)"
The meaning of n and m is the same as in @(mod n m), but one more condition
is imposed. This clause is used if the repetition modulo m is
equal to n, and if it is the last repetition.

.PP
The precedence among the clauses which take an iteration is:
single > first > mod > modlast > last > main.  That is if two or more of these
clauses can apply to a repetition, then the leftmost one in this precedence
list applies. For instance, if there is just a single repetition, then any of
these special clause types can apply to that repetition, since it is the only
repetition, as well as the first and last one. In this situation, if there is a
@(single) clause present, then the repetition is processed using that clause.
Otherwise, if there is a @(first) clause present, that clause is used. Failing
that, @(mod) is used if there is such a clause and its numeric conditions
are satisfied. If not then @(modlast) clauses are considered, and if there
are none, or none of them activate, then @(last) is considered. If none
of those clauses are present or apply, then the repetition is processed
using the main clause.

Repeat supports arguments.

  @(repeat [:counter <symbol>] [:vars (<symbol>*)])

The :counter argument designates a symbol which will behave as an integer
variable over the scope of the clauses inside the repeat. The variable provides
access to the repetition count, starting at zero, incrementing with each
repetition.

The :vars argument specifies a list of variables. The repeat directive
will pick out from this list those variables which have bindings.
It will assume that all these variables occur in the repeat block and
are to be iterated. This syntax is needed for situations in which @(repeat)
is not able to deduce the existence of a variable in the block. 
It does not dig very deeply to discover variables, and does not "see"
variables that are referenced via embedded TXR Lisp expressions.
For instance, the following produces no output:

  @(bind list ("a" "b" "c"))
  @(output)
  @(repeat)
  @(format nil "<~a>" list)
  @(end)
  @(end)

Although the list variable appears in the repeat block, it is embedded
in a TXR Lisp construct. That construct will never be evaluated because
no repetitions take place: the repeat construct doesn't find any variables
and so doesn't iterate. The remedy is to provide a little help via
the :vars parameter:

  @(bind list ("a" "b" "c"))
  @(output)
  @(repeat :vars (list))
  @(format nil "<~a>" list)
  @(end)
  @(end)

Now the repeat block iterates over list and the output is:

  <a>
  <b>
  <c>

.SS Nested Repeats

If a repeat clause encloses variables which hold multidimensional lists,
those lists require additional nesting levels of repeat (or rep).
It is an error to attempt to output a list variable which has not been
decimated into primary elements via a repeat construct.

Suppose that a variable X is two-dimensional (contains a list of lists).  X
must be twice nested in a repeat. The outer repeat will walk over the lists
contained in X. The inner repeat will walk over the elements of each of these
lists.

A nested repeat may be embedded in any of the clauses of a repeat,
not only the main clause.

.SS The Rep Directive

The @(rep) directive is similar to @(repeat), but whereas @(repeat) is line
oriented, @(rep) generates material within a line. It has all the same clauses,
but everything is specified within one line:

  @(rep)... main material ... .... special clauses ...@(end)

More than one @(rep) can occur within a line, mixed with other material.
A @(rep) can be nested within a @(repeat) or within another @(rep).

Also, @(rep) accepts the same :counter and :vars arguments.

.SS Repeat and Rep Examples

Example 1: show the list L in parentheses, with spaces between
the elements, or the symbol NIL if the list is empty:

  @(output)
  @(rep)@L @(single)(@L)@(first)(@L @(last)@L)@(empty)NIL@(end)
  @(end)

Here, the @(empty) clause specifies NIL. So if there are no repetitions,
the text NIL is produced. If there is a single item in the list L,
then  @(single)(@L) produces that item between parentheses.  Otherwise
if there are two or more items, the first item is produced with
a leading parenthesis followed by a space by @(first)(@L , and
the last item is produced with a closing parenthesis: @(last)@L).
All items in between are emitted with a trailing space by
the main clause: @(rep)@L .

Example 2: show the list L like Example 1 above, but the empty list is ().

  @(output)
  (@(rep)@L @(last)@L@(end))
  @(end)

This is simpler. The parentheses are part of the text which
surrounds the @(rep) construct, produced unconditionally.
If the list L is empty, then @(rep) produces no output, resulting in ().
If the list L has one or more items, then they are produced with
spaces each one, except the last which has no space.
If the list has exactly one item, then the @(last) applies to it
instead of the main clause: it is produced with no trailing space.

.SS The Close Directive

The syntax of the @(close) directive is:

  @(close <expr>)

Where <expr> evaluates to a stream. The close directive can be
used to explicitly close streams created using @(output ... :named <var>)
syntax, as an alternative to the @(output :finish <expr>)

Examples:

Write two lines to "foo.txt" over two output blocks using
a single stream:

  @(output "foo.txt" :named foo)
  Hello,
  @(end)
  @(output :continue foo)
  world!
  @(end)
  @(close foo)

The same as above, using :finish rather than :continue
so that the stream is closed at the end of the second block:

  @(output "foo.txt" :named foo)
  Hello,
  @(end)
  @(output :finish foo)
  world!
  @(end)

.SS Output Filtering

Often it is necessary to transform the output to preserve its meaning
under the convention of a given data format. For instance, if a piece of
text contains the characters < or >, then if that text is being
substituted into HTML, these should be replaced by &lt; and &gt;.
This is what filtering is for.  Filtering is applied to the contents of output
variables, not to any template text.
.B TXR
implements named filters.  Built-in filters are named by keywords,
given below. User-defined filters are possible, however.  See notes on the
deffilter directive below.

Instead of a filter name, the syntax (fun NAME) can be used. This
denotes that the function called NAME is to be used as a filter.
This is discussed in the next section Function Filters below.

Built-in filters named by keywords:

.IP :to_html
Filter text to HTML, representing special characters using HTML
ampersand sequences. For instance '>' is replaced by '&gt;'.

.IP :from_html
Filter text with HTML codes into text in which the codes are replaced by the
corresponding characters. For instance '&gt;' is replaced by '>'.

.IP :upcase
Convert the 26 lower case letters of the English alphabet to upper case.

.IP :downcase
Convert the 26 upper case letters of the English alphabet to lower case.

.IP :frompercent
Decode percent-encoded text. Character triplets consisting
of the % character followed by a pair of hexadecimal digits (case insensitive)
are are converted to bytes having the value represented by the hexadecimal
digits (most significant nybble first). Sequences of one or more such bytes are
treated as UTF-8 data  and decoded to characters.

.IP :topercent
Convert to percent encoding according to RFC 3986. The text is first converted
to UTF-8 bytes. The bytes are then converted back to text as follows.
Bytes in the range 0 to 32, and 127 to 255 (note: including the ASCII DEL), 
bytes whose values correspond to ASCII characters which are listed by RFC 3986 
as being in the "reserved set", and the byte value corresponding to the
ASCII % character are encoded as a three-character sequence consisting
of the % character followed by two hexadecimal digits derived from the
byte value (most significant nybble first, upper case). All other bytes
are converted directly to characters of the same value without any such
encoding.

.IP :fromurl
Decode from URL encoding, which is like percent encoding, except that
if the unencoded + character occurs, it is decoded to a space character.
Of course %20 still decodes to space, and %2B to the + character.

.IP :tourl
Encode to URL encoding, which is like percent encoding except that
a space maps to + rather than %20. The + character, being in the
reserved set, encodes to %2B.

.IP :tonumber
Converts strings to numbers. Strings that contain a period, e or E are
converted to floating point as if by the function flo-str. Otherwise
they are converted to integer as if using int-str with a radix of 10.
Non-numeric junk results in the object nil.

.IP :tointeger
Converts strings to integers as if using int-str with a radix of 10.
Non-numeric junk results in the object nil.

.IP :tofloat
Converts strings to floating-point values as if using the function flo-str.
Non-numeric junk results in the object nil.

.IP :hextoint
Converts strings to integers as if using int-str with a radix of 16.
Non-numeric junk results in the object nil.

.PP

.TP
Examples

To escape HTML characters in all variable substitutions occurring in an
output clause, specify :filter :to_html in the directive:

  @(output :filter :to_html)
  ...
  @(end)

To filter an individual variable, add the syntax to the variable spec:

  @(output)
  @{x :filter :to_html}
  @(end)

Multiple filters can be applied at the same time. For instance:

  @(output)
  @{x :filter (:upcase :to_html)}
  @(end)

This will fold the contents of x to upper case, and then encode any special
characters into HTML. Beware of combinations that do not make sense.
For instance, suppose the original text is HTML, containing codes
like '&quot;'. The compound filter (:upcase :from_html) will not work
because '&quot;' will turn to '&QUOT;' which no longer be recognized
by the :from_html filter, because the entity names in HTML codes
are case-sensitive.

Capture some numeric variables and convert to numbers:

  @date @time @temperature @pressure
  @(filter :tofloat temperature pressure)
  @;; temperature and pressure can now be used in calculations

.SS Function Filters

A function can be used as a filter. For this to be possible, the function must
conform to certain rules:

.IP 1.
The function must take two special arguments, which may be followed
by additional arguments.

.IP 2.
When the function is called, the first argument will be bound to a string,
and the second argument will be unbound. The function must produce a 
value by binding it to the second argument. If the filter is to be used
as the final filter in a chain, it must produce a string.

For instance, the following is a valid filter function:

  @(define foo_to_bar (in out))
  @  (next :string in)
  @  (cases)
  foo
  @    (bind out "bar")
  @  (or)
  @    (bind out in)
  @  (end)
  @(end)

This function binds the out parameter to "bar" if the in parameter
is "foo", otherwise it binds the out parameter to a copy of the in parameter.
This is a simple filter.

To use the filter, use the syntax (:fun foo_to_bar) in place of a filter name. 
For instance in the bind directive:

  @(bind "foo" "bar" :lfilt (:fun foo_to_bar))

The above should succeed since the left side is filtered from "foo"
to "bar", so that there is a match.

Of course, function filters can be used in a chain:

  @(output :filter (:downcase (:fun foo_to_bar) :upcase))
  ...
  @(end)

Here is a split function which takes an extra argument.

  @(define split (in out sep))
  @  (next :list in)
  @  (coll)@(maybe)@token@sep@(or)@token@(end)@(end)
  @  (bind out token)
  @(end)

Furthermore, note that it produces a list rather than a string.
This function separates the argument in into tokens according to the
separator text sep.

Here is another function, join, which catenates a list:

  @(define join (in out sep))
  @  (output :into out)
  @  (rep)@in@sep@(last)@in@(end)
  @  (end)
  @(end)

Now here is these two being used in a chain:

  @(bind text "how,are,you")
  @(output :filter (:fun split ",") (:fun join "-"))
  @text
  @(end)

Output:

  how-are-you

When the filter invokes a function, it generates the first two arguments
internally to pass in the input value and capture the output. The remaining
arguments from the (:fun ...) construct are also passed to the function.
Thus the "," and "-" are passed as the sep argument to split and join.

Note that split puts out a list, which join accepts. So the overall filter
chain operates on a string: a string goes into split, and a string comes out of
join.

.SS The Deffilter Directive

The deffilter directive allows a query to define a custom filter, which
can then be used in @(output) clauses to transform substituted data.

This directive's syntax is illustrated in this example:

  Query:        @(deffilter rot13 
                   ("a" "n")
                   ("b" "o")
                   ("c" "p")
                   ("d" "q")
                   ("e" "r")
                   ("f" "s")
                   ("g" "t")
                   ("h" "u")
                   ("i" "v")
                   ("j" "w")
                   ("k" "x")
                   ("l" "y")
                   ("m" "z")
                   ("n" "a")
                   ("o" "b")
                   ("p" "c")
                   ("q" "d")
                   ("r" "e")
                   ("s" "f")
                   ("t" "g")
                   ("u" "h")
                   ("v" "i")
                   ("w" "j")
                   ("x" "k")
                   ("y" "l")
                   ("z" "m"))
                @(collect)
                @line
                @(end)
                @(output :filter rot13)
                @(repeat)
                @line
                @(end)
                @(end)

  Input:        hey there!

  Output:       url gurer!


The deffilter symbol must be followed by the name of the filter to be defined,
followed by forms which evaluate to lists of strings. Each list must
be at least two elements long and specifies one or more texts which are mapped
to a replacement text. For instance, the following specifies a telephone keypad
mapping from upper case letters to digits.
 
  @(deffilter alpha_to_phone ("E" "0") 
                             ("J" "N" "Q" "1")
                             ("R" "W" "X" "2")
                             ("D" "S" "Y" "3")
                             ("F" "T" "4")
                             ("A" "M" "5")
                             ("C" "I" "V" "6")
                             ("B" "K" "U" "7")
                             ("L" "O" "P" "8")
                             ("G" "H" "Z" "9"))

  @(deffilter foo (`@a` `@b`) ("c" `->@d`))

  @(bind x ("from" "to"))
  @(bind y ("---" "+++"))
  @(deffilter sub x y)

The last deffilter above equivalent to 
@(deffilter sub ("from" "to") ("---" "+++")).

Filtering works using a longest match algorithm. The input is scanned from left
to right, and the longest piece of text is identified at every character
position which matches a string on the left hand side, and that text is
replaced with its associated replacement text. The scanning then continues
at the first character after the matched text.

If none of the strings matches at a given character position, then that
character is passed through the filter untranslated, and the scan continues at
the next character in the input.

Filtering is not in-place but rather instantiates a new text, and so
replacement text is not re-scanned for more replacements.

If a filter definition accidentally contains two or more repetitions of the
same left hand string with different right hand translations, the later ones
take precedence. No warning is issued.


.SS The Filter Directive

The syntax of the filter directive is:

  @(filter FILTER { VAR }+ )

A filter is specified, followed by one or more variables whose values
are filtered and stored back into each variable.

Example: convert a, b, and c to upper case and HTML encode:

  @(filter (:upcase :to_html) a b c)

.SH EXCEPTIONS

.SS Introduction

The exceptions mechanism in
.B TXR
is another disciplined form of non-local transfer, in addition to the blocks
mechanism (see BLOCKS above).  Like blocks, exceptions provide a construct
which serves as the target for a dynamic exit.  Both blocks and exceptions
can be used to bail out of deep nesting when some condition occurs.
However, exceptions provide more complexity. Exceptions are useful for
error handling, and TXR in fact maps certain error situations to exception
control transfers. However, exceptions are not inherently an error-handling
mechanism; they are a structured dynamic control transfer mechanism, one
of whose applications is error handling.

An exception control transfer (simply called an exception) is always identified
by a symbol, which is its type. Types are organized in a subtype-supertype
hierarchy.  For instance, the file_error exception type is a subtype of the
error type. This means that a file error is a kind of error. An exception
handling block which catches exceptions of type error will catch exceptions of
type file_error, but a block which catches file_error will not catch all
exceptions of type error. A query_error is a kind of error, but not a kind of
file_error. The symbol t is the supertype of every type: every exception type
is considered to be a kind of t.  (Mnemonic: t stands for type, as in any
type).

Exceptions are handled using @(catch) clauses within a @(try) directive.

In addition to being useful for exception handling, the @(try) directive
also provides unwind protection by means of a @(finally) clause,
which specifies query material to be executed unconditionally when
the try clause terminates, no matter how it terminates.

.SS The Try Directive

The general syntax of the try directive is

  @(try)
  ... main clause, required ...
  ... optional catch clauses ...
  ... optional finally clause
  @(end)

A catch clause looks like:

  @(catch TYPE)
  .
  .
  .

and also the this form, equivalent to @(catch (t)):

  @(catch)
  .
  .
  .

which catches all exceptions.

A finally clause looks like:

  @(finally)
  ...
  .
  .

The main clause may not be empty, but the catch and finally may be.

A try clause is surrounded by an implicit anonymous block (see BLOCKS section
above). So for instance, the following is a no-op (an operation with no effect,
other than successful execution):

  @(try)
  @(accept)
  @(end)

The @(accept) causes a successful termination of the implicit anonymous block.
Execution resumes with query lines or directives which follow, if any.

Try clauses and blocks interact. For instance, a block accept from within
a try clause invokes a finally.

  Query:        @(block foo)
                @  (try)
                @    (accept foo)
                @  (finally)
                @     (output)
                bye!
                @     (end)
                @  (end)

  Output:       bye!

How this works: the try block's main clause is @(accept foo). This causes
the enclosing block named foo to terminate, as a successful match.
Since the try is nested within this block, it too must terminate
in order for the block to terminate. But the try has a finally clause,
which executes unconditionally, no matter how the try block
terminates. The finally clause performs some output, which is seen.

.SS The Finally Clause

A try directive can terminate in one of three ways. The main clause
may match successfully, and possibly yield some new variable bindings.
The main clause may fail to match. Or the main clause may be terminated
by a non-local control transfer, like an exception being thrown or a block
return (like the block foo example in the previous section).

No matter how the try clause terminates, the finally clause is processed.

Now, the finally clause is itself a query which binds variables, which leads to
the question: what happens to such variables? What if the finally block fails
as a query? Another question is: what if a finally clause itself initiates a
control transfer?  Answers follow.

Firstly, a finally clause will contribute variable bindings only if the main
clause terminates normally (either as a successful or failed match).
If the main clause successfully matches, then the finally block continues
matching at the next position in the data, and contributes bindings.
If the main clause fails, then the finally block matches at the
same position.

The overall try directive succeeds as a match if either the main clause
or the finally clause succeed. If both fail, then the try directive is
a failed match. The subquery in which it is located fails, et cetera.

Example:

  Query:        @(try)
                @a
                @(finally)
                @b
                @(end)
                @c

  Data:         1
                2
                3

  Output (-B):  a="1"
                b="2"
                c="3"

In this example, the main clause of the try captures line "1" of the data as
variable a, then the finally clause captures "2" as b, and then the
query continues with the @c variable after try block, and captures "3".


Example:

  Query:        @(try)
                hello @a
                @(finally)
                @b
                @(end)
                @c

  Data:         1
                2

  Output (-B):  b=1
                c=2

In this example, the main clause of the try fails to match, because
the input is not prefixed with "hello ". However, the finally clause
matches, binding b to "1". This means that the try block is a successful
match, and so processing continues with @c which captures "2".

When finally clauses are processed during a non-local return,
they have no externally visible effect if they do not bind variables.
However, their execution makes itself known if they perform side effects,
such as output.

A finally clause guards only the main clause and the catch clauses. It does not
guard itself.   Once the finally clause is executing, the try block is no
longer guarded.  This means if a nonlocal transfer, such as a block accept
or exception, is initiated within the finally clause, it will not re-execute
the finally clause. The finally clause is simply abandoned.

The disestablishment of blocks and try clauses is properly interleaved
with the execution of finally clauses. This means that all surrounding
exit points are visible in a finally clause, even if the finally clause
is being invoked as part of a transfer to a distant exit point.
The finally clause can make a control transfer to an exit point which
is more near than the original one, thereby "hijacking" the control
transfer. Also, the anonymous block established by the try directive
is visible in the finally clause.

Example:

  @(try)
  @  (try)
  @    (next "nonexistent-file")
  @  (finally)
  @    (accept)
  @  (end)
  @(catch file_error)
  @  (output)
  file error caught
  @  (end)
  @(end)

In this example, the @(next) directive throws an exception of type file_error,
because the given file does not exist. The exit point for this exception is the
@(catch file_error) clause in the outer-most try block. The inner block is
not eligible because it contains no catch clauses at all. However, the inner
try block has a finally clause, and so during the processing of this
exception which is headed for the @(catch file_error), the finally
clause performs an anonymous accept. The exit point for the accept
is the anonymous block surrounding the inner try.  So the original
transfer to the catch clause is forgotten. The inner try terminates
successfully, and since it constitutes the main clause of the outer try,
that also terminates successfully. The "file error caught" message is
never printed.

.SS Catch Clauses

Catch clauses establish a try block as a potential exit point for
an exception-induced control transfer (called a ``throw'').

A catch clause specifies an optional list of symbols which represent
the exception types which it catches. The catch clause will catch
exceptions which are a subtype of any one of those exception types.

If a try block has more than one catch clause which can match a given
exception, the first one will be invoked.

When a catch is invoked, it is of course understood that the main clause did
not terminate normally, and so the main clause could not have produced any
bindings.

Catches are processed prior to finally.

If a catch clause itself throws an exception, that exception cannot
be caught by that same clause or its siblings in the same try block.
The catches of that block are no longer visible at that point.
Nevertheless, the catch clauses are still protected by the finally block.
If a catch clause throws, the finally block is still processed.

If a finally block throws an exception, then it is simply aborted;
the remaining directives in that block are not processed.

So the success or failure of the try block depends on the behavior of the catch
clause or the finally, if there is one. If either of them succeed, then the try
block is considered a successful match.

Example:

  Query:        @(try)
                @  (next "nonexistent-file")
                @  x
                @  (catch file_error)
                @a
                @(finally)
                @b
                @(end)
                @c

  Data:         1
                2
                3

  Output (-B):  a="1"
                b="2"
                c="3"

Here, the try block's main clause is terminated abruptly by a file_error
exception from the @(next) directive.   This is handled by the
catch clause, which binds variable a to the input line "1".
Then the finally clause executes, binding b to "2". The try block
then terminates successfully, and so @c takes "3".

.SS Catch Clauses with Parameters

A catch may have parameters following the type name, like this:

  @(catch pair (a b))

To write a catch-all with parameters, explicitly write the
master supertype t:

  @(catch t (arg ...))

Parameters are useful in conjunction with throw. The built-in
error exceptions generate one argument, which is a string containing
the error message. Using throw, arbitrary parameters can be passed
from the throw site to the catches.

.SS The Throw Directive

The throw directive generates an exception. A type must be specified,
followed by optional arguments. For example,

  @(throw pair "a" `@file.txt`)

throws an exception of type pair, with two arguments, being "a"
and the expansion of the quasiliteral `@file.txt`.

The selection of the target catch is performed purely using the type
name; the parameters are not involved in the selection.

Binding takes place between the arguments given in throw, and the
target catch.

If any catch parameter, for which a throw argument is given, is a bound
variable, it has to be identical to the argument, otherwise the catch fails.
(Control still passes to the catch, but the catch is a failed match).

  Query:        @(bind a "apple")
                @(try)
                @(throw e "banana")
                @(catch e (a))
                @(end)

  Output:       false

If any argument is an unbound variable, the corresponding parameter
in the catch is left alone: if it is an unbound variable, it remains
unbound, and if it is bound, it stays as is.

  Query:        @(try)
                @(trow e "honda" unbound)
                @(catch e (car1 car2))
                @car1 @car2
                @(end)

  Data:         honda toyota

  Output (-B):  car1="honda"
                car2="toyota"

If a catch has fewer parameters than there are throw arguments,
the excess arguments are ignored.

  Query:         @(try)
                 @(throw e "banana" "apple" "pear")
                 @(catch e (fruit))
                 @(end)

  Output (-B):   fruit="banana"

If a catch has more parameters than there are throw arguments, the excess
parameters are left alone. They may be bound or unbound variables.

  Query:        @(try)
                @(trow e "honda")
                @(catch e (car1 car2))
                @car1 @car2
                @(end)

  Data:         honda toyota

  Output (-B):  car1="honda"
                car2="toyota"

A throw argument passing a value to a catch parameter which is unbound causes
that parameter to be bound to that value.

Throw arguments are evaluated in the context of the throw, and the bindings
which are available there. Consideration of what parameters are bound
is done in the context of the catch.

  Query:        @(bind c "c")
                @(try)
                @(forget c)
                @(bind (a c) ("a" "lc"))
                @(throw e a c)
                @(catch e (b a))
                @(end)

   Output (-B): c="c"
                b="a"
                a="lc"

In the above example, c has a toplevel binding to the string "c",
but is then unbound within the try construct, and rebound to the value "c".
Since the try construct is terminated by a throw, these modifications of the
binding environment are discarded. Hence, at the end of the query, variable
c ends up bound to the original value "c".  The throw still takes place
within the scope of the bindings set up by the try clause, so the values of
a and c that are thrown are "a" and "lc".  However, at the catch site, variable
a does not have a binding.  At that point, the binding to "a" established in
the try has disappeared already. Being unbound, the catch parameter a can take
whatever value the corresponding throw argument provides, so it ends up with
"lc".

.SS The Defex Directive

The defex directive allows the query writer to invent custom exception types,
which are arranged in a type hierarchy (meaning that some exception types are
considered subtypes of other types).

Subtyping means that if an exception type B is a subtype of A, then every
exception of type B is also considered to be of type A. So a catch for type A
will also catch exceptions of type B.  Every type is a supertype of itself: an
A is a kind of A. This of course implies that ever type is a subtype of itself
also.  Furthermore, every type is a subtype of the type t, which has no
supertype other than itself. Type nil is is a subtype of every type, including
itself.  The subtyping relationship is transitive also. If A is a subtype
of B, and B is a subtype of C, then A is a subtype of C.

Defex may be invoked with no arguments, in which case it does nothing:

  @(defex)

It may be invoked with one argument, which must be a symbol. This introduces a
new exception type. Strictly speaking, such an introduction is not necessary;
any symbol may be used as an exception type without being introduced by
@(defex):

  @(defex a)

Therefore, this also does nothing, other than document the intent to use
a as an exception.

If two or more argument symbols are given, the symbols are all introduced as
types, engaged in a subtype-supertype relationship from left to right.
That is to say, the first (leftmost) symbol is a subtype of the next one,
which is a subtype of the next one and so on. The last symbol, if it
had not been already defined as a subtype of some type, becomes a
direct subtype of the master supertype t. Example:

  @(defex d e)
  @(defex a b c d)

The fist directive defines d as a subtype of e, and e as a subtype of t.
The second defines a as a subtype of b, b as a subtype of c, and
c as a subtype of d, which is already defined as a subtype of e.
Thus a is now a subtype of e. It should be obvious that the above
could be condensed to:

  @(defex a b c d e)

Example:

  Query:        @(defex gorilla ape primate)
                @(defex monkey primate)
                @(defex human primate)
                @(collect)
                @(try)
                @(skip)
                @(cases)
                gorilla @name
                @(throw gorilla name)
                @(or)
                monkey @name
                @(throw monkey name)
                @(or)
                human @name
                @(throw human name)
                @(end)@#cases
                @(catch primate (name))
                @kind @name
                @(output)
                we have a primate @name of kind @kind
                @(end)@#output
                @(end)@#try
                @(end)@#collect


  Input:        gorilla joe
                human bob
                monkey alice

  Output:       we have a primate joe of kind gorilla
                we have a primate bob of kind human
                we have a primate alice of kind monkey

Exception types have a pervasive scope. Once a type relationship is introduced,
it is visible everywhere. Moreover, the defex directive is destructive,
meaning that the supertype of a type can be redefined. This is necessary so
that something like the following works right.

  @(defex gorilla ape)
  @(defex ape primate)

These directives are evaluated in sequence. So after the first one, the ape
type has the type t as its immediate supertype.  But in the second directive,
ape appears again, and is assigned the primate supertype, while retaining
gorilla as a subtype.  This situation could instead be diagnosed as an
error, forcing the programmer to reorder the statements, but instead
TXR obliges. However, there are limitations.  It is an error to define a
subtype-supertype relationship between two types if they are already connected
by such a relationship, directly or transitively. So the following
definitions are in error:

  @(defex a b)
  @(defex b c)
  @(defex a c)@# error: a is already a subtype of c, through b

  @(defex x y)
  @(defex y x)@# error: circularity; y is already a supertype of x.

.SS The Assert directive

The assert directive requires the remaining query or sub-query which follows it
to match. If the remainder fails to match, the assert directive throws an
exception. If the directive is simply

  @(assert)

Then it throws an assertion of type assert, which is a subtype of error.
The assert directive also takes arguments similar to the throw
directive. The following assert directive, if it triggers, will throw
an exception of type foo, with arguments 1 and "2".

  @(assert foo 1 "2")

The throw directive generates an exception. A type must be specified,
followed by optional arguments.

Example:

  @(collect)
  Important Header
  ----------------
  @(assert)
  Foo: @a, @b
  @(end)

Without the assertion in places, if the "Foo: @a, @b" part does not
match, then the entire interior of the @(collect) clause fails,
and the collect continues searching for another match.

With the assertion in place, if the "Important Header" and its
underline match, then the remainder of the collect body must
match, otherwise an exception is thrown. Now the program will not
silently skip over any Important Header sections due to a problem
in its matching logic. This is particularly useful when the matching is varied
with numerous cases, and they must all be handled.

There is a horizontal directive also. For instance:

  abc@(assert)d@x

asserts that if the prefix "abc" is matched, then it must be
followed by a successful match for "d@x", or else an exception
is thrown.


.SH TXR LISP

The TXR language contains an embedded Lisp dialect called TXR Lisp.

This language is exposed in TXR in several ways.

Firstly, in any situation that calls for an expression, a Lisp 
expression can be used, if it is preceded by the @ symbol. The Lisp expression
is evaluated and its value  becomes the value of that expression.
Thus, TXR directives are embedded in literal text using @, and Lisp expressions
are embedded in directives using @ also. 

Secondly, the @(do) directive can be used for evaluating one or more Lisp
forms, such that their value is thrown away. This is useful for evaluating some
Lisp code for the sake of its side effect, such as defining a variable,
updating a hash table, et cetera.

Thirdly, the @(require) directive can be used to evaluate Lisp expressions
as part of the matching logic of the TXR pattern language. The return value
of the rightmost expression is examined. If it is nil, then the @(require)
directive triggers a match failure. Otherwise, matching proceeds.

Lastly, TXR Lisp expressions can be evaluated via the txr command line,
using the -e and -p options.

Examples:

Bind variable a to the integer 4:

  @(bind a @(+ 2 2))

Bind variable b to the standard input stream:

  @(bind a @*stdin*)

Define several Lisp functions using @(do):

  @(do 
    (defun add (x y) (+ x y))

    (defun occurs (item list)
      (cond ((null list) nil)
            ((atom list) (eql item list))
            (t (or (eq (first list) item)
                   (occurs item (rest list)))))))

Trigger a failure unless previously bound variable "answer" is greater
than 42:

  @(require (> (str-int answer) 42)

.SS Overview

TXR Lisp is a small and simple dialect, like Scheme, but much more similar to
Common Lisp than Scheme. It has separate value and function binding namespaces,
like Common Lisp (and thus is a Lisp-2 type dialect), and represents boolean
true and false with the symbols t and nil (but note the case sensitivity of
identifiers denoting symbols!) Furthermore, the symbol nil is also the empty
list, which terminates nonempty lists.

Function and variable bindings are dynamically scoped in TXR Lisp. However,
closures do capture variables.

.SS Additional Syntax

Much of the TXR Lisp syntax has been introduced in the previous sections of the
manual, since directive forms are based on it. There is some additional syntax
that is useful in TXR Lisp programming.

.SS Consing Dot

Unlike other major Lisp dialects, TXR Lisp allows a consing dot with no forms
preceding it. This construct simply denotes the form which follows the dot.
That is to say, the parser implements the following transformation:

  (. expr) -> expr

This is convenient in writing function argument lists that only take
variable arguments. Instead of the syntax:

  (defun fun args ...)

the following syntax can be used:

  (defun fun (. args) ...)

When a lambda form is printed, it is printed in the following style.

  (lambda nil ...) -> (lambda () ...)
  (lambda sym ...) -> (lambda (. sym) ...)
  (lambda (sym) ...) -> (lambda (sym) ...)

In no other circumstances is nil printed as (), or a symbol as (. sym).

symbol is followed by a symbol.

.SS Quote and Quasiquote

.IP '<expr>

The quote character in front of an expression is used for suppressing evaluation,
which is useful for forms that evaluate to something other than themselves.
For instance if '(+ 2 2) is evaluated, the value is the three-element list
(+ 2 2), whereas if (+ 2 2) is evaluated, the value is 4. Similarly, the
value of 'a is the symbol a itself, whereas the value of a is the value
of the variable a.

.IP ^<qq-template>

The caret in front of an expression is a quasiquote. A quasiquote is like
a quote, but with the possibility of substitution of material.

Under a quasiquote, form is considered to be a quasiquote template. The template
is considered to be a literal structure, except that it may contain
the notations ,<expr> and ,*<expr>  which denote non-constant parts.

A quasiquote gets translated into code which, when evaluated, constructs
the structure implied by <qq-template>, taking into account the unquotes
and splices.

A quasiquote also processes nested quasiquotes specially.

If <qq-template> does not contain any unquotes or splices (which match its
level of nesting), or is simply an atom, then ^<qq-template> is equivalent to
'<qq-template>: in other words, it is like an ordinary quote.  For instance ^(a
b ^(c ,d)) is equivalent to '(a b ^(c ,d)).  Although there is an unquote ,d it
belongs to the inner quasiquote ^(c ,d), and the outer quasiquote does not have
any unquotes of its own, making it equivalent to a quote.

Dialect note: in Common Lisp and Scheme, ^form is written `form, and
quasiquotes are also informally known as backquotes.  In TXR, the backquote is
used for quasi string literals already.  Moreover, the caret is more visually
distinct from the backquote, making it somewhat easier to tell apart generated
code from its surroundings.

.IP ,<expr>

The comma character is used within a <qq-template> to denote an unquote.  Whereas
the quote suppresses evaluation, the comma introduces an exception: an element
of a form which is evaluated. For example, list ^(a b c ,(+ 2 2)
(+ 2 2)) is the list (a b c 4 (+ 2 2)).  Everything
in the quasiquote stands for itself, except for the ,(+ 2 2) which is evaluated.

Note: if a variable is called *x*, then the syntax ,*x* means ,* x*: splice
the value of x*. In this situation, whitespace between the comma and the
variable name should be used: , *x*.

.IP ,*<expr>

The comma-star operator is used within quasiquote list to denote a splicing unquote.
The form which follows ,* must evaluate to a list. That list is spliced into
the structure which the quasiquote denotes. For example: '(a b c ,*(list
(+ 3 3) (+ 4 4) d)) evaluates to (a b c 6 8 d).  The expression (list (+ 3 3)
(+ 4 4)) is evaluated to produce the list (6 8), and this list is spliced into
the quoted template.

Dialect note: in other Lisp dialects, the equivalent syntax is usually ,@
(comma at). The @ character already has an assigned meaning, so * is used.

.SS Quasiquoting non-List Objects

Quasiquoting is supported over hash table and vector literals (see Vectors
and Hashes below).  A hash table or vector literal can be quoted, like any
object, for instance:

  '#(1 2 3)

The #(1 2 3) literal is turned into a vector atom right in the TXR parser,
and this atom is being quoted: this is (quote <atom>) syntactically,
which evaluates to <atom>.

When a vector is quasi-quoted, this is a case of ^<atom>, which
evaluates to <atom>.

  ^#(1 2 3)

If unquotes occur in the quasi-quoted vector, it is a quasivector.

  (let ((a 42))
    ^#(1 ,a 3)) ; value is #(1 42 3)

In this situation, the ^#(...) notation produces code which constructs
a vector.

The vector in the following example is also a quasivector. It contains
unquotes, and is though the quote is not directly applied to it,
it is surrounded in a quote.

  (let ((a 42))
    ^(a b c #(d ,a))) ; value is (a b c #(d 42))

Hash table literals have two parts: the list of hash construction
arguments and the key-value pairs. For instance:

   #H((:equal-based) (a 1) (b 2))

where (:equal-based) is the list of arguments and the pairs are (a 1) and (b
2). Hash literals may be quasiquoted.  In quasiquoting, the arguments and pairs
are treated as separate syntax; it is not one big list.  So the following is
not a possible way to express the above hash:

  ;; not supported: splicing across the entire syntax
  (let ((hash-syntax '((:equal-based) (a 1) (b 2))))
    ^#H(,*hash-syntax))

This is correct:

  ;; fine: splicing hash arguments and contents separately
  (let ((hash-args '(:equal-based))
        (hash-contents '((a 1) (b 2))))
    ^#H(,hash-args ,*hash-contents))

.SS Quasiquoting combined with Quasiliterals

When a quasiliteral is embedded in a quasiquote, it is possible to use
splicing to insert material into the quasiliteral.

.TP
Example:

  (eval (let ((a 3)) ^`abc @,a @{,a} @{(list 1 2 ,a)}`))

  -> "abc 3 3 1 2 3"

.SS Vectors

.IP "#(...)"

A hash token followed by a list denotes a vector. For example #(1 2 a)
is a three-element vector containing the numbers 1 and 2, and the symbol a.

.SS Hashes

.IP "#H((<hash-argument>*) (<key> <value>)*)"

The notation #H followed by a nested list syntax denotes a hash table literal.
The first item in the syntax is a list of keywords. These are the same
keywords as are used when calling the function hash to construct
a hash table. Allowed keywords are: :equal-based, :weak-keys, :weak-values.
An empty list can be specified as nil or (), which defaults to a
hash table based on the eq function, with no weak semantics.

.SS The .. notation

In TXR Lisp, there is a special "dotdot" notation consisting of a pair of dots.
This can be written between successive atoms or compound expressions, and is a
shorthand for cons.

That is to say, A .. B translates to (cons A B), and so for instance
(a b .. (c d) e .. f . g) means (a (cons b (c d)) (cons e f) . g).

This is a syntactic sugar useful in certain situations in which a cons is used
to represent a pair of numbers or other objects. For instance, if L
is a list, then [L 1 .. 3] computes a sublist of L consisting of
elements 1 through 2 (counting from zero).

.TP
Restrictions: 

The notation must be enclosed in a list. For instance a..b is not an
expression, but (a..b) is. This is important if Lisp data is being parsed from
a string or stream using the read function. If the data "a..b"  is
parsed, the symbol "a" will be extracted, leaving "..a", which, if parsed,
produces a syntax error since it consists of a "dotdot" token followed by
a symbol, which is not valid syntax, akin to something like ")a" or ".a".

The notation cannot occur in the dot position; that is, the syntax (a . b .. c)
is invalid. The dotdot operator can only be used between the non-dot-position
elements of a list.

.SS The DWIM Brackets

TXR Lisp has a square bracket notation. The syntax [...] is a shorthand
way of writing (dwim ...).  The [] syntax is useful for situations
where the expressive style of a Lisp-1 dialect is useful.

For instance if foo is a variable which holds a function object, then [foo 3]
can be used to call it, instead of (call foo 3).  If foo is a vector, then
[foo 3] retrieves the fourth element, like (vecref foo 3). Indexing over lists,
strings and hash tables is possible, and the notation is assignable.

Furthermore, any arguments enclosed in [] which are symbols are treated
according to a modified namespace lookup rule.

More details are given in the documentation for the dwim operator.

.SS Compound Forms

In TXR Lisp, there are two types of compound forms: the Lisp-2 style
compound forms, denoted by ordinary lists that are expressed with parentheses.
There are Lisp-1 style compound forms denoted by the DWIM Brackets, discussed
in the previous section.

The first position of an ordinary Lisp-2 style compound form, is expected to
have a function or operator name.  Then arguments follow. Finally, there may
also be an expression in the dotted position, if the form is a function call.

If the form is a function call then the arguments are evaluated. If any of the
arguments are symbols, they are treated according to Lisp-2 namespacing rules.

Additionally, if there is an expression in the dotted position, it is also
evaluated. It should evaluate to a sequence: a list, vector or string.  The
elements of the sequence generate additional arguments for the function
call. Note, however, that a compound form cannot be used in the dot position,
for obvious reasons, namely that (a b c . (foo z)) does not mean that there is
a compound form in the dot position, but a different spelling for
(a b c foo z), where foo behaves as a variable.

The DWIM brackets are similar, except that the first position is an arbitrary
expression which is evaluated according to the same rules as the remaining
positions. The first expression must evaluate to a function, or else to some
other object for which the DWIM syntax is defined, such as a vector, string,
list or hash. Operators are not supported.   The dotted syntax for application
of additional arguments from a list or vector is supported in the DWIM
brackets just like in the parentheses.

.TP
Examples:

  ;; a contains 3
  ;; b contains 4
  ;; c contains #(5 6 7)
  ;; s contains "xyz"

  (foo a b . c) ;; calls (foo 3 4 5 6 7)
  (foo a)       ;; calls (foo 3)
  (foo . s)     ;; calls (foo #\ex #\ey #\ez)

  [foo a b . c] ;; calls (foo 3 4 5 6 7)

  [c 1]         ;; indexes into vector #(5 6 7) to yield 6

.TP
Dialect Note:

In some other Lisp dialects, the improper list syntax is not supported;
a function called apply (or similar) must be used for application even if
the expression which gives the trailing arguments is a symbol. Moreover,
applying sequences other than lists is not supported.

.SS Regular Expressions

In TXR Lisp, the / character can occur in symbol names, and the / token
is a symbol. Therefore the /regex/ syntax is absent, replaced with the
#/regex/ syntax.

.SS Generalization of List Accessors car and cdr

In ancient Lisp in the 1960's, it was not possible to apply the operations
car and cdr to the nil symbol (empty list), because it is not a cons cell. In
the InterLisp dialect, this restriction was lifted: these operations were
extended to accept nil (and return nil). The convention was adopted in
other Lisp dialects such as MacLisp and eventually in Common Lisp. Thus there
exists an object which is not a cons, yet which takes car and cdr.

In TXR Lisp, this relaxation is extended further. For the sake of convenience,
the operations car and cdr, are extended to work with strings and vectors:

  (cdr "") -> nil
  (car "") -> nil

  (car "abc") -> #\ea
  (cdr "abc") -> "bc"

  (cdr #(1 2 3)) -> #(2 3)
  (car #(1 2 3)) -> 1

The ldiff function is also extended in a special way. When the right parameter
is a string or vector, then it uses the equal equality test rather than eq
for detecting the tail of the list.

  (ldiff "abcd" "cd") -> (#\ea #\eb)

The ldiff operation starts with "abcd" and repeatedly applies cdr to produce
"bcd" and "cd", until the suffix is equal to the second argument: (equal "cd"
"cd") yields true.

Operations based on car, cdr and ldiff, such as keep-if and remq extend to
strings and vectors.

Derived list processing operations such as remq or mapcar obey the following
rule: the returned object follows the type of the leftmost input list object.
For instance, if one or more sequences are processed by mapcar, and the
leftmost one is a character string, the function is expected to return
characters, which are converted to a character string. However, in the
event that the objects produced cannot be assembled into that type of
sequence, a list is returned instead.

For example [mapcar list "ab" "12"] returns ((#\ea #\eb) (#\e1 #\e2)),
because a string cannot hold lists of characters. However
[mappend list "ab" "12"] returns "a1b2".

The lazy versions of these functions such as mapcar* do not have this behavior;
they produce lazy lists.

.SS Callable Objects

In TXR Lisp, sequences (strings, vectors and lists) and hashes can be used
as functions everywhere, not just with the DWIM brackets. Sequences work
as one or two-argument functions. With a single argument, an element is
selected by position and returned. With two arguments, a range is extracted and
returned. Hashes also work as one or two argument functions, corresponding
to the arguments of the gethash function.

Moreover, when a sequence is used as a function of one argument, and the
argument is a cons cell rather than an integer, then the call becomes a
two-argument call in which the car and cdr of the cell are passed as separate
arguments. This allows for syntax like (call "abc" 0..1).

.TP
Example 1:

  (mapcar "abc" '(2 0 1)) -> (#\ec #\ea #\eb)

Here, mapcar treats the string "abc" as a function of one argument (since there
is one list argument). This function maps the indices 0, 1 and 2 to the
corresponding characters of string "abc". Through this function, the list of 
integer indices (2 0 1) is taken to the list of characters (#\ec #\ea #\eb).

.TP
Example 2:

  (call '(1 2 3 4) 1..3) -> (2 3)

Here, the shorthand 1 .. 3 denotes (cons 1 3). A cons cell as an argument
to a sequence performs range extraction: taking a slice starting at
index 1, up to and not including index 3, as if by the call
(sub '(1 2 3 4) 1 3).

.TP
Example 3:

  (call '(1 2 3 4) '(0 2)) -> (1 2)

A list of indices applied to a sequence is equivalent to using the
select function, as if (select '(1 2 3 4) '(0 2)) were called.

.SS Special Variables

Similarly to Common Lisp, TXR Lisp is lexically scoped by default, but
also has dynamically scoped (a.k.a "special") variables.

When a variable is defined with defvar, it is introduced as a global
(global) binding, regardless of where in the scope the defvar form occurs.

Furthermore, at the time the defvar form is evaluated, the symbol which
names the variable is tagged as special.

When a symbol is tagged as special, it behaves differently when it is used
in a lexical binding construct like let, and all other such constructs
such as function parameter lists. Such a binding is not the usual lexical
binding, but a "rebinding" of the global variable. Over the dynamic scope
of the form, the global variable takes on the value given to it by the
rebinding. When the form terminates, the prior value of the variable
is restored. (This is true no matter how the form terminates; even if by
an exception.)

Because of this "pervasive special" behavior of a symbol that has been
used as the name of a global variable, a good practice is to make global
variables have visually distinct names via the "earmuffs" convention:
beginning and ending the name with an asterisk.

Certain variables in TXR's library break this convention; however, they at
least have distinct prefixes, examples being example s-ifmt, log-emerg and
sig-hup.

.TP
Example:

  (defvar *x* 42)     ;; *x* has a value of 42

  (defun print-x ()
    (format t "~a\en" *x*))

  (let ((*x* "abc"))  ;; this overrides *x*
    (print-x))        ;; *x* is now "abc" and so that is printed

  (print-x)           ;; *x* is 42 again and so "42" is printed



.SH OPERATOR AND FUNCTION LIBRARY

A compound expression with a symbol as its first element, if
intended to be evaluated, denotes either an operator invocation or a function
call. This depends on whether the symbol names an operator or a function.

When the form is an operator invocation, the interpretation of the meaning of
that form is under the complete control of that operator. 

Functions calls do not control the evaluation of the function call forms which
invoke them; function call forms are evaluated according to very regular rules
that apply to all function calls.

Some operators are macros. There exist predefined macros in the library, and
macro operators can also be user-defined using the macro-defining operator
defmacro.  Operators that are not macros are called special operators. 

Macro operators work as functions which are given the source code of the form.
They analyze the form, and translate it to another form which is substituted in
their place.   This happens during a code walking phase called the expansion
phase, which is applied to Lisp code prior to evaluation. All macros are
expanded in the expansion phase, resulting in code which contains only
function calls and the executable forms of the operators.

(Special operators can also perform code transformations during the expansion
phase, but that is not considered macroexpansion, but rather an adjustment
of the representation of the operator into an required executable form.)

The following sections list all of the special operators, macros
and functions in TXR Lisp.

In these sections Syntax is indicated using these conventions:

.TP
<word> 

A symbol in angle brackets denotes some syntactic unit: it
may be a symbol or compound form. The syntactic unit is explained
in the Description section.

.TP
{syntax}*  <word>*

This indicates a repetition of zero or more of the given
syntax enclosed in the braces or syntactic unit.

.TP
{syntax}+  <word>+

This indicates a repetition of one or more of the given
syntax enclosed in the braces or syntactic unit.

.TP
[syntax]  [<word>]

Square brackets indicate optional syntax.

.TP
alternative1 | alternative2 | ... | alternativeN

Multiple syntactic variations allowed in one place are
indicated as bar-separated items.

.SH CONTROL FLOW AND SEQUENCING

.SS Operators progn and prog1

.TP
Syntax:

  (progn <form>*)
  (prog1 <form>*)

.TP
Description

The progn operator evaluates forms in order, and returns the value
of the last form. The return value of (progn) is nil.

The prog1 operator evaluates forms in order, and returns the value
of the first form. The return value of (prog1) is nil.

Various other operators such as let also arrange for the evaluation
of a body of forms, the value of the last of which is returned.
These operators are said to feature an "implicit progn".

.SS Operator cond

.TP
Syntax:

  (cond {(<test> {form}*)}*)

.TP
Description:

The cond operator provides a multi-branching conditional evaluation of
forms. Enclosed in the cond form are groups of forms expressed as lists.
Each group must be a list of at least one form.

The forms are processed from left to right as follows: the first form,
<test>, in each group is evaluated. If it evaluates true, then the remaining
forms in that group, if any, are also evaluated. Processing then terminates and
the result of the last form in the group is taken as the result of cond.
If <test> is the only form in the group, then result of <test> is taken
as the result of cond.

If the first form of a group yields nil, then processing continues with the
next group, if any. If all form groups yield nil, then the cond form yields
nil.  This holds in the case that the syntax is empty: (cond) yields nil.

.SS Macros caseq, caseql and casequal

.TP
Syntax:

  (caseq <test-form> <normal-clause>* [<else-clause>])
  (caseql <test-form> <normal-clause>* [<else-clause>])
  (caseqqual <test-form> <normal-clause>* [<else-clause>])

.TP
Description:

These three macros arrange for the evaluation of of <test-form>, whose value
is then compared against the key or keys in each <normal-clause> in turn.
When the value matches a key, then the remaining forms of <normal-clause>
are evaluated, and the value of the last form is returned; subsequent
clauses are not evaluated. When the value doesn't match any of the keys
of a <normal-clause> then the next <normal-clause> is tested.
If all these clauses are exhausted, and there is no <else-clause>,
then the value nil is returned. Otherwise, the forms in the <else-clause>
are evaluated, and the value of the last one is returned.

The syntax of a <normal-clause> takes on these two forms:

  (<key> <form>*)

where <key> may be an atom which denotes a single key, or else a list
of keys.  There is a restriction that the symbol t may not be used
as <key>. The form (t) may be used as a key to match that symbol.

The syntax of an <else-clause> is:

  (t <form>*)

which resembles a form that is often used as the final clause
in the cond syntax.

The three forms of the case construct differ from what type of
test they apply between the value of <test-form> and the keys.
The caseq macro generates code which uses the eq function's
equality. The caseql macro uses eql, and casequal uses equal.

.TP
Example:

  (let ((command-symbol (casequal command-string
                          (("q" "quit") 'quit)
                          (("a" "add") 'add)
                          (("d" "del" "delete") 'delete)
                          (t 'unknown))))
    ...)

.SS Macros when and unless

.TP
Syntax:

  (when <expression> <form>*)
  (unless <expression> <form>*)

.TP
Description:

The when macro operator evaluates <expression>. If <expression> yields
true, and there are additional forms, then each <form> is evaluated.
The value of the last form is becomes the result value of the when form.
If there are no forms, then the result is nil.

The unless operator is similar to when, except that it reverses the
logic of the test. The forms, if any, are evaluated if, and only if
<expression> is false.

.SS Macros while and until

.TP
Syntax:

  (while <expression> <form>*)
  (until <expression> <form>*)

.TP
Description:

The while macro operator provides a looping construct.  It evaluates
<expression>. If <expression> yields nil, then the evaluation of the while form
terminates, producing the value nil.  Otherwise, if there are additional forms,
then each <form> is evaluated.  Next, evaluation returns to <expression>,
repeating all of the previous steps.

The until macro operator is similar to while, except that the until form
terminates when <expression> evaluates true, rather than false.

These operators arrange for the evaluation of all their enclosed forms
in an anonymous block. Any of the <form>-s, or <expression>, may use
the return operator to terminate the loop, and optionally to specify
a result value for the form.

The only way these forms can yield a value other than nil is if
the return operator is used to terminate the implicit anonymous block,
and is given an argument, which becomes the result value.

.SS Operator/function if

.TP
Syntax:

  (if <cond> <t-form> [<e-form>])
  [if <cond> <then> [<else>]]

.TP
Description:

There exist both an if operator and an if function. A list form with the symbol
if in the fist position is interpreted as an invocation of the if operator.
The function can be accessed using the DWIM bracket notation and in other
ways.

The if operator provides a simple two-way-selective evaluation control.
The <cond> form is evaluated. If it yields true then <t-form> is
evaluated, and that form's return value becomes the return value of the if.
If <cond> yields false, then <e-form> is evaluated and its return value
is taken to be that of if. If <e-form> is omitted, then the behavior is
as if <e-form> were specified as nil.

The if function provides no evaluation control. All of arguments
are evaluated from left to right. If the <cond> argument is true, then it
returns the <then> argument, otherwise it returns the value of the
<else> argument, if present, otherwise it returns nil.

.SS Operator/function and 

.TP
Syntax:

  (and {<form>}*)
  [and {<arg>]*)

.TP
Description:

There exist both an and operator and an and function. A list form with the
symbol and in the fist position is interpreted as an invocation of the 
operator.  The function can be accessed using the DWIM bracket notation and in
other ways.

The and operator provides three functionalities in one.  It computes the
logical "and" function over several forms.  It controls evaluation (a.k.a.
"short-circuiting").  It also allows the convenient substitution of an
arbitrary true value in the true case.

The and operator evaluates as follows. First, a return value is
established and initialized to the value t.  The forms, if any, are
evaluated from left to right.  The return value is overwritten with
the result of each form. Evaluation stops when all forms are exhausted,
or when any of them yields nil. When evaluation stops, the operator yields
the return value.

The and function provides no evaluation control; it receives all of its
arguments fully evaluated. If it is given no arguments, it returns t.
If it is given one or more arguments, and any of them are nil, it returns
nil. Otherwise it returns the value of the last argument.

.TP
Examples:

  (and) -> t
  (and (> 10 5) (stringp "foo")) -> t
  (and 1 2 3) -> 3

.SS Operator/function or

.TP
Syntax:

  (or {<form>}*)
  [or {<arg>}*]

.TP
Description:

There exist both an or operator and an or function. A list form with the
symbol or in the fist position is interpreted as an invocation of the 
operator.  The function can be accessed using the DWIM bracket notation and in
other ways.

The or operator provides three functionalities in one.  It computes the
logical "or" function over several forms.  It controls evaluation (a.k.a.
"short-circuiting").  The behavior of or also provides for a simplified
selection of the first non-nil value from a sequence of forms.

The or operator evaluates as follows.  First, a return value is
established and initialized to the value nil. The forms, if any,
are evaluated from left to right. The return value is overwritten
with the result of each form. Evaluation stops when all forms are
exhausted, or when a form yields a true value. When evaluation stops, the
operator yields the return value.

The and function provides no evaluation control; it receives all of its
arguments fully evaluated. If it is given no arguments, it returns nil.
If all of its arguments are nil, it also returns nil. Otherwise, it
returns the value of the first non-nil argument.

.TP
Examples:

  (or) -> nil
  (or 1 2) -> 1
  (or nil 2) -> 2
  (or (> 10 20) (stringp "foo")) -> t

.SS Operator unwind-protect

.TP
Syntax:

  (unwind-protect <protected-form> <cleanup-form>*)

.TP
Description:

The unwind-protect operator evaluates <protected-form> in such a way that no
matter how the execution of <protected-form> terminates, the <cleanup-form>-s
will be executed.

The cleanup forms, however, are not protected. If a cleanup form terminates via
some non-local jump, the subsequent cleanup forms are not evaluated.

Cleanup forms themselves can "hijack" a non-local control transfer such
as an exception. If a cleanup form is evaluated during the processing of
a dynamic control transfer such as an exception, and that cleanup form
initiates its own dynamic control transfer, the original control transfer
is aborted and replaced with the new one.

.TP
Example:

    (block foo
      (unwind-protect
        (progn (return-from foo 42)
               (format t "not reached!\en"))
        (format t "cleanup!\en")))

In this example, the protected progn form terminates by returning from
block foo. Therefore the form does not complete and so the
output "not reached!" is not produced. However, the cleanup form
executes, producing the output "cleanup!".

.SS Operator block

.TP
Syntax:

  (block <name> <body-form>*)

.TP
Description:

The block operator introduces a named block around the execution of
some forms. The <name> argument must be a symbol. Since a block name is not
a variable binding, keyword symbols are permitted, and so are the symbols
t and nil.   A block named by the symbol nil is slightly special: it is
understood to be an anonymous block.

Blocks in TXR Lisp have dynamic scope. This means that the following
situation is allowed:

  (defun func () (return-from foo 42))
  (block foo (func))

The function can return from the foo block even though the foo block
does not lexically surround foo.

Thus blocks in TXR Lisp provide dynamic non-local returns, as well
as returns out of lexical nesting.

.TP
Dialect Note:

In Common Lisp, blocks are lexical. A separate mechanism consisting of
catch and throw operators performs non-local transfer based on symbols.
The TXR Lisp example:

  (defun func () (return-from foo 42))
  (block foo (func))

is not allowed in Common Lisp, but can be transliterated to:

  (defun func () (throw 'foo 42))
  (catch 'foo (func))

Note that foo is quoted in CL. This underscores the dynamic nature of
the construct. THROW itself is a function and not an operator.

.SS Operators return, return-from

.TP
Syntax:

  (return [<value>])
  (return-from <name> [<value>])

.TP
Description:

The return operator must be dynamically enclosed within an anonymous
block (a block named by the symbol nil). It immediately terminates the
evaluation of the innermost anonymous block which encloses it, causing
it to return the specified value. If the value is omitted, the anonymous
block returns nil.

The return-from operator must be dynamically enclosed within a named block
whose name matches the <name> argument. It immediately terminates the
evaluation of the innermost such block, causing it to return the specified
value. If the value is omitted, that block returns nil.

.TP
Example:

    (block foo
      (let ((a "abc\en")
            (b "def\en"))
        (pprint a *stdout*)
        (return-from foo 42)
        (pprint b *stdout*)))

Here, the output produced is "abc". The value of b is not printed
because the return-from terminates block foo, and so the second pprint
form is not evaluated.

.SH EVALUATION

.SS Operator dwim

.TP
Syntax:

  (dwim <argument>*)

  [<argument>*]

.TP
Description:

The dwim operator's name is an acronym: DWIM may be taken to mean
"Do What I Mean", or alternatively, "Dispatch, in a Way that is
Intelligent and Meaningful".

The notation [...] is a shorthand equivalent to (dwim ...) and is the preferred
way for writing dwim expressions.

The dwim operator takes a variable number of arguments, which are
all evaluated in the same way: the first argument is not evaluated differently
from the remaining arguments.

This means that the first argument isn't a function name, but an ordinary
expression which can simply compute a function object (or, more generally,
a callable object).

Furthermore, for those arguments of dwim which are symbols (after all
macro-expansion is performed on the arguments), the evaluation rules are
altered. For the purposes of resolving symbols to values, the function and
variable binding namespaces are considered to be merged into a single space,
creating a situation that is very similar to a Lisp-1 style dialect.

This special Lisp-1 evaluation is not recursively applied.  All arguments of
dwim which, after macro expansion, are not symbols are evaluated using the
normal Lisp-2 evaluation rules. Thus, the DWIM operator must be used
in every expression where the Lisp-1 rules for reducing symbols to
values are desired.

After macro expansion, the first argument of dwim may not be an operator such
as let, or the name of a macro. Prior to macroexpansion, any argument of dwim
may be a symbol macro.

If a symbol has bindings both in the variable and function namespace in scope,
and is referenced by a dwim argument, this constitutes a conflict which is
resolved according to two rules.  When nested scopes are concerned, then an
inner binding shadows an outer binding, regardless of their kind.  An inner
variable binding for a symbol X shadows an outer or global function binding,
and vice versa.

If a symbol is bound to both a function and variable in the global namespace,
then the variable binding is favored.

Macros do not participate in the special scope conflation. This is apparent
in two ways. Firstly, the space of symbol macros is not folded together with
the space of regular macros. An argument of dwim that is a symbol might be
symbol macro, variable or function, but it cannot be interpreted as the name of
a regular macro. Secondly, function bindings cannot shadow symbol macros. If a
function is defined in an inner scope relative to a symbol macro for the
same symbol, that symbol macro still hides the function when it appears in
a dwim form. Symbol macros are expanded without any consideration for the
dwim operator, which is not treated specially by the expansion phase.
(Interaction between dwim and macros may become more sophisticated in the
future.)

How many arguments are required by the dwim operator depends on the type of
object to which the first argument expression evaluates.  The possibilities
are:

.IP "[<function> <argument>*]"
Call the given the function object to the given arguments.

.IP "[<symbol> <argument>*]"
If the first expression evaluates to a symbol, that symbol
is resolved in the function namespace, and then
the resulting function, if found, is called with the
given arguments.

.IP "[<sequence> <index>]"
Retrieve an element from <sequence>, given by the integer <index>, given by the
integer <index>.

The following equivalences hold:

  [seq index] <--> (ref seq index)

  (set [seq index] new) <--> (refset seq index new)

This form accepts update operators like inc and flip.

.IP "[<sequence> <from-index>..<to-below-index>]"
Retrieve the specified range of elements.
The range of elements is specified in the car and cdr fields of a cons cell,
for which the .. (dotdot) syntactic sugar is useful.
See the section on Range Indexing below.

The following equivalences hold:

  [seq from..to] <--> (sub seq from to)

  (set [seq from..to] new) <--> (refset seq new from to)

This form does not accept update operators like inc and flip.

.IP [<sequence> <index-list>]
Elements specified
by <index-list> are extracted from <sequence> and returned as a sequence
of the same kind as <sequence>. Equivalent to (select <sequence>
<where-index>), except when the target of an assignment operation.

The following equivalences hold:

  [seq list] <--> (select seq list)

  (set [seq list] new) <--> (refset seq new list)

This form does not accept update operators like inc and flip.

Note that unlike the select function, this does not support [<hash>
<index-list>], because since hash keys may be lists, that syntax is
indistinguishable from a simple hash lookup where <index-list> is the key.

.IP "[<hash> <key> <default-value>]"
Retrieve a value from the hash table corresponding to <key>,
or <default-value> if there is no such entry.

The first argument may not be an operator such as let, only a function.

The places denoted by the dwim operator can be assigned.  There are some
restrictions. List, string and vector ranges can only be replaced using
the set operator. The other operators like push do not apply.  
Characters in a string can only be assigned with set or incremented with inc
and dec.

The source of a range assignment can be a string, vector or list,
regardless of whether the target is a string, vector or list.
If the target is a string, the replacement sequence must be
a string, or a list or vector of characters.

.TP
Range Indexing

Vector and list range indexing is based from zero. The first element element
zero. Furthermore, the value -1 refers to the last element of the vector or
list, and -2 to the second last and so forth. So the range 1 .. -2 means
"everything except for the first element and the last two".

The symbol t represents the position one past the end of the vector, string or
list, so 0 .. t denotes the entire list or vector, and the range t .. t
represents the empty range just beyond the last element.
It is possible to assign to t .. t. For instance:

  (defvar list '(1 2 3))
  (set [list t .. t] '(4)) ;; list is now (1 2 3 4)

The value zero has a "floating" behavior when used as the end of a range.
If the start of the range is a negative value, and the end of the
range is zero, the zero is interpreted as being the position past the
end of the sequence, rather than the first element. For instance the range
-1..0 means the same thing as -1..t. Zero at the start of a range
always means the first element, so that 0..-1 refers to all the elements except
for the last one.

.TP
Notes:

The dwim operator allows for a Lisp-1 flavor of programming in TXR Lisp,
which is normally Lisp-2, with some useful extensions.

A Lisp-1 dialect is one in which an expression like (a b) treats both a and b
as expressions with the same evaluation rules. The symbols a and b are looked
up in a variable namespace. A function call occurs if the value of variable
a is a function object.  Thus in a Lisp-1, named functions do not exist as
such: they are just variable bindings.  In a Lisp-1 (car 1 2) means that there
is a variable called car, which holds a function. In a Lisp-2 (car 1 2) means
that there is a function called car, and so (car car car) is possible, because
there can be also a variable called car.

The Lisp-1 design has certain disadvantages, which are avoided in TXR Lisp by
confining the Lisp-1 expressivity inside the [...] notation, in which operators
are not allowed.  When round parentheses are used, the normal Lisp-2 rules
apply. A "best of both worlds" situation is achieved. The square brackets
are just as convenient as parentheses and at the same time visually distinct,
making it clear that different rules apply.

The Lisp-1 is useful for functional programming, because it eliminates
occurrences of the call and fun operators.  For instance:

  ;; regular notation

  (call foo (fun second) '((1 a) (2 b)))

  ;; [] notation

  [foo second '((1 a) (2 b))]

Lisp-1 dialects can also provide useful extensions by giving a meaning
to objects other than functions in the first position of a form,
and the dwim/[...] syntax does exactly this.
However, unlike Lisp-1 dialects, the [] syntax does not allow operators.
It
.B is
an operator: (dwim ...).


.SS Function identity

.TP
Syntax:

  (identity <value>)

.TP
Description:

The identity function returns its argument. 

.TP
Notes:

The identify function is useful as a functional argument, when a transformation
function is required, but no transformation is actually desired.

.SS Function eval

.TP
Syntax:

  (eval <form> <env>)

.TP
Description:

The eval function treats the <form> object as a Lisp expression, which is
evaluated. The side effects implied by the form are performed, and the value
which it produces is returned. The <env> object specifies an environment for
resolving the function and variable references encountered in the expression.
The object nil can be specified as an environment, in which case the evaluation
takes place in the global environment.

See also: the make-env function.

.SS Function make-env

.TP
Syntax:

  (make-env [<variable-bindings> [<function-bindings> [<next-env>]]])

.TP
Description:

The make-env function creates an environment object suitable as the <env> parameter.

The <variable-bindings> and <function-bindings> parameters, if specified,
should be association lists, mapping symbols to objects.  The objects in
<function-bindings> should be functions, or objects callable as functions.

The <next-env> argument, if specified, should be an environment. 

Note: bindings can also be added to an environment using the env-vbind
and env-fbind functions.

.SS Functions env-vbind and env-fbind

.TP
Syntax:

  (env-vbind <env> <symbol> <value>)
  (env-fbind <env> <symbol> <value>)

.TP
Description:

These functions bind a symbol to a value in either the function or variable space
of environment <env>.

Values established in the function space should be functions or objects that
can be used as functions such as lists, strings, arrays or hashes.

If <symbol> already exists in the environment, in the given space, then its
value is updated with <value>.

.SH MUTATION

.SS Operators inc, dec, set, push, pop, flip and del

.TP
Syntax:

  (inc <place> [<delta>])
  (dec <place> [<delta>])
  (set <place> <new-value>)
  (push <item> <place>)
  (pop <place>)
  (flip <place>)
  (del <place>)

.TP
Description:

These destructive operators update the value of a place. A place is a storage
location which is denoted by a form. Place forms are identical to value
accessing forms. That is to say, any form recognized as a place by these
operators can be evaluated by itself to retrieve the value of the storage
location. However, the converse is false: not all forms which access storage
location are recognized as places.

With are exceptions noted below, it is an error if a place does not exist.
For instance, a variable being assigned must exist.

Literal objects which are directly specified in the source code are
considered part of the program body. Modifying parts of these objects
therefore gives rise to self-modifying code. The behavior of self-modifying
code is not specified.

The inc and dec update the place by adding or subtracting, respectively, a
displacement to or from that number. If the <delta> expression is
specified, then it is evaluated and its value is used as the increment.
Otherwise, a default increment of 1 is used. The prior value of the place
and the delta must be suitable operands for the + and - functions.
(inc x) is equivalent to (set x (+ 1 x)), except that expression x
is evaluated only once to determine the storage location. The inc
and dec operators return the new value that was stored.

The set operator overwrites the previous value of a place with a new value,
and also returns that value.

The push and pop operators operate on a place which holds a list.  The push
operator updates the list by replacing it with a new list which has a new item
at the front, followed by the previous list. The item is returned.
The pop operator performs the reverse operation: it removes the first item
from the list and returns it. (push y x) is similar to

  (let ((temp y)) (set x (cons temp x)) temp)

except that x is evaluated only once to determine the storage place, and no
such temporary variable is visible to the program.  Similarly, (pop x) is much
like

  (let ((temp (car x))) (set x (cdr x)) temp)
 
except that x is evaluated only once, and no such temporary variable
is visible to the program.

The flip operator toggles a place between true and false. If the place
contains a value other than nil, then its value is replaced with nil.
If it contains nil, it is replaced with t.

The del operator does not modify the value of a place, but rather deletes the
place itself. Index values and ranges of lists denoted using the dwim operator
indexing notation can be subject to a deletion, as can hash table entries
denoted using dwim or gethash. It is an error to try to delete other kinds of
places such as simple variables. The del operator returns the value of the
place that was deleted. Deleting from a sequence means removing the element or
elements. Deleting a hash place means removing the corresponding entry from the
hash table.

Currently, these forms are recognized as places:

  <symbol>

  (car <cons>)

  (cdr <cons>)

  (gethash <hash> <key> <default-value>)

  (vecref <vector> <index>)

  (dwim <obj> ...)
  
  [<obj> ...]  ;; equivalent to (dwim <obj> ...)


A <symbol> place denotes a variable. If the variable does not exist, it is an
error. 

The (car <form>) and (cdr <form>) places denote the corresponding slots
of a cons cell. The <cons> form must be an expression which evaluates to a
cons. 

The gethash place denotes a value stored in a hash table.
The form <hash> must evaluate to a hash table. If the place does not exist
in the hash table under the given key, then the destructive operation
will create it. In that case, the <default-value> form is evaluated to
determine the initial value of the place. Otherwise it is ignored.

The vecref place denotes a vector element, allowing vector elements
to be treated as assignment places.

The dwim/[] place denotes a vector element, list element, string, or hash
table, depending on the type of obj. 

.SH BINDING AND ITERATION

.SS Operator defvar

.TP
Syntax:

  (defvar <sym> <value>)

.TP
Description:

The defvar operator binds a variable in the global environment. 

If the variable named <sym> already exists in the global environment, the
form has no effect; the <value> form is not evaluated, and the value of the
variable is unchanged.

If the variable does not exist, then it is introduced, with a value given by
evaluating the <value> form. The <value> form is evaluated in the environment
in which the defvar form occurs, not necessarily in the global environment.

The symbols t and nil may not be used as variables, and neither
can be keyword symbols: symbols denoted by a leading colon.

In addition to creating a binding, the defvar operator also marks <sym>
as the name of a special variable. This changes what it means to bind
that symbol in a lexical binding construct such as the let operator,
or a function parameter list. See the section "Special Variables" far above.

.SS Operators let and let*

.TP
Syntax:

  (let ({<sym> | (<sym> <init-form>)}*) <body-form>*)
  (let* ({<sym> | (<sym> <init-form>)}*) <body-form>*)

.TP
Description:

The let and let* operators introduce a new scope with variables and
evaluate forms in that scope. The operator symbol, either let or let*,
is followed by a list which can contain any mixture of variable
name symbols, or (<sym> <init-form>) pairs.  A symbol
denotes the name of variable to be instantiated and initialized
to the value nil.  A symbol specified with an init-form denotes
a variable which is initialized from the value of the init-form.

The symbols t and nil may not be used as variables, and neither
can be keyword symbols: symbols denoted by a leading colon.

The difference between let and let* is that in let*, later init-forms
have visibility over the variables established by earlier variables
in the same let* construct. In plain let, the variables are not
visible to any of the init-forms.

When the variables are established, then the body forms
are evaluated in order. The value of the last form becomes the
return value of the let. 

If the forms are omitted, then the return value nil is produced.

The variable list may be empty.


.TP
Examples:

  (let ((a 1) (b 2)) (list a b)) -> (1 2)
  (let* ((a 1) (b (+ a 1))) (list a b (+ a b))) -> (1 2 3)
  (let ()) -> nil
  (let (:a nil)) -> error, :a and nil can't be used as variables

.SS Operators for and for*

.TP
Syntax:

  ({for | for*} ({<sym> | (<sym> <init-form>)}*) 
                ([<test-form> <result-form>*]) 
                (<inc-form>*)
    <body-form>*)

.TP
Description:

The for and for* operators combine variable binding with loop iteration.
The first argument is a list of variables with optional initializers,
exactly the same as in the let and let* operators. Furthermore, the
difference between for and for* is like that between let and let* with
regard to this list of variables. 

The for operators execute these steps:

1. Establish bindings for the specified variables similarly to let
and let*. The variable bindings are visible over the <test-form>, each
<result-form>, each <inc-form> and each <body-form>.

2. Establish an anonymous block over the remaining forms, allowing
the return operator to be used to terminate the loop.

3. Evaluate <test-form>. If <test-form> yields nil, then the loop
terminates. Each <result-form> is evaluated, and the value of the last of these
forms is is the result value of the for loop. If there are no <result-form>-s
then the result value is nil. If the <test-form> is omitted, then the test
is taken to be true, and the loop does not terminate.

4. Otherwise, if <test-form> yields non-nil, then each <body-form>
is evaluated in turn. Then, each <inc-form> is evaluated in turn
and processing resumes at step 2.

Furthermore, the for operators establish an anonymous block,
allowing the return operator to be used to terminate at any point.

.SS Operators each, each*, collect-each, collect-each*, append-each and append-each*

.TP
Syntax:

  (each ({(<sym> <init-form>)}*) <body-form>*)
  (each* ({(<sym> <init-form>)}*) <body-form>*)
  (collect-each ({(<sym> <init-form>)}*) <body-form>*)
  (collect-each* ({(<sym> <init-form>)}*) <body-form>*)
  (append-each ({(<sym> <init-form>)}*) <body-form>*)
  (append-each* ({(<sym> <init-form>)}*) <body-form>*)

.TP
Description:

These operator establish a loop for iterating over the elements of one or more
lists. Each <init-form> must evaluate to a list. The lists are then iterated in
parallel over repeated evaluations of the <body-form>-s, which each <sym>
variable being assigned to successive elements of its list. The shortest list
determines the number of iterations, so if any of the <init-form>-s evaluate to
an empty list, the body is not executed.

The body forms are enclosed in an anonymous block, allowing the return
operator to terminate the loop prematurely and optionally specify
the return value.

The collect-each and collect-each* variants are like each and each*,
except that for each iteration, the resulting value of the body is collected
into a list. When the iteration terminates, the return value of the
collect-each or collect-each* operator is this collection.

The append-each and append-each* variants are like each and each*,
except that for each iteration other than the last, the resulting value of the
body must be a list. The last iteration may produce either an atom or a list.
The objects produced by the iterations are combined together as if they
were arguments to the append function, and the resulting value is the
value of the append-each or append-each* operator.

The alternate forms denoted by the adorned symbols each*, collect-each* and
append-each*, variants differ from each, collect-each and append-each* in the
following way. The plain forms evaluate the <init-form>-s in an environment in
which none of the <sym> variables are yet visible. By contrast, the alternate
forms evaluate each <init-form> in an environment in which bindings for the
previous <sym> variables are visible.  In this phase of evaluation, <sym>
variables are list-valued: one by one they are each bound to the list object
emanating from their corresponding <init-form>. Just before the first loop
iteration, however, the <sym> variables are assigned the first item from each
of their lists.

.TP
Examples:

 ;; print numbers from 1 to 10 and whether they are even or odd
 (each* ((n (range 1 10)) 
         (even (collect-each ((n m)) (evenp m)))) ;; n is a list here
   (format t "~s is ~s\en" n (if even "even" "odd"))) ;; n is an item here

 Output:

 1 is odd
 2 is even
 3 is odd
 4 is even
 5 is odd
 6 is even
 7 is odd
 8 is even
 9 is odd
 10 is even

.SH FUNCTION OBJECTS AND NAMED FUNCTIONS

.SS Operator defun

.TP
Syntax:

  (defun <name> (<param>* [: <opt-param>*] [. <rest-param>]) <body-form>*)

Description:

The defun operator introduces a new function in the global function namespace.
The function is similar to a lambda, and has the same parameter syntax
and semantics as the lambda operator.

Unlike in lambda, the <body-form>-s of a defun are surrounded by a block.
The name of this block is the same as the name of the function, making it
possible to terminate the function and return a value using (return-from <name>
<value>). For more information, see the definition of the block operator.

A function may call itself by name, allowing for recursion.

.SS Operator lambda

.TP
Syntax:

  (lambda (<param>* [: <opt-param>*] [. <rest-param>]) {<body-form>}*)

  (lambda <rest-param> {<body-form>}*)

.TP
Description:

The lambda operator produces a value which is a function.  Like in most other
Lisps, functions are objects in TXR Lisp.  They can be passed to functions as
arguments, returned from functions, aggregated into lists, stored in variables,
et cetera.

The first argument of lambda is the list of parameters for the function.   It
may be empty, and it may also be an improper list (dot notation) where the
terminating atom is a symbol other than nil. It can also be a single symbol.

The second and subsequent arguments are the forms making up the function body.
The body may be empty.

When a function is called, the parameters are instantiated as variables that
are visible to the body forms. The variables are initialized from the values of
the argument expressions appearing in the function call.

The dotted notation can be used to write a function that accepts
a variable number of arguments. To write a function that accepts
variable arguments only, with no required arguments, use a single symbol.

The keyword symbol : (colon) can appear in the parameter list. This is
the symbol in the keyword package whose name is the empty string.  This
symbol is treated specially: it serves as a separator between
required parameters and optional parameters.  Furthermore, the : symbol
has a role to play in function calls: it can be specified as an argument
value to an optional parameter by which the caller indicates that the
optional argument is not being specified. It will be processed exactly
that way.

An optional parameter can also be written in the form (<name> <expr> [<sym>]).
In this situation, if the call does not specify a value for the parameter
(or specifies a value as the keyword : (colon)) then the parameter takes on the
value of the expression <expr>.  If <sym> is specified, then <sym> will be
introduced as an additional binding with a boolean value which indicates
whether or not the optional parameter had been specified by the caller.

The initializer expressions are evaluated an environment in which
all of the previous parameters are visible, in addition to the surrounding
environment of the lambda. For instance:

  (let ((default 0))
    (lambda (str : (end (length str)) (counter default))
      (list str end counter)))

In this lambda, the initializing expression for the optional parameter
end is (length str), and the str variable it refers to is the previous
argument. The initializer for the optional variable counter is
the expression default, and it refers to the binding established
by the surrounding let. This reference is captured as part of the
lambda's lexical closure.

.TP
Examples:

Counting function. This function, which takes no arguments, captures the
variable "counter". Whenever this object is called, it increments the counter
by 1 and returns the incremented value.

  (let ((counter 0))
    (lambda () (inc counter)))

Function that takes two or more arguments. The third and subsequent arguments
are aggregated into a list passed as the single parameter z:

  (lambda (x y . z) (list 'my-arguments-are x y z))

Variadic function:

  (lambda args (list 'my-list-of-arguments args))

Optional arguments:

  [(lambda (x : y) (list x y)) 1] -> (1 nil)
  [(lambda (x : y) (list x y)) 1 2] -> (1 2)

.SS Function call

.TP
Syntax:

  (call <function> <argument>*)

.TP
Description:

The call function invokes <function>, passing it the given
arguments, if any.

.TP
Examples:

Apply arguments 1 2 to a lambda which adds them to produce 3:

(call (lambda (a b) (+ a b)) 1 2) -> 3

Useless use of call on a named function; equivalent to (list 1 2):

(call (fun list) 1 2) -> (1 2)

.SS Operator fun

.TP
Syntax:

  (fun <function-name>)

.TP
Description:
The fun operator retrieves the function object corresponding to a named
function in the current lexical environment.

The <function-name> is a symbol denoting a named function: a built in
function, or one defined by defun.

Note: the fun operator does not see macro bindings. It is possible to
retrieve a global macro expander using symbol-function.

.TP
Dialect Note:
A lambda expression is not a function name in TXR Lisp. The 
syntax (fun (lambda ...)) is invalid.

.SS Functions symbol-function and symbol-value

.TP
Syntax:

  (symbol-function <symbol>)
  (symbol-value <symbol>)

.TP
Description:

The symbol-function retrieves the value of the global function binding of the
given symbol if it has one: that is, the function object tied to the symbol. If
the symbol has no global function binding, then the value of the global macro
binding is returned. If that doesn't exist, then the value of a global special
operator binding is returned, and if that doesn't exist, then nil is returned.

The symbol-value retrieves the value of a global variable, if it exists,
otherwise nil.

Note: a function binding is a function, but a macro or special operator binding
binding isn't.  The value of a macro binding is a list of the following form:

  (#<environment object> <macro-parameter-list> <body-form>*)

The value of a special operator binding is a "C pointer" object, whose
printed representation looks like:

  #<cptr: 808be4f>

These details may change in future version of TXR.

.TP
Dialect note:

Forms which call symbol-function or symbol-value are currently not an
assignable place. Only the defun operator defines functions, and the set
operator modifies variables. 

.SS Functions boundp and fboundp

.TP
Syntax:

  (boundp <symbol>)
  (fboundp <symbol>)

.TP
Description:

boundp returns t if the symbol has a variable binding in the global
environment, otherwise nil.  

Foundp returns t if the symbol has a function or macro binding in the global
environment, or if it is an operator, otherwise nil.

.SS Function func-get-form

.TP
Syntax:

  (func-get-form <func>)

.TP
Description:

The func-get-form function retrieves a source code form of <func>, which
must be an interpreted function. The source code form has the syntax 
(<name> <arglist> {<body-form>}*).

.SS Function func-get-env

.TP
Syntax:

  (func-get-env <func>)

.TP
Description:

The func-get-env function retrieves the environment object associated with
function <func>.  The environment object holds the captured bindings of a
lexical closure.

.SS Function functionp

.TP
Syntax:

  (functionp <obj>)

.TP
Description:

The functionp function returns t if <obj> is a function, otherwise it
returns nil.

.SS Function interp-fun-p

.TP
Syntax:

  (interp-fun-p <obj>)

.TP
Description:

The interp-fun-p function returns t if <obj> is an interpreted function,
otherwise it returns nil.

.SS Macros flet and labels

.TP
Syntax:

  (flet ({(<name> <param-list> <function-body-form>*)}*)
     <body-form>*)

  (labels ({(<name> <param-list> <function-body-form>*)}*)
     <body-form>*)

.TP
Description:

The flet and labels macros bind local, named functions in the lexical scope.
The difference between flet and labels is that a function defined by labels can
see itself, and therefore recurse directly by name. Moreover, if multiple
functions are defined by the same labels construct, they all see each other.
By contrast, a flet function does not have itself in scope and cannot recurse.
Multiple functions in the same flet do not have each other in scope.

More formally, the <function-body-form>-s and <param-list> of the functions
defined by labels are in a scope in which all of the function names being
defined by that labels construct are visible.

Under both labels and flet, the local functions that are defined are
lexically visible to the main <body-form>s.

Note that labels and flat are properly scoped with regard to macros.
During macro expansion, they shadow, macros defined by macrolet and defmacro.

See also: the macrolet operator.

.TP
Examples:

  ;; Wastefully slow algorithm for determining even-ness.
  ;; Note:
  ;; - mutual recursion between labels-defined functions
  ;; - inner is-even bound by labels shadows the outer one bound by defun
  ;;   so the (is-even n) call goes to the local function.

  (defun is-even (n)
   (labels ((is-even (n)
              (if (zerop n) t (is-odd (- n 1))))
            (is-odd (n)
              (if (zerop n) nil (is-even (- n 1)))))
     (is-even n)))

.SH OBJECT TYPE AND EQUIVALENCE

.SS Function typeof

.TP
Syntax:

  (typeof <value>)

.TP
Description

The typeof function returns a symbol representing the type of <value>.

.RS

The core types are identified by the following symbols.
.IP cons

A cons cell.

.IP str

String.

.IP lit

A literal string embedded in the TXR executable image.

.IP chr

Character.

.IP fixnum

Fixnum integer. An integer that fits into the value word, not having to
be heap allocated.

.IP sym

Symbol.

.IP pkg

Symbol package.

.IP fun

Function.

.IP vec

Vector.

.IP lcons

Lazy cons.

.IP lstr

Lazy string.

.IP env

Function/variable binding environment.

.IP bignum

A bignum integer: arbitrary precision integer that is heap-allocated.

.PP
There are additional kinds of objects, such as streams.

.SS Functions null, not, false

.TP
Syntax:

  (null <value>)
  (not <value>)
  (false <value>)

.TP
Description:

The null, not and false functions are synonyms.  They tests whether <value> is
the object nil. They return t if this is the case, nil otherwise.

.TP
Examples:

  (null '()) -> t
  (null nil) -> t
  (null ()) -> t
  (false t) -> nil

  (if (null x) (format t "x is nil!"))

  (let ((list '(b c d)))
    (if (not (memq 'a list))
      (format t "list ~s does not contain the symbol a\en")))

.SS Function true

.TP
Syntax:

  (true <value>)

.TP
Description:

The true function is the complement of the null, not and false functions.
It return t if the <value> is any object other than nil. If <value> is
nil, it returns nil.

Note: programs should avoid explicitly testing values with true.
For instance (if x ...) should be favored over (if (true x) ...)

.TP
Example:

   ;; Compute indices where the list '(1 nil 2 nil 3) has true values:
   ;; "Where is (1 nil 2 nil 3) true?"

   [where '(1 nil 2 nil 3) true] -> (1 3)

.SS Functions eq, eql and equal

.TP
Syntax:

  (eq <left-obj> <right-obj>)
  (eql <left-obj> <right-obj>)
  (equal <left-obj> <right-obj>)

.TP
Description:

The principal equality test functions eq, eql and equal test whether
two objects are equivalent, using different criteria. They return t
if the objects are equivalent, and nil otherwise.

The eq function uses the strictest equivalence test, called implementation
equality.  The eq function returns t if, and only if, <left-obj> and
<right-obj> are actually the same object. The eq test is is implemented
by comparing the raw bit pattern of the value, whether or not it is
an immediate value or a pointer to a heaped object, including its type
tags.  Consequently, two objects of different type are never equal, two
character values are eq if they are the same character, and two fixnum integers
are eq if they have the same value.  All other objects kinds are actually
represented as pointers, and are eq if they point to the same object in memory.
So two bignum integers might not be eq even if they have the same numeric
value, two lists might not be eq even if all their corresponding elements are
eq, two strings might not be eq even if they hold identical text, etc.

The eql function is slightly less strict than eq. The difference between
eql and eq is that if <left-obj> and <right-obj> are bignums which have
the same numeric value, eql returns t, even if they are different objects.
For all other objects, eql behaves like eq.

The equal function is less strict than eql. In general, it recurses into some
kinds of aggregate objects to perform a structural equivalence.  

If <left-obj> and <right-obj> are eql then they are also equal.  

If the two objects are both cons cells, then they are equal if their "car"
fields are equal and their "cdr" fields are equal.  

If two objects are vectors, they are equal if they have the same length, and
their corresponding elements are equal. 

If two objects are strings, they are equal if they are textually identical.  

If two objects are functions, they are equal if they have equal environments,
and if they have equal functions.  Two compiled functions are the same if they
are the same function. Two interpreted functions are equal if their list
structure is equal.

Two hashes are equal if they use the same equality (both are equal-based,
or both are the default eql-based), if their user-data elements are equal, if
their sets of keys are identical, and if the data items associated with
corresponding keys from each respective hash are equal objects.

For some aggregate objects, there is no special semantics.  Two arguments
which are symbols, packages, or streams are equal if and only if they
are the same object.

Certain object types have a custom equal function.

.SH BASIC LIST LIBRARY

When the first element of a compound form is a symbol denoting a function,
the evaluation takes place as follows. The remaining forms, if any, denote
the arguments to the function. They are evaluated in left to right order
to produce the argument values, and passed to the function.
An exception is thrown if there are not enough arguments, or too many.

Programs can define named functions with the defun operator

The following are Lisp functions and variables built-in to TXR.

.SS Function cons

.TP
Syntax:

  (cons <car-value> <cdr-value>)

.TP

Description:

The cons function allocates, initializes and returns a single cons cell.
A cons has two fields called "car" and "cdr", which are accessed by
functions of the same name, or by the functions "first" and "rest",
which are alternative spellings.

Lists are made up of conses. A (proper) list is either the symbol nil
denoting an empty list, or a cons cell which holds the first item of
the list in its "car", and the list of the remaining items in "cdr".
(cons 1 nil) allocates a one element list denoted (1). The "cdr"
is nil, so there are no additional items.

A cons cell with a "cdr" other than nil is printed with the dotted
pair notation. For example (cons 1 2) yields (1 . 2). 
The notation (1 . nil) is valid as input into the machine,
but is printed as (1). 

A list terminated by an atom other than nil is called an improper
list, and the dot notation is extended to cover improper lists.
For instance (1 2 . 3) is an improper list of two elements,
terminated by 3, and can be constructed using (cons 1 (cons 2 3)).
Another notation for this list is (1 . (2 . 3))
The list (1 2) is (1 . (2 . nil)).

.SS Function atom

.TP
Syntax:
(atom <value>)

.TP
Description:

The atom function tests whether <value> is an atom. It returns t if this is the
case, nil otherwise.  All values which are not cons cells are atoms.

(atom x) is equivalent to (not (consp x)).

.TP
Examples:

  (atom 3) -> t
  (atom (cons 1 2)) -> nil
  (atom "abc") -> t
  (atom '(3)) -> nil

.SS Function consp

.TP
Syntax:

(consp <value>)

.TP
Description:

The atom function tests whether <value> is a cons. It returns t if this is the
case, nil otherwise.

(consp x) is equivalent to (not (atom x)).

Non-empty lists test positive under consp because a list is represented
as a reference to the first cons in a chain of one or more conses.

Note that a lazy cons is a cons and satisfies the consp test.  See the function
make-lazy-cons.

.TP
Examples:

  (consp 3) -> nil
  (consp (cons 1 2)) -> t
  (consp "abc") -> nil
  (consp '(3)) -> t

.SS Functions car and first

.TP
Syntax:

  (car <cons-or-nil>)
  (first <cons-or-nil>)

.TP
Description:

The functions car and first are synonyms. They retrieve the "car"
field of a cons cell. (car (cons 1 2)) yields 1.

For programming convenience, (car nil) is allowed, and returns nil,
even though nil isn't a cons and doesn't have a "car" field.

.SS Functions cdr and rest

.TP
Syntax:

  (cdr <cons-or-nil>)
  (rest <cons-or-nil>)

.TP
Description:

The functions cdr and rest are synonyms. They retrieve the "cdr"
field of a cons cell. (cdr (cons 1 2)) yields 2.

For programming convenience, (cdr nil) is allowed, and returns nil,
even though nil isn't a cons and doesn't have a "cdr" field.

.TP
Example:

Walk every element of the list (1 2 3):

    (for ((i '(1 2 3))) (i) ((set i (cdr i)))
      (print (car i) *stdout*)
      (print #\enewline *stdout*))

The variable i marches over the cons cells which make up the "backbone"
of the list. The elements are retrieved using the car function.
Advancing to the next cell is achieved using (cdr i). If i is the
last cell in a (proper) list, (cdr i) yields nil. The guard
expression i fails and the loop terminates.

.SS Functions rplaca and rplacd

.TP
Syntax:

  (rplaca <cons> <new-car-value>)
  (rplacd <cons> <new-cdr-value>)

.TP
Description:

The rplaca and rplacd functions assign new values into the "car"
and "cdr" fields of the cell <cons>.  Note that (rplaca x y)
is the same as the more generic (set (car x) y), and likewise
(rplacd x y) can be written as (set (cdr x) y).

It is an error if <cons> is not a cons or lazy cons. In particular,
whereas (car nil) is correct, (rplaca nil ...) is erroneous.

The rplaca and rplacd functions return <cons>.

Note: TXR versions 89 and earlier, these functions returned the new value.
The behavior was undocumented.

.SS Functions second, third, fourth, fifth and sixth

.TP
Syntax:

  (first <list>)
  (second <list>)
  (third <list>)
  (fourth <list>)
  (fifth <list>)
  (sixth <list>)

.TP
Description:

These functions access the elements of a proper list by position.

If the list is shorter than implied, these functions return nil.

.TP
Examples:

  (third '(1 2)) -> nil
  (second '(1 2)) -> 2
  (third '(1 2 . 3)) -> **error**

.SS Functions append, nconc and append*

.TP
Syntax:

  (append [<list>* <last-arg>])
  (nconc [<list>* <last-arg>])
  (append* [<list>* <last-arg>])

.TP
Description:

The append function creates a new list which is a catenation of the
<list> arguments. All arguments are optional, such that (append) produces
the empty list.

If a single argument is specified, then append simply returns the value of that
argument. It may be any kind of object.

If N arguments are specified, where N > 1, then the first N-1 arguments must be
proper lists. Copies of these lists are catenated together. The last argument
N, shown in the above syntax as <last-arg>, may be any kind of object. It is
installed into the cdr field of the last cons cell of the resulting list.
Thus, if argument N is also a list, it is catenated onto the resulting list,
but without being copied. Argument N may be an atom other than nil; in that
case append produces an improper list.

The nconc function works like append, but avoids consing. It destructively
manipulates (that is to say, mutates) incoming lists to catenate them, and so
must be used with care.

The append* function works like append, but returns a lazy list which produces
the catenation of the lists on demand.  If some of the arguments are
themselves lazy lists which are infinite, then append* can return immediately,
whereas append will get caught in an infinite loop trying to produce a
catenation and eventually exhaust available memory. (However, the last
argument to append may be an infinite lazy list, because append does not
traverse the last argument.)

.TP
Examples:

  ;; An atom is returned.
  (append 3) -> 3

  ;; A list is also just returned: no copying takes place.
  ;; The eq function can verify that the same object emerges
  ;; from append that went in.
  (let ((list '(1 2 3))) 
    (eq (append list) list)) -> t

  (append '(1 2 3) '(4 5 6) 7) -> '(1 2 3 4 5 6 . 7))

  ;; the (4 5 6) tail of the resulting list is the original
  ;; (4 5 6) object, shared with that list.

  (append '(1 2 3) '(4 5 6)) -> '(1 2 3 4 5 6)

  (append nil) -> nil

  ;; (1 2 3) is copied: it is not the last argument
  (append '(1 2 3) nil) -> (1 2 3)

  ;; empty lists disappear
  (append nil '(1 2 3) nil '(4 5 6)) -> (1 2 3 4 5 6)
  (append nil nil nil) -> nil

  ;; atoms and improper lists other than in the last position
  ;; are erroneous
  (append '(a . b) 3 '(1 2 3)) -> **error**

.SS Function list

.TP
Syntax:

(list <value>*)

.TP
Description:

The list function creates a new list, whose elements are the
argument values.

.TP
Examples:

  (list) -> nil
  (list 1) -> (1)
  (list 'a 'b) -> (a b)

.SS Function list*

.TP
Syntax:

(list* <value>*)

.TP
Description:

The list* function is a generalization of cons. If called with exactly
two arguments, it behaves exactly like cons: (list* x y) is
identical to (cons x y).  If three or more arguments are specified,
the leading arguments specify additional atoms to be consed to the
front of the list. So for instance (list* 1 2 3) is the same as
(cons 1 (cons 2 3)) and produces the improper list (1 2 . 3).
Generalizing in the other direction, list* can be called with just
one argument, in which case it returns that argument, and
can also be called with no arguments in which case it returns nil.

.TP
Examples:

  (list*) -> nil
  (list* 1) -> 1
  (list* 'a 'b) -> (a . b)
  (list* 'a 'b 'c) -> (a b . c)

.TP
Dialect Note:

Note that unlike in some other Lisp dialects, the effect
of (list* 1 2 x) can also be obtained using (list 1 2 . x).
However, (list* 1 2 (func 3)) cannot be rewritten as (list 1 2 . (func 3))
because the latter is equivalent to (list 1 2 func 3).

.SS Function sub-list

.TP
Syntax:

  (sub-list <list> [<from> [<to>]])

.TP
Description:

This function is like the sub function, except that it operates
strictly on lists.

For a description of the arguments and semantics, refer to the sub function.

.SS Function replace-list

.TP
Syntax:

  (replace-list <list> <item-sequence> [<from> [<to>]])

.TP
Description:

The replace-list function is like the replace function, except that the first
argument must be a list.

For a description of the arguments and semantics, refer to the replace function.

.SS Functions listp and proper-listp

.TP
Syntax:

  (listp <value>)
  (proper-listp <value>)

.TP
Description:

The listp and proper-listp functions test, respectively, whether
<value> is a list, or a proper list, and return
t or nil accordingly.

The listp test is weaker, and executes without having to traverse
the object. (listp x) is equivalent to (or (null x) (consp x)).
The empty list is a list, and a cons cell is a list.

The proper-listp function returns t only for proper lists.  A proper list is
either nil, or a cons whose cdr is a proper list. proper-listp traverses the
list, and its execution will not terminate if the list is circular.

.SS Function length-list

.TP
Syntax:

(length-list <list>)

.TP
Description:

The length-list function returns the length of <list>, which may be
a proper or improper list. The length of a list is the number of conses in that
list.

.SS Function copy-list

.TP
Syntax:

  (copy-list <list>)

.TP
Description:

The copy-list function which returns a list similar to <list>, but with
a newly allocated cons cell structure.

If <list> is an atom, it is simply returned.

Otherwise, <list> is a cons cell, and copy-list returns
(cons (car <list>) (copy-list (cdr <list>))) except that recursion
is not necessarily used.

Note that the object (car <list>) is not deeply copied, but only
propagated by reference into the new list. copy-list produces
a new list structure out of the same items that are in <list>.

.TP
Dialect Note:

Common Lisp does not allow the argument to be an atom, except
for the empty list nil.

.SS Function copy-cons

.TP
Syntax:

  (copy-cons <cons>)

.TP
Description:

This function creates a fresh cons cell, whose car and cdr fields are
copied from <cons>.

.SS Functions reverse, nreverse

.TP
Syntax:

  (reverse <list>)
  (nreverse <list>)

.TP
Description:

The functions reverse and nreverse produce an object which contains
the same items as proper list <list>, but in reverse order.
If <list> is nil, then both functions return nil.

The reverse function is non-destructive: it creates a new list.

The nreverse function creates the structure of the reversed list out of the
cons cells of the input list, thereby destructively altering it (if it contains
more than one element). How nreverse uses the material from the original list
is unspecified. It may rearrange the cons cells into a reverse order, or it may
keep the structure intact, but transfer the "car" values among cons cells into
reverse order.  Other approaches are possible.

.SS Function ldiff

.TP
Syntax:

  (ldiff <list> <sublist>)

.TP
Description:

The values <list> and <sublist> are proper lists.

The ldiff function determines whether <sublist> is a structural suffix of
<list> (meaning that it actually is a suffix, and is not merely equal to one).

This is true if <list> and <sublist> are the same object, or else,
recursively, if <sublist> is a suffix of (cdr <list>).

The object nil is the sublist of every list, including itself.

The ldiff function returns a new list consisting of the elements of
the prefix of <list> which come before the <sublist> suffix. The elements
are in the same order as in <list>.  If <sublist> is not a suffix of <list>,
then a copy of <list> is returned.

.TP
Examples:

  ;;; unspecified: the compiler could make '(2 3) a suffix of '(1 2 3),
  ;;; or they could be separate objects.
  (ldiff '(1 2 3) '(2 3)) -> either (1) or (1 2 3)

  ;; b is the (1 2) suffix of a, so the ldiff is (1)
  (let ((a '(1 2 3)) (b (cdr a)))
    (ldiff a b))
  -> (1)

.SS Function last

.TP
Syntax:

  (last <list>)

.TP
Description:

If <list> is a nonempty proper or improper list, the last function
returns the last cons cell in the list: that cons cell whose cdr field
is a terminating atom.

If <list> is nil, then nil is returned.

.SS Functions flatten, flatten*

.TP
Syntax:

  (flatten <list>)
  (flatten* <list>)

.TP
Description:

The flatten function produces a list whose elements are all of the non-nil
atoms contained in the structure of <list>. The flatten* function
works like flatten except that flatten creates and returns a complete
flattened list, whereas flatten* produces a lazy list which is
instantiated on demand. This is particularly useful when the input
structure is itself lazy.

.TP
Examples:

  (flatten '(1 2 () (3 4))) -> (1 2 3 4)

  ;; precisely equivalent to previous example! nil is the same thing as ()
  (flatten '(1 2 nil (3 4))) -> (1 2 3 4)

  (flatten nil) -> nil

  (flatten '(((()) ()))) -> nil

.SS Functions memq, memql and memqual

.TP
Syntax:

  (memq <object> <list>)
  (memql <object> <list>)
  (memqual <object> <list>)

.TP
Description:

The memq, memql and memqual functions search the <list> for a member
which is, respectively, eq, eql or equal to <object>. (See the eq, eql and
equal functions below.)

If no such element found, nil is returned.

Otherwise, that tail of the list is returned whose first element
is the matching object.

.SS Functions member and member-if

.TP
Syntax:

  (member <key> <sequence> [<testfun> [<keyfun>]])
  (member-if <predfun> <sequence> [<keyfun>])

.TP
Description:

The find and find-if functions search through <sequence> for an item which
matches a key, or satisfies a predicate function, respectively.

The keyfun argument specifies a function which is applied to the elements
of the sequence to produce the comparison key. If this argument is omitted,
then the untransformed elements of the sequence themselves are examined.

The member function's testfun argument specifies the test function which is
used to compare the comparison keys taken from the sequence to the search key.
If this argument is omitted, then the equal function is used.
If member does not find a matching element, it returns nil. Otherwise it
returns the suffix of <sequence> which begins with the matching element.

The member-if function's predfun argument specifies a predicate function
which is applied to the successive comparison keys pulled from the sequence
by applying the key function to successive elements.  If no match is found,
then nil is returned, otherwise the suffix of <sequence> which begins
with the matching element.

.SS Functions remq, remql and remqual

.TP
Syntax:

  (remq <object> <list>)
  (remql <object> <list>)
  (remqual <object> <list>)

.TP
Description

The remq, remql and remqual functions produce a new list based on <list>,
removing the items which are eq, eql or equal to <object>.

The input <list> is unmodified, but the returned list may share substructure
with it. If no items are removed, it is possible that the return value
is <list> itself.

.SS Functions remq*, remql* and remqual*

.TP
Syntax:

  (remq* <object> <list>)
  (remql* <object> <list>)
  (remqual* <object> <list>)

.TP
Description:

The remq*, remql* and remqual* functions are lazy versions of
remq, remql and remqual. Rather than computing the entire new list
prior to returning, these functions return a lazy list.

Caution: these functions can still get into infinite looping behavior.
For instance, in (remql* 0 (repeat '(0))), remql will keep consuming
the 0 values coming out of the infinite list, looking for the first item that
does not have to be deleted, in order to instantiate the first lazy value.

.TP
Examples:

  ;; Return a list of all the natural numbers, excluding 13,
  ;; then take the first 100 of these.
  ;; If remql is used, it will loop until memory is exhausted,
  ;; because (range 1) is an infinite list.

  [(remql* 13 (range 1)) 0..100]

.SS Functions countqual, countql and countq

.TP
Syntax:

  (countq <object> <list>)
  (countql <object> <list>)
  (countqual <object> <list>)

.TP
Description

The countq, countql and countqual functions count the number of objects
in <list> which are eq, eql or equal to <object>, and return the count.

.SH APPLICATIVE LIST PROCESSING

.SS Functions remove-if, keep-if, remove-if* and keep-if*

.TP
Syntax:

  (remove-if <predicate-function> <list> [<key-function>])
  (keep-if <predicate-function> <list> [<key-function>])
  (remove-if* <predicate-function> <list> [<key-function>])
  (keep-if* <predicate-function> <list> [<key-function>])

.TP
Description

The remove-if function produces a list whose contents are those of
<list> but with those elements removed which satisfy <predicate-function>.
Those elements which are not removed appear in the same order.
The result list may share substructure with the input list,
and may even be the same list object if no items are removed.

The optional <key-function> specifies how each element from the <list> is
transformed to an argument to <predicate-function>. If this argument is omitted
then the predicate function is applied to the elements directly, a behavior
which is identical to <key-function> being (fun identity).

The keep-if function is exactly like remove-if, except the sense of
the predicate is inverted. The function keep-if retains those items
which remove-if will delete, and removes those that remove-if will preserve.

The remove-if* and keep-if* are like remove-if and keep-if, but
produce lazy lists.

.TP
Examples:

  ;; remove any element numerically equal to 3.
  (remove-if (op = 3) '(1 2 3 4 3.0 5)) -> (1 2 4 5)

  ;; remove those pairs whose first element begins with "abc"
  [remove-if (op equal [@1 0..3] "abc")
             '(("abcd" 4) ("defg" 5))
             car]
  -> (("defg 5))

  ;; equivalent, without test function
  (remove-if (op equal [(car @1) 0..3] "abc")
             '(("abcd" 4) ("defg" 5)))
  -> (("defg 5))

.SS Function count-if

.TP
Syntax:

  (count-if <predicate-function> <list> [<key-function>])

.TP
Description:

The count-if function counts the number of elements of <list> which satisfy
<predicate-function> and returns the count.

The optional <key-function> specifies how each element from the <list> is
transformed to an argument to <predicate-function>. If this argument is omitted
then the predicate function is applied to the elements directly, a behavior
which is identical to <key-function> being (fun identity).

.SS Functions posqual, posql and posq

.TP
Syntax:

  (posq <object> <list>)
  (posql <object> <list>)
  (posqual <object> <list>)

.TP
Description

The posq, posql and posqual functions return the zero-based position of the
first item in <list> which is, respectively, eq, eql or equal to <object>.

.SS Functions posqual, posql and posq

.TP
Syntax:

  (posq <object> <list>)
  (posql <object> <list>)
  (posqual <object> <list>)

.TP
Description

The posq, posql and posqual functions return the zero-based position of the
first item in <list> which is, respectively, eq, eql or equal to <object>.

.SS Functions pos and pos-if

.TP
Syntax:

  (pos <key> <list> [<testfun> [<keyfun>]])
  (pos-if <predfun> <list> [<keyfun>])

.TP
Description:

The pos and pos-if functions search through a list for an item which
matches a key, or satisfies a predicate function, respectively.
They return the zero based position of the matching item.

The keyfun argument specifies a function which is applied to the elements
of the list to produce the comparison key. If this argument is omitted,
then the untransformed elements of the list themselves are examined.

The pos function's testfun argument specifies the test function which
is used to compare the comparison keys from the list to the search key.
If this argument is omitted, then the equal function is used.
The position of the first element from the list whose comparison key (as
retrieved by the key function) matches the search (under the test function) is
returned. If no such element is found, nil is returned.

The pos-if function's predfun argument specifies a predicate function
which is applied to the successive comparison keys pulled from the list
by applying the key function to successive elements. The position of
the first element for which the predicate function yields true is returned. If
no such element is found, nil is returned.

.SS Functions pos-max and pos-min

.TP
Syntax:

  (pos-max <sequence> [<testfun> [<keyfun>]])
  (pos-min <sequence> [<testfun> [<keyfun>]])

.TP
Description:

The pos-min and pos-max function implement exactly the same algorithm; they
differ only in their defaulting behavior with regard to the <testfun>
argument.  If <testfun> is not given, then the pos-max function defaults it to
the > function, whereas pos-min defaults it to the < function.

If <sequence> is empty, both functions return nil.

Without a <testfun> argument, the pos-max function finds the zero-based
position index of the numerically maximum value occurring in <sequence>,
whereas pos-min without a <testfun> argument finds the index of the minimum
value.

If a <testfun> argument is given, the two functions are equivalent.
The <testfun> function must be callable with two arguments.
If <testfun> behaves like a greater-than comparison, then pos-max
and pos-min return the index of the maximum element. If <testfun>
behaves like a less-than comparison, then the functions return
the index of the minimum element.

The <keyfun> argument defaults to the identity function. Each element
from sequence is passed through this one-argument function, and
the resulting value is used in its place.

.SS Function where

.TP
Syntax:

  (where <object> <function>)

.TP
Description:

If <object> is a sequence, the where function returns
a list of the numeric indices of those of its elements which satisfy
<function>. The numeric indices appear in increasing order.

If <object> is a hash, the where function returns an unordered list
of keys which have values which satisfy <function>.

<function> must be a function that can be called with one argument.
For each element of <object>, <function> is called with that element
as an argument.  If a non-nil value is returned, then the zero-based index of
that element is added to a list. Finally, the list is returned.

.SS Function select

.TP
Syntax:

  (select <object> <index-list>)

.TP
Description:

The select function returns an object, of the same kind as <object>,
which consists of those elements of <object> which are identified by
the indices in <index-list>.

If <object> is a sequence, then <index-list> consists of numeric
indices.  The select function stops processing <object> upon encountering an
index inside <index-list> which is out of range. (Rationale: without
this strict behavior, select would not be able to terminate if
<index-list> is infinite.)

If <object> is a list, then <index-list> must contain monotonically increasing
numeric values, even if no value is out of range, since the select function
makes a single pass through the list based on the assumption that indices
are ordered. (Rationale: optimization.)

If <object> is a hash, then <index-list> is a list of keys. A new hash is
returned which contains those elements of <object> whose keys appear
in <index-list>. All of <index-list> is processed, even if it contains
keys which are not in <object>.

.SS Function tree-find

.TP
Syntax:

  (tree-find <obj> <tree> <test-function>)

.TP
Description:

The tree-find function searches <tree> for an occurrence of <obj>.  Tree can be
any atom, or a cons. If <tree> it is a cons, it is understood to be a proper
list whose elements are also trees.

The equivalence test is performed by <test-function> which must take two
arguments, and has conventions similar to eq, eql or equal.

tree-find works as follows.  If <tree> is equivalent to <obj> under
<test-function>, then t is returned to announce a successful finding.
If this test fails, and <tree> is an atom, nil is returned immediately to
indicate that the find failed.  Otherwise, <tree> is taken to be a proper list,
and tree-find is recursively applied to each element of the list in turn, using
the same <obj> and <test-function> arguments, stopping at the first element
which returns non-nil.  

.SS Functions find and find-if

.TP
Syntax:

  (find <key> <list> [<testfun> [<keyfun>]])
  (find-if <predfun> <list> [<keyfun>])

.TP
Description:

The find and find-if functions search through a list for an item which
matches a key, or satisfies a predicate function, respectively.

The keyfun argument specifies a function which is applied to the elements
of the list to produce the comparison key. If this argument is omitted,
then the untransformed elements of the list themselves are searched.

The find function's testfun argument specifies the test function which
is used to compare the comparison keys from the list to the search key.
If this argument is omitted, then the equal function is used.
The first element from the list whose comparison key (as retrieved by
the key function) matches the search (under the test function)
is returned. If no such element is found, nil is returned.

The find-if function's predfun argument specifies a predicate function
which is applied to the successive comparison keys pulled from the list
by applying the key function to successive elements. The first element
for which the predicate function yields true is returned. If no such
element is found, nil is returned.

.SS Functions find-max and find-min

.TP
Syntax:

  (find-max <sequence> [<testfun> [<keyfun>]])
  (find-min <sequence> [<testfun> [<keyfun>]])

.TP
Description:

The find-min and find-max function implement exactly the same algorithm; they
differ only in their defaulting behavior with regard to the <testfun>
argument.  If <testfun> is not given, then the find-max function defaults it to
the > function, whereas find-min defaults it to the < function.

Without a <testfun> argument, the find-max function finds the numerically
maximum value occurring in <sequence>, whereas pos-min without a <testfun>
argument finds the minimum value.

If a <testfun> argument is given, the two functions are equivalent.
The <testfun> function must be callable with two arguments.
If <testfun> behaves like a greater-than comparison, then find-max
and find-min both return the maximum element. If <testfun>
behaves like a less-than comparison, then the functions return
the minimum element.

The <keyfun> argument defaults to the identity function. Each element
from sequence is passed through this one-argument function, and
the resulting value is used in its place for the purposes of the
comparison. However, the original element is returned.

.SS Function set-diff

.TP
Syntax:
  (set_diff <list1> <list2> [<testfun> [<keyfun>]])

.TP
Description:

The set-diff function treats the lists <list1> and <list2> as if they were sets
and computes the set difference: a list which contains those elements in
<list1> which do not occur in <list2>.

Element equivalence is determined by a combination of testfun and keyfun.
Elements are compared pairwise, and each element of a pair is passed through
the keyfun function to produce a comparison value. The comparison values
are compared with the testfun function. If keyfun is omitted, then the
untransformed elements themselves are compared, and if testfun is omitted,
then the equal function is used.

If <list1> contains duplicate elements which do not occur in list2 (and
thus are preserved in the set difference) then these duplicates appear
in the resulting list. Furthermore, the order of the items from list1 is
preserved.

.SS Functions mapcar, mappend, mapcar* and mappend*

.TP
Syntax:

  (mapcar <function> <list>*)
  (mappend <function> <list>*)
  (mapcar* <function> <list>*)
  (mappend* <function> <list>*)

.TP
Description:

When given only one argument, the mapcar function returns nil.
The <function> is never called.

When given two arguments, the mapcar function applies <function> to
the elements of <list> and returns a list of the resulting values.
Essentially, the list is filtered through the function.

When additional lists are given as arguments, this filtering behavior is
generalized in the following way: mapcar traverses the lists in parallel,
taking a value from each list as an argument to the function. If there
are two lists, the function is called with two arguments and so forth.
The process is limited by the length of the shortest list.
The return values of the function are collected into a new list which is
returned.

The mappend function works like mapcar, with the following difference.
Rather than accumulating the values returned by the function into a list,
mappend expects the items returned by the function to be lists which
are catenated with append, and the resulting list is returned.
That is to say, (mappend f a b c) is equivalent to
(apply (fun append) (mapcar f a b c)). 

The mapcar* and mappend* functions work like mapcar and mappend, respectively.
However, they return lazy lists rather than generating the entire
output list prior to returning.

.TP
Caveats:

Like mappend, mappend* must "consume" empty lists. For instance,
if the function being mapped puts out a sequence of nil values,
then the result must be the empty list nil, because
(append nil nil nil nil ...) is nil.

Suppose that mappend* is used on inputs which are infinite lazy
lists, such that the function returns nil values indefinitely.
For instance:

  ;; Danger: infinite loop!!!
  (mappend* (fun identity) (repeat '(nil))) 

The mappend* function is caught in a loop trying to consume
and squash an infinite stream of nil values.

.TP
Examples:

  ;; multiply every element by two
  (mapcar (lambda (item) (* 2 item)) '(1 2 3)) -> (4 6 8)

  ;; "zipper" two lists together
  (mapcar (lambda (le ri) (list le ri)) '(1 2 3) '(a b c)) '((1 a) (2 b) (3 c)))

  ;; like append, mappend allows a lone atom or a trailing atom:
  (mappend (fun identity) 3) -> (3)
  (mappend (fun identity) '((1) 2)) -> (1 . 2)

  ;; take just the even numbers
  (mappend (lambda (item) (if (evenp x) (list x))) '(1 2 3 4 5))
  -> (2 4)

.SS Function mapdo

.TP
Syntax:

  (mapdo <function> <sequence>*)

.TP
Description:

The mapdo function is similar to mapcar, but always returns nil.  It is useful
when <function> performs some kind of side effect, hence the "do" in the name,
which is a mnemonic for the execution of imperative actions.

When only the <function> argument is given, the function is never called,
and nil is returned.

If a single <sequence> argument is given, then mapdo iterates over
<sequence>, invoking <function> on each element.

If two or more <sequence> arguments are given, then mapdo iterates over
the sequences in parallel, extracting parallel tuples of items. These
tuples are passed as arguments to <function>, which must accept as many
arguments as there are sequences.

.SS Functions transpose and zip

.TP
Syntax:

  (transpose <sequence>)
  (zip <sequence>*)

.TP
Description:

The transpose function performs a transposition on <sequence>. This means that the
elements of <sequence> must be sequences.  These sequences are understood to be
columns; transpose exchanges rows and columns, returning a sequence of the rows
which make up the columns.  The returned sequence is of the same kind as
<sequence>, and the rows are also the same kind of sequence as the first column
of the original sequence. The number of rows returned is limited by the
shortest column among the sequences.

All of the input sequences (the elements of <sequence>) must have elements
which are compatible with the first sequence. This means that if the first
element of <sequence> is a string, then the remaining sequences must be
strings, or else sequences of characters, or of strings.

The zip function takes variable arguments, and is equivalent to calling
transpose on a list of the arguments. The following equivalences hold:

   (zip . x) <--> (transpose x)

   [apply zip x] <--> (transpose x)

.TP
Examples:

  ;; transpose list of lists
  (transpose '((a b c) (c d e))) ->  ((a c) (b d) (c e))

  ;; transpose vector of strings:
  ;; - string columns become string rows
  ;; - vector input becomes vector output
  (transpose #("abc" "def" "ghij")) -> #("adg" "beh" "cfi")

  ;; error: transpose wants to make a list of strings
  ;; but 1 is not a character
  (transpose #("abc" "def" '(1 2 3))) ;; error!

  ;; String elements are catenated:
  (transpose #("abc" "def" ("UV" "XY" "WZ"))) -> #("adUV" "beXY" "cfWZ")

  (zip '(a b c) '(c d e)) ->  ((a c) (b d) (c e))

.SS Function interpose

.TP
Syntax:

  (interpose <sep> <sequence>)

.TP
Description:

The interpose function returns a sequence of the same type as <sequence>,
in which the elements from <sequence> appear with the <sep> value inserted
between them.

If <sequence> is an empty sequence or a sequence of length 1, then a
sequence identical to <sequence> is returned. It may be a copy of <sequence>
or it may be <sequence> itself.

If <sequence> is a character string, then the value <sep> must be a character.

It is permissible for <sequence>, or for a suffix of <sequence> to be a lazy
list, in which case interpose returns a lazy list, or a list with a lazy
suffix.

.SS
Examples:

  (interpose #\e- "xyz") -> "x-y-z"
  (interpose t nil) -> nil
  (interpose t #()) -> #()
  (interpose #\ea "") -> ""
  (interpose t (range 0 0)) -> (0)
  (interpose t (range 0 1)) -> (0 t 1)
  (interpose t (range 0 2)) -> (0 t 1 t 2)

.SS Functions conses and conses*

.TP
Syntax:

  (conses <list>)
  (conses* <list>)

.TP
Description:

These functions return a list whose elements are the conses which make
up <list>. The conses* function does this in a lazy way, avoiding the
computation of the entire list: it returns a lazy list of the conses of <list>.
The conses function computes the entire list before returning.

The input <list> may be proper or improper.

The first cons of a list is that list itself. The second cons is the rest
of the list, or (cdr <list>). The third cons is (cdr (cdr <list>)) and so on.

.TP
Example:

  (conses '(1 2 3)) -> ((1 2 3) (2 3) (3))

.TP
Dialect Note:

These functions are useful for simulating the maplist function found in
other dialects like Common Lisp. 

TXR Lisp's (conses x) can be expressed in Common Lisp as
(maplist #'identity x).

Conversely, the Common Lisp operation (maplist function list) can be computed
in TXR Lisp as (mapcar function (conses list)).

More generally, the Common Lisp operation

  (maplist function list0 list1 ... listn)
  
can be expressed as:

  (mapcar function (conses list0) (conses list1) ... (conses listn))

.SS Functions apply and iapply

.TP
Syntax:

  (apply <function> [ <arg>* <trailing-args> ])
  (iapply <function> [ <arg>* <trailing-args> ])

.TP
Description:

The apply function invokes <function>, optionally passing to it an argument
list. The return value of the apply call is that of <function>.

If no arguments are present after <function>, then <function> is invoked
without arguments.

If one argument is present after <function>, then it is interpreted as
<trailing-args>. If this is a sequence (a list, vector or string),
then the elements of the sequence are passed as individual arguments to
<function>.  If <trailing-args> is not a sequence, then the function is invoked
with an improper argument list, terminated by the <trailing-args> atom.

If two or more arguments are present after <function>, then the last of
these arguments is interpreted as <trailing-args>. The previous arguments
represent leading arguments which are applied to <function>, prior to the
arguments taken from <trailing-args>.

The iapply function ("improper apply") is similar to apply, except with regard
to the treatment of <trailing-args>. Firstly, under iapply, if <trailing-args>
is an atom other than nil (possibly a sequence, such as a vector or string),
then it is treated as an ordinary argument: <function> is invoked with a proper
argument list, whose last element is <trailing-args>.  Secondly, if
<trailing-args> is a list, but an improper list, then the terminating atom of
<trailing-args> becomes an ordinary argument. Thus, in all possible cases,
iapply treats an extra non-nil atom as an argument, and never calls
<function> with an improper argument list.

.TP
Examples:

  ;; '(1 2 3) becomes arguments to list, thus (list 1 2 3).
  (apply (fun list) '(1 2 3)) -> (1 2 3)

  ;; this effectively invokes (list 1 2 3 4)
  (apply (fun list) 1 2 '(3 4)) -> (1 2 3)

  ;; this effectively invokes (list 1 2 . 3)
  (apply (fun list) 1 2 3)) -> (1 2 . 3)

  ;; "abc" is separated into characters which become arguments of list
  (apply (fun list) "abc") -> (#\ea #\eb #\ec)

.TP
Dialect Note:

Note that some uses of this function that are necessary in other Lisp dialects
are not necessary in TXR Lisp. The reason is that in TXR Lisp, improper list
syntax is accepted as a compound form, and performs application:

  (foo a b . x)

Here, the variables a and b supply the first two arguments for foo. In
the dotted position, x must evaluate to a list or vector. The list or
vector's elements are pulled out and treated as additional arguments for foo.
Of course, this syntax can only be used if x is a symbolic form or an atom.  It
cannot be a compound form.

.SS Functions reduce-left and reduce-right

.TP
Syntax:

  (reduce-left <binary-function> <list> [ <init-value> [ <key-function> ]])
  (reduce-right <binary-function> <list> [ <init-value> [ <key-function> ]])

.TP
Description:

The reduce-left and reduce-right functions reduce lists of operands specified
by <list> and <init-value> to a single value by the repeated application of
<binary-function>. 

An effective list of operands is formed by combining <list> and
<init-value>.   If <key-function> is specified, then the items of <list> are
mapped to a new values through <key-function>.  If <init-value> is supplied,
then in the case of reduce-left, the effective list of operands is formed by
prepending <init-value> to <list>. In the case of reduce-right, the effective
operand list is produced by appending <init-value> to <list>.

The production of the effective list can be expressed like this,
though this is not to be understood as the actual implementation:

  ;; reduce-left
  (let ((eff-list (append (if init-value-present (list init-value))
                          [mapcar (or key-function identity) list])))

In the reduce-right case, the arguments to append are reversed.

If the effective list of operands is empty, then <binary-function> is called
with no arguments at all, and its value is returned. This is the only
case in which <binary-function> is called with no arguments; in all
remaining cases, it is called with two arguments.

If the effective list contains one item, then that item is returned.

Otherwise, the effective list contains two or more items, and is decimated as
follows. 

Note that an <init-value> specified as nil is not the same as a missing
<init-value>; this means that the initial value is the object nil.  Omitting
<init-value> is the same as specifying a value of : (the colon symbol).
It is possible to specify <key-function> while omitting an <init-value>
argument. This is achieved by explicitly specifying : as the <init-value>
argument.

Under reduce-left, the leftmost pair of operands is removed
from the list and passed as arguments to <binary-function>, in the same order
that they appear in the list, and the resulting value initializes an
accumulator. Then, for each remaining item in the list, <binary-function> is
invoked on two arguments: the current accumulator value, and the next element
from the list. After each call, the accumulator is updated with the return
value of <binary-function>.  The final value of the accumulator is returned.

Under reduce-right, the list is processed right to left.  The rightmost
pair of elements in the effective list is removed, and passed as arguments to
<binary-function>, in the same order that they appear in the list. The
resulting value initializes an accumulator. Then, for each remaining item in
the list, <binary-function> is invoked on two arguments:  the
next element from the list, in right to left order, and the current
accumulator value. After each call, the accumulator is updated with the return
value of <binary-function>. The final value of the accumulator is returned.

.TP
Examples:

  ;;; effective list is (1) so 1 is returned
  (reduce-left (fun +) () 1 nil)  ->  1  

  ;;; computes (- (- (- 0 1) 2) 3) 
  (reduce-left (fun -) '(1 2 3) 0 nil) -> -6

  ;;; computes (- 1 (- 2 (- 3 0)))
  (reduce-right (fun -) '(1 2 3) 0 nil) -> 2

  ;;; computes (* 1 2 3)
  (reduce-left (fun *) '((1) (2) (3)) nil (fun first)) -> 6

  ;;; computes 1 because the effective list is empty
  ;;; and so * is called with no arguments, which yields 1.
  (reduce-left (fun *) nil)

.SS Function some, all and none

.TP
Syntax:

  (some <list> [ <predicate-fun> [<key-fun>] ])
  (all <list> [ <predicate-fun> [<key-fun>] ])
  (none <list> [ <predicate-fun> [<key-fun>] ])

.TP
Description

The some, all and none functions apply a predicate test function
<predicate-fun> over a list of elements.  If the argument <key-fun> is
specified, then values <list> are passed into <key-fun>, and <predicate-fun> is
applied to the resulting values. If <key-fun> is omitted, the behavior is
as if <key-fun> is the identity function. If <predicate-fun> is omitted,
the behavior is as if <predicate-fun> is the identity function.

These functions have short-circuiting semantics and return conventions similar
to the and and or operators.

The some function applies <predicate-fun> to successive values
produced by retrieving elements of <list> and processing them through
<key-fun>. If the list is empty, it returns nil. Otherwise it returns the
first non-nil return value returned by a call to <predicate-fun> and
stops evaluating more elements. If <predicate-fun> returns nil for all
elements, it returns nil.

The all function applies <predicate-fun> to successive values
produced by retrieving elements of <list> and processing them through
<key-fun>. If the list is empty, it returns t. Otherwise, if
<predicate-fun> yields nil for any value,  the all function immediately
returns without invoking <predicate-fun> on any more elements.
If all the elements are processed, then the all function returns
the value which <predicate-fun> yielded for the last element.

The none function applies <predicate-fun> to successive values
produced by retrieving elements of <list> and processing them through
<key-fun>. If the list is empty, it returns t. Otherwise, if
<predicate-fun> yields  non-nil for any value, the none function
immediately returns nil. If <predicate-fun> yields nil for all
values, the none function returns t.

.TP
Examples:

  ;; some of the integers are odd
  [some '(2 4 6 9) oddp] -> t

  ;; none of the integers are even
  [none '(1 3 4 7) evenp] -> t

.SS Function multi

.TP
Syntax:

  (multi <function> <list>*)

.TP
Description:

The multi function distributes an arbitrary list processing function <multi>
over multiple lists given by the <list> arguments.

The <list> arguments are first transposed into a single list of tuples. Each
successive element of this transposed list consists of a combination of the
successive items from the lists. The length of the transposed list is that
of the shortest <list> argument.

The transposed list is then passed to <function> as an argument.

The <function> is expected to produce a list of tuples, which are transposed
again to produce a list of lists which is then returned.

Conceptually, the input lists are columns and <function> is invoked on
a list of the rows formed from these columns. The output of <function>
is a transformed list of rows which is reconstituted into a list of columns.

.TP
Example:

  ;; Take three lists in parallel, and remove from all of them
  ;; them the element at all positions where the third list
  ;; has an element of 20.

  (multi (op remove-if (op eql 20) @1 third)
         '(1 2 3)
         '(a b c)
         '(10 20 30))

  -> ((1 3) (a c) (10 30))

  ;; The (2 b 20) "row" is gone from the three "columns".

  ;; Note that the (op remove if (op eql 20) @1 third)
  ;; expression can be simplified using the ap operator:
  ;;
  ;; (op remove-if (ap eql @3 20))

.SH ASSOCIATION LISTS

Association lists are ordinary lists formed according to a special convention.
Firstly, any empty list is a valid association list. A non-empty association
list contains only cons cells as the key elements. These cons cells are
understood to represent key/value associations, hence the name "association
list".

.SS Function assoc

.TP
Syntax:

  (assoc <key> <alist>)

.TP
Description:

The assoc function searches an association list <alist> for a cons cell whose
car field is equivalent to <key> (with equality determined by the equal
function). The first such cons is returned. If no such cons is found, nil is
returned.

.SS Function assql

.TP
Syntax:

  (assql <key> <alist>)

.TP
Description:

The assql function is just like assoc, except that the equality test
is determined using the eql function rather than equal.

.SS Function acons

.TP
Syntax:

  (acons <car> <cdr> <alist>)

.TP
Description:

The acons function constructs a new alist by consing a new cons to the
front of <alist>. The following equivalence holds:

  (acons car cdr alist) <--> (cons (cons car cdr) alist)

.SS Function acons-new

.TP
Syntax:

  (acons-new <car> <cdr> <alist>)

.TP
Description:

The acons-new function searches <alist>, as if using the assoc function,
for an existing cell which matches the key provided by the car argument.
If such a cell exists, then its cdr field is overwritten with the <cdr>
argument, and then the list is returned. If no such cell exists, then
a new list is returned by adding a new cell to the input list consisting
of the <car> and <cdr> values, as if by the acons function.

.SS Function aconsql-new

.TP
Syntax:

  (aconsql-new <car> <cdr> <alist>)

.TP
Description:

This function is like acons-new, except that the eql function is used
for equality testing. Thus, the list is searched for an existing cell
as if using the assql function rather than assoc.

.SS Function alist-remove

.TP
Syntax:

  (alist-remove <alist> <keys>)

.TP
Description:

The alist-remove function takes association list <alist> and produces a
duplicate from which cells matching the specified keys have been removed. The
<keys> argument is a list of the keys not to appear in the output list.

.SS Function alist-nremove

.TP
Syntax:

  (alist-nremove <alist> <keys>)

.TP
Description:

The alist-nremove function is like alist-remove, but potentially destructive.
The input list <alist> may be destroyed and its structural material re-used to
form the output list. The application should not retain references to the input
list.

.SS Function copy-alist

.TP
Syntax:

  (copy-alist <alist>)

.TP
Description:

The copy-alist function duplicates <alist>. Unlike copy-list, which
only duplicates list structure, copy-alist also duplicates each cons
cell of the input alist. That is to say, each element of the output list
is produced as if by the copy-cons function applied to the corresponding
element of the input list.

.SH PROPERTY LISTS

.SS Function prop

.TP
Syntax:

  (prop <plist> <key>)

.TP
Description:

A property list a flat list of even length consisting of interleaved
pairs of property names (usually symbols) and their values (arbitrary
objects). An example property list is (:a 1 :b "two") which contains
two properties, :a having value 1, and :b having value "two".

The prop function searches property list <plist> for key <key>. If
the key is found, then the value next to it is returned. Otherwise
nil is returned.

It is ambiguous whether nil is returned due to the property not being
found, or due to the property being present with a nil value.

.SH LIST SORTING

.SS Function merge

.TP
Syntax:

  (merge <list1> <list2> <lessfun> [<keyfun>])

.TP
Description:

The merge function merges two sorted lists <list1> and <list2> into a single
sorted list. The semantics and defaulting behavior of the <lessfun> and
<keyfun> arguments are the same as those of the sort function. The input lists
are assumed to be sorted according to these functions.

This function is destructive. The application should not retain references to
the input lists, since the output list is formed out of the structure of the
input lists.

.SS Function multi-sort

.TP
Syntax:

  (multi-sort <columns> <less-funcs> [<key-funcs>])

.TP
Description:

The multi-sort function regards a list of lists to be the columns of a
database. The corresponding elements from each list constitute a record.
These records are to be sorted, producing a new list of lists.

The <columns> argument supplies the list of lists which comprise the columns of
the database. The lists should ideally be of the same length. If the lists are
of different lengths, then the shortest list is taken to be the length of the
database. Excess elements in the longer lists are ignored, and do not appear in
the sorted output.

The <less-funcs> argument supplies a list of comparison functions which are 
applied to the columns. Successive functions correspond to successive
columns. If <less-funcs> is an empty list, then the sorted database will
emerge in the original order. If <less-funcs> contains exactly one function,
then the rows of the database is sorted according to the first column. The
remaining columns simply follow their row. If <less-funcs> contains more than
one function, then additional columns are taken into consideration if the items
in the previous columns compare equal. For instance if two elements from column
one compare equal, then the corresponding second column elements are compared
using the second column comparison function.

The optional <key-funcs> argument supplies transformation functions through
which column entries are converted to comparison keys, similarly to the single
key function used in the sort function and others.  If there are more key
functions than less functions, the excess key functions are ignored.

.SH LAZY LISTS AND LAZY EVALUATION

.SS Function make-lazy-cons

.TP
Syntax:

(make-lazy-cons <function>)

.TP
Description:

The function make-lazy-cons makes a special kind of cons cell called a lazy
cons, or lcons.  Lazy conses are useful for implementing lazy lists.

Lazy lists are lists which are not allocated all at once. Rather,
their elements materialize when they are accessed, like
magic stepping stones appearing under one's feet out of thin air.

A lazy cons has "car" and "cdr" fields like a regular cons, and those
fields are initialized to nil when the lazy cons is created. A lazy cons also
has an update function, the one which is provided as the <function>
argument to make-lazy-cons.

When either the car and cdr fields of a cons are accessed for the first time,
the function is automatically invoked first. That function has the opportunity
to initialize the car and cdr fields. Once the function is called, it is removed
from the lazy cons: the lazy cons no longer has an update function.

To continue a lazy list, the function can make another call to make-lazy-cons
and install the resulting cons as the cdr of the lazy cons.

.TP
Example:

  ;;; lazy list of integers between min and max
  (defun integer-range (min max)
    (let ((counter min))
      ;; min is greater than max; just return empty list,
      ;; otherwise return a lazy list
      (if (> min max)
        nil
        (make-lazy-cons (lambda (lcons)
                          ;; install next number into car
                          (rplaca lcons counter)
                          ;; now deal wit cdr field
                          (cond
                             ;; max reached, terminate list with nil!
                            ((eql counter max) 
                             (rplacd lcons nil))
                            ;; max not reached: increment counter
                            ;; and extend with another lazy cons
                            (t
                             (inc counter)
                             (rplacd lcons (make-lazy-cons 
                                            (lcons-fun lcons))))))))))

.SS Function lconsp

.TP
Syntax:

  (lconsp <value>)

.TP
Description:

The lconsp function returns t if <value> is a lazy cons cell. Otherwise
it returns nil, even if <value> is an ordinary cons cell.

.SS Function lcons-fun

.TP
Syntax:

(lcons-fun <lazy-cons>)

.TP
Description:

The lcons-fun function retrieves the update function of a lazy cons.
Once a lazy cons has been accessed, it no longer has an update function
and lcons-fun returns nil.  While the update function of a lazy cons is
executing, it is still accessible. This allows the update function
to retrieve a reference to itself and propagate itself into
another lazy cons (as in the example under make-lazy-cons).

.SS Functions lazy-stream-cons and get-lines

.TP
Syntax:

  (lazy-stream-cons <stream>)
  (get-lines <stream>)

.TP
Description:

The lazy-stream-cons and get-lines functions are synonyms. Thus, the following
description of lazy-stream-cons also applies to get-lines.

The lazy-stream-cons returns a lazy cons which generates a lazy list based on
reading lines of text from input stream <stream>, which form the elements of
the list. The get-line function is called on demand to add elements to the
list.

The lazy-stream-cons function itself makes the first call to get-line
on the stream. If this returns nil, then the stream is closed and nil is
returned. Otherwise, a lazy cons is returned whose update function will install
that line into the car field of the lazy cons, and continue the lazy list
by making another call to lazy-stream-cons, installing the result into the
cdr field.

the string returned by get-line, and whose cdr contains the lazy function.

The lazy-stream-cons function inspects the real-time property of a stream
as if by the real-time-stream-p function. This determines which of two
styles of lazy list are returned. For an ordinary (non-real-time) stream,
the lazy list treats the end-of-file condition accurately: an empty
file turns into the empty list nil, a one line file into a one-element
list which contains that line and so on. This accuracy requries one
line of lookahead which is not acceptable in real-time streams. For real-time
streams, the lazy list will generate an extra nil item after the last
line, and so an empty input source translates to the list (nil).

.SS Macro delay

.TP
Syntax:

  (delay <expression>)

.TP
Description:

The delay operator arranges for the delayed (or "lazy") evaluation of
<expression>. This means that the expression is not evaluated immediately.
Rather, the delay expression produces a promise object.

The promise object can later be passed to the force function (described
later in this document). The force function will trigger the evaluation
of the expression and retrieve the value.

The expression is evaluated in the original scope, no mater where
the force takes place.

The expression is evaluated at most once, by the first call to force.
Additional calls to force only retrieve a cached value.

.TP
Example:

  @(do
    ;; list is popped only once: the value is computed
    ;; just once when force is called on a given promise
    ;; for the first time.

    (defun get-it (promise)
      (format t "*list* is ~s\en" *list*)
      (format t "item is ~s\en" (force promise))
      (format t "item is ~s\en" (force promise))
      (format t "*list* is ~s\en" *list*))


    (defvar *list* '(1 2 3))

    (get-it (delay (pop *list*))))

  Output:

  *list* is (1 2 3)
  item is 1
  item is 1
  *list* is (2 3)

.SS Function force

.TP
Syntax:

  (force <promise>)

.TP
Description:

The force function accepts a promise object produced by the delay macro.
The first time force is invoked <promise>, the promise expression
is evaluated (in its original lexical environment, regardless of where
in the program the force call takes place). The value of the expression is
cached inside <promise> and returned, becoming the return value of the
force function call.  If the force function is invoked additional times on
the same promise, the cached value is retrieved.

.SH LAZY SEQUENCES, RANGES, PERMUTATIONS AND COMBINATIONS

.SS Functions generate and giterate

.TP
Syntax:

  (generate <while-fun> <gen-fun>)
  (giterate <while-fun> <gen-fun> [<value>])

.TP
Description:

The generate function produces a lazy list which dynamically produces items
according to the following logic.

The arguments to generate are functions which do not take any arguments.  The
return value of generate is a lazy list.

When the lazy list is accessed, for instance with the functions car and cdr, it
produces items on demand. Prior to producing each item, <while-fun> is
called. If it returns a true boolean value (any value other than nil), then
the <gen-fun> function is called, and its return value is incorporated as
the next item of the lazy list. But if <while-fun> yields nil, then the lazy
list immediately terminates.

Prior to returning the lazy list, generate invokes the <while-fun> one time.
If while-fun yields nil, then generate returns the empty list nil instead
of a lazy list. Otherwise, it instantiates a lazy list, and invokes
the gen-func to populate it with the first item.

The giterate function is similar to generate, except that <while-fun>
and <gen-fun> are functions of one argument rather than functions of
no arguments. The optional <value> argument defaults to nil and
is threaded through the function calls. That is to say, the lazy
list returned is (<value> [<gen-fun <value>] [<gen-fun> [<gen-fun> <value>]] ...).

The lazy list terminates when a value fails to satsify <while-fun>.
That is to say, prior to generating each value, the lazy list tests
the value using <while-fun>. If that function returns false, then
the item is not added, and the sequence terminates.

Note: the giterate function could be written in terms of generate
like this:

  (defun giterate (w g v)
     (generate (lambda () [w v]) (lambda () (prog1 v (set v [g v])))))

.SS
Example:

  (giterate (op > 5) (op + 1) 0) -> (0 1 2 3 4)

.SS Function repeat


Syntax:

  (repeat <list> [<count>])

.TP
Description:

If <list> is empty, then repeat returns an empty list.

If <count> is omitted, the repeat function produces an infinite lazy list
formed by catenating together copies of <list>.

If <count> is specified and is zero or negative, then an empty list is
returned.

Otherwise a list is returned consisting of <count> repetitions of <list>
catenated together.

.SS Macros gen and gun

.TP
Syntax:

  (gen <while-expression> <produce-item-expression>)
  (gun <produce-item-expression>)

.TP
Description:

The gen macro operator produces a lazy list, in a manner similar to the
generate function. Whereas the generate function takes functional arguments,
the gen operator takes two expressions, which is often more convenient.

The return value of gen is a lazy list. When the lazy list is accessed, for
instance with the functions car and cdr, it produces items on demand. Prior to
producing each item, the <while-expression> is evaluated, in its original
lexical scope.  If the expression yields a true value (non-nil), then
<produce-item-expression> is evaluated, and its return value is incorporated as
the next item of the lazy list. If the expression yields nil, then the lazy
list immediately terminates.

The gen operator itself immediately evaluates <while-expression> before
producing the lazy list. If the expression yields nil, then the operator
returns the empty list nil. Otherwise, it instantiates the lazy list and
invokes the <produce-item-expression> to force the first item.

The gun macro similarly creates a lazy list according to the following
rules. Each successive item of the lazy list is obtained as a result of
evaluating <produce-item-expression>. However, when <produce-item-expression>
yields nil, then the list terminates (without adding that nil as an item).

Note 1: the form gun can be implemented as a macro-expanding to
an instance of the gen operator, like this:

  (defmacro gun (expr)
    (let ((var (gensym)))
      ^(let (,var)
         (gen (set ,var ,expr)
              ,var))))

This exploits the fact that the set operator returns the value that is
assigned, so the set expression is tested as a condition by gen,
while having the side effect of storing the next item temporarily
in a hidden variable.

In turn, gen can be implemented as a macro expanding to some lambda
functions which are passed to the generate function:

  (defmacro gen (while-expr produce-expr)
    ^(generate (lambda () ,while-expr) (lambda () ,produce-expr)))

Note 2: GEN can be considered as an acronym for Generate, testing Expression
before Next item, whereas GUN stands for Generate Until Null.

.TP

Example:

  @(do
    ;; Make a lazy list of integers up to 1000
    ;; access and print the first three.
    (let* ((counter 0)
           (list (gen (< counter 1000) (inc counter))))
      (format t "~s ~s ~s\en" (pop list) (pop list) (pop list))))

  Output:
  1 2 3

.SS Functions range and range*

.TP
Syntax:

  (range [ [ [ <from> ] <to> ] <step> ])
  (range* [ [ [ <from> ] <to> ] <step> ])

.TP
Description:

The range and range* functions generate a lazy sequence of integers, with a
fixed step between successive values.

The difference between range and range* is that range* excludes the endpoint.
For instance (range 0 3) generates the list (0 1 2 3), whereas (range* 0 3)
generates (0 1 2).

All arguments are optional. If the <step> argument is omitted, then it defaults
to 1: each value in the sequence is greater than the previous one by 1.
Positive or negative step sizes are allowed. There is no check for a step size
of zero, or for a step direction which cannot meet the endpoint.

The <to> argument specifies the endpoint value, which, if it occurs in the
sequence, is excluded from it by the range* function, but included by the range
function. If <to> is missing, or specified as nil, then there is no endpoint,
and the sequence which is generated is infinite, regardless of <step>.

If <from> is omitted, then the sequence begins at zero, otherwise <from> must
be an integer which specifies the initial value.

The sequence stops if it reaches the endpoint value (which is included in the
case of range, and excluded in the case of range*).  However, a sequence with a
stepsize greater than 1 or less than -1 might step over the endpoint value, and
therefore never attain it. In this situation, the sequence also stops, and the
excess value which surpasses the endpoint is excluded from the sequence.

.SS Function perm

.TP
Syntax:

  (perm <seq> [<len>])

.TP
Description:

The rperm function returns a lazy list which consists of all
length <len> permutations of formed by items taken from <seq>. 
The permutations do not use any element of <seq> more than once.

Argument <len>, if present, must be a positive integer, and <seq> must be a
sequence.

If <len> is not present, then its value defaults to the length of <seq>:
the list of the full permutations of the entire sequence is returned.

The permutations in the returned list are sequences of the same kind as <seq>.

If <len> is zero, then a list containing one permutation is returned, and that
permutations is of zero length.

If <len> exceeds the length of <seq>, then an empty list is returned,
since it is impossible to make a single non-repeating permutation that
requires more items than are available.

The permutations are lexicographically ordered.

.SS Function rperm

.TP
Syntax:

  (rperm <seq> <len>)

.TP
Description:

The rperm function returns a lazy list which consists of all the repeating
permutations of length <len> formed by items taken from <seq>. 
"Repeating" means that the items from <seq> can appear more than
once in the permutations.

The permutations which are returned are sequences of the same kind as <seq>.

Argument <len> must be a nonnegative integer, and <seq> must be a sequence.

If <len> is zero, then a single permutation is returned, of zero length.
This is true regardless of whether <seq> is itself empty.

If <seq> is empty and <len> is greater than zero, then no permutations are
returned, since permutations of a positive length require items, and the
sequence has no items. Thus there exist no such permutations.

The first permutation consists of <len> repetitions of the first element of
<seq>. The next repetition, if there is one, differs from the first
repetition in that its last element is the second element of <seq>.
That is to say, the permutations are lexicographically ordered.

.TP
Examples:

  (rperm "01" 4) -> ("000" "001" "010" "011" "100" "101" "110" "111")

  (rperm #(1) 3) -> (#(1 1 1))

  (rperm '(0 1 2) 2) -> ((0 0) (0 1) (0 2) (1 0) (1 1) (1 2) (2 0) (2 1) (2 2))


.SS Function comb

.TP
Syntax:

  (comb <seq> <len>)

.TP
Description:

The comb function returns a lazy list which consists of all
length <len> non-repeating combinations formed by taking items taken from
<seq>.  "Non-repeating combinations" means that the combinations do not use any
element of <seq> more than once. If <seq> contains no duplicates, then
the combinations contain no duplicates.

Argument <len> must be a nonnegative integer, and <seq> must be a sequence
or a hash table.

The combinations in the returned list are objects of the same kind as <seq>.

If <len> is zero, then a list containing one combination is returned, and that
permutations is of zero length.

If <len> exceeds the number of elements in <seq>, then an empty list is
returned, since it is impossible to make a single non-repeating combination
that requires more items than are available.

If <seq> is a sequence, the returned combinations are lexicographically ordered.
This requirement is not applicable when <seq> is a hash table.

.SS Function rcomb

.TP
Syntax:

  (rcomb <seq> <len>)

.TP
Description:

The comb function returns a lazy list which consists of all
length <len> repeating combinations formed by taking items taken from
<seq>.  "Repeating combinations" means that the combinations can use
an element of <seq> more than once.

Argument <len> must be a nonnegative integer, and <seq> must be a sequence.

The combinations in the returned list are sequences of the same kind as <seq>.

If <len> is zero, then a list containing one combination is returned, and that
permutations is of zero length. This is true even if <seq> is empty.

If <seq> is empty, and <len> is nonzero, then an empty list is returned.

The combinations are lexicographically ordered.

.SH CHARACTERS AND STRINGS

.SS Function mkstring

.TP
Syntax:

  (mkstring <length> <char>)

.TP
Description:

The mkstring function constructs a string object of a length specified
by the <length> parameter.  Every position in the string is initialized 
with <char>, which must be a character value.

.SS Function copy-str

.TP
Syntax:

  (copy-str <string>)

.TP
Description:

The copy-str function constructs a new string whose contents are identical
to <string>.

.SS Function upcase-str

.TP
Syntax:

  (upcase-str <string>)

.TP
Description:

The upcase-str function produces a copy of <string> such that all lower-case
characters of the English alphabet are mapped to their upper case counterparts.

.SS Function downcase-str

.TP
Syntax:

  (downcase-str <string>)

.TP
Description:

The downcase-str function produces a copy of <string> such that
all upper case characters of the English alphabet are mapped to their
lower case counterparts.

.SS Function string-extend

.TP
Syntax:

  (string-extend <string> <tail>)

.TP
Description:

The string-extend function destructively increases the length of <string>,
which must be an ordinary dynamic string.  It is an error to invoke this
function on a literal string or a lazy string.

The <tail> argument can be a character, string or integer. If it is a string or
character, it specifies material which is to be added to the end of the string:
either a single character or a sequence of characters. If it is an integer, it
specifies the number of characters to be added to the string.

If <tail> is an integer, the newly added characters have indeterminate contents.
The string appears to be the original one because of an internal terminating
null character remains in place, but the characters beyond the terminating zero
are indeterminate.

.SS Function stringp

.TP
Syntax:

  (stringp <obj>)

.TP
Description:

The stringp function returns t if <obj> is one of the several
kinds of strings. Otherwise it returns nil.

.SS Function length-str

.TP
Syntax:

  (length-str <string>)

.TP
Description:

The length-str function returns the length <string> in characters.
The argument must be a string.

.SS Function search-str

.TP
Syntax:

  (search-str <haystack> <needle> [<start> [<from-end>]])

.TP
Description:

The search-str function finds an occurrence of the string <needle> inside
the <haystack> string and returns its position. If no such occurrence exists,
it returns nil.

If a <start> argument is not specified, it defaults to zero. If it is
a non-negative integer, it specifies the starting character position for
the search.  Negative values of <start> indicate positions from the end of the
string, such that -1 is the last character of the string.

If the <from-end> argument is specified and is not nil, it means
that the search is conducted right-to-left. If multiple matches are possible,
it will find the rightmost one rather than the leftmost one.

.SS Function search-str-tree

.TP
Syntax:

  (search-str-tree <haystack> <tree> [<start> [<from-end>]])

.TP
Description:

The search-str-tree function is similar to search-str, except that instead of
searching <haystack> for the occurrence of a single needle string, it searches
for the occurrence of numerous strings at the same time.  These search strings
are specified, via the <tree> argument, as an arbitrarily structured tree whose
leaves are strings.

The function finds the earliest possible match, in the given search direction,
from among all of the needle strings.

If <tree> is a single string, the semantics is equivalent to
search-str.

.SS Function match-str

.TP
Syntax:

  (match-str <bigstring> <littlestring> [<start>])

.TP
Description:

Without the <start> argument, the match-str function determines whether
<littlestring> is a prefix of <bigstring>, returning a t or nil
indication.

If the <start> argument is specified, and is a non-negative integer, then the
function tests whether <littlestring> matches a prefix of that portion of
<bigstring> which starts at the given position.

If the <start> argument is a negative integer, then match-str determines
whether <littlestring> is a suffix of <bigstring>, ending on that position
of bigstring, where -1 denotes the last character of <bigstring>,
-2 the second last one and so on.

If <start> is -1, then this corresponds to testing whether <littlestring>
is a suffix of <bigstring>.

.SS Function match-str-tree

.TP
Syntax:

  (match-str-tree <bigstring> <tree> [<start>])

.TP
Description:

The match-str-tree function is a generalization of match-str which matches
multiple test strings against <bigstring> at the same time. The value
reported is the longest match from among any of the strings.

The strings are specified as an arbitrarily shaped tree structure which has
strings at the leaves.

If <tree> is a single string atom, then the function behaves
exactly like match-str.

.SS Function sub-str

.TP
Syntax:

  (sub-str <string> [<from> [<to>]])

.TP
Description:

The sub-str function is like the more generic function sub, except that it
operates only on strings.  For a description of the arguments and semantics,
refer to the sub function.

.SS Function replace-str

.TP
Syntax:

  (replace-str <string> <item-sequence> [<from> [<to>]])

.TP
Description:

The replace-str function is like the replace function, except that the first
argument must be a string.

For a description of the arguments and semantics, refer to the replace function.

.SS Function cat-str

.TP
Syntax:

  (cat-str <string-list> [<sep-string>])

.TP
Description:

The cat-str function catenates a list of strings given by <string-list> into a
single string.  The optional <sep-string> argument specifies a separator string
which is interposed between the catenated strings.

.SS Function split-str

.TP
Syntax:

  (split-str <string> <sep>)

.TP
Description:

The split-str function breaks the <string> into pieces, returning a list
thereof. The <sep> argument must be either a string or a regular expression.
It specifies the separator character sequence within <string>. 

All non-overlapping matches for <sep> within <string> are identified in left
to right order, and are removed from <string>. The string is broken into pieces
according to the gaps left behind by the removed separators, and a list
of the remaining pieces is returned.

If a match for <sep> is not found in the string at all, then the string is not
split at all: a list of one element is returned containing the original
string.

If <sep> matches the entire string, then a list of two empty strings is
returned, except in the case that the original string is empty, in which case a
list of one element is returned, containing the empty string.

Whenever two adjacent matches for <sep> occur, they are considered separate
cuts with an empty piece between them.

This operation is nondestructive: <string> is not modified in any way.

.SS Function split-str-set

.TP
Syntax:

  (split-str-set <string> <set>)

.TP
Description:

The split-str-set function breaks the <string> into pieces, returning a list
thereof. The <sep> argument must be a string. It specifies a set of
characters.  All occurrences of any of these characters within <string> are
identified, and are removed from <string>. The string is broken into pieces
according to the gaps left behind by the removed separators.

Adjacent occurrences of characters from <set> within <string> are considered to
be separate gaps which come between empty strings.

This operation is nondestructive: <string> is not modified in any way.

.SS Functions tok-str and tok-where

.TP
Syntax:

  (tok-str <string> <regex> [<keep-between>])
  (tok-where <string> <regex>)

.TP
Description:

The tok-str function searches <string> for tokens, which are defined as
substrings of <string> which match the regular expression <regex> in the
longest possible way, and do not overlap. These tokens are extracted from the 
string and returned as a list.

Whenever <regex> matches an empty string, then an empty token is returned, and
the search for another token within <string> resumes after advancing by one
character position. So for instance, (tok-str "abc" #/a?/) returns the
list ("a" "" "" ""). After the token "a" is extracted from a non-empty match
for the regex, the regex is considered to match three more times: before the
"b", between "b" and "c", and after the "c".

If the <keep-between> argument is specified, and is not nil, then the behavior
of tok-str changes in the following way. The pieces of <string> which are
skipped by the search for tokens are included in the output. If no token is
found in <string>, then a list of one element is returned, containing <string>.
Generally, if N tokens are found, then the returned list consists of 2N + 1
elements. The first element of the list is the (possibly empty) substring which
had to be skipped to find the first token. Then the token follows. The next
element is the next skipped substring and so on. The last element is the
substring of <string> between the last token and the end.

The tok-where function works similarly to tok-str, but instead of returning
the extracted tokens themselves, it returns a list of the character position
ranges within <string> where matches for <regex> occur. The ranges
are pairs of numbers, represented as cons cells, where the first number
of the pair gives the starting character position, and the second number
is one position past the end of the match.  If a match is empty, then the
two numbers are equal.

The tok-where function does not support the <keep-between> parameter.

.SS Function list-str

.TP
Syntax:

  (list-str <string>)

.TP
Description:

The list-str function converts a string into a list of characters.

.SS Function trim-str

.TP
Syntax:

  (trim-str <string>)

.TP
Description:

The trim-str function produces a copy of <string> from which leading and
trailing whitespace is removed. Whitespace consists of spaces, tabs,
carriage returns, linefeeds, vertical tabs and form feeds.

.SS Function chrp

.TP
Syntax:

  (chrp <obj>)

.TP
Description:

Returns t if <obj> is a character, otherwise nil.

.SS Function chr-isalnum

.TP
Syntax:

  (chr-isalnum <char>)

.TP
Description:

Returns t if <char> is an alpha-numeric character, otherwise nil. Alpha-numeric
means one of the upper or lower case letters of the English alphabet found in
ASCII, or an ASCII digit. This function is not affected by locale.

.SS Function chr-isalpha

.TP
Syntax:

  (chr-isalpha <char>)

.TP
Description:

Returns t if <char> is an alphabetic character, otherwise nil. Alphabetic
means one of the upper or lower case letters of the English alphabet found in
ASCII. This function is not affected by locale.

.SS Function chr-isascii

.TP
Syntax:

  (chr-isalpha <char>)

.TP
Description:

This function returns t if the code of character <char> is in the range
0 to 127, inclusive. For characters outside of this range, it returns nil.

.SS Function chr-iscntrl

.TP
Syntax:

  (chr-iscntrl <char>)

.TP
Description:

This function returns t if the character <char> is a character whose code
ranges from 0 to 31, or is 127. In other words, any non-printable ASCII
character. For other characters, it returns nil.

.SS Function chr-isdigit

.TP
Syntax:

  (chr-isdigit <char>)

.TP
Description:

This function returns t if the character <char> is is an ASCII digit.
Otherwise, it returns nil.

.SS Function chr-isgraph

.TP
Syntax:

  (chr-isgraph <char>)

.TP
Description:

This function returns t if <char> is a non-space printable ASCII character.
It returns nil if it is a space or control character.

It also returns nil for non-ASCII characters: Unicode characters with a code
above 127.

.SS Function chr-islower

.TP
Syntax:

  (chr-islower <char>)

.TP
Description:

This function returns t if <char> is an ASCII lower case letter. Otherwise it returns nil.

.SS Function chr-isprint

.TP
Syntax:

  (chr-isprint <char>)

.TP
Description:

This function returns t if <char> is an ASCII character which is not a
control character.  It also returns nil for all non-ASCII characters: Unicode
characters with a code above 127.

.SS Function chr-ispunct

.TP
Syntax:

  (chr-ispunct <char>)

.TP
Description:

This function returns t if <char> is an ASCII character which is not a
control character.  It also returns nil for all non-ASCII characters: Unicode
characters with a code above 127.

.SS Function chr-isspace

.TP
Syntax:

  (chr-isspace <char>)

.TP
Description:

This function returns t if <char> is an ASCII whitespace character: any of the
characters in the set #\espace, #\etab, #\elinefeed, #\enewline, #\ereturn,
#\evtab, and #\epage.  For all other characters, it returns nil.

.SS Function chr-isupper

.TP
Syntax:

  (chr-isupper <char>)

.TP
Description:

This function returns t if <char> is an ASCII upper case letter. Otherwise it returns nil.

.SS Function chr-isxdigit

.TP
Syntax:

  (chr-isxdigit <char>)

.TP
Description:

This function returns t if <char> is a hexadecimal digit. One of the ASCII
letters A through F, or their lower-case equivalents, or an ASCII digit 0
through 9.

.SS Function chr-toupper

.TP
Syntax:

  (chr-toupper <char>)

.TP
Description:

If character <char> is a lower case ASCII letter character, this function
returns the upper case equivalent character. If it is some other
character, then it just returns <char>.

.SS Function chr-tolower

.TP
Syntax:

  (chr-tolower <char>)

.TP
Description:

If character <char> is an upper case ASCII letter character, this function
returns the lower case equivalent character. If it is some other
character, then it just returns <char>.

.SS Functions num-chr and chr-num

.TP
Syntax:

  (num-chr <char>)
  (chr-num <num>)

.TP
Description:

The argument <char> must be a character. The num-chr function returns that
character's Unicode code point value as an integer.

The argument <num> must be a fixnum integer in the range 0 to #\e10FFFF.
The argument is taken to be a Unicode code point value and the
corresponding character object is returned.

.SS Function chr-str

.TP
Syntax:

  (chr-str <str> <idx>)

.TP
Description:

The chr-str function performs random access on string <str> to retrieve
the character whose position is given by integer <idx>, which must
be within range of the string.

The index value 0 corresponds to the first (leftmost) character of the string
and so non-negative values up to one less than the length are possible.

Negative index values are also allowed, such that -1 corresponds to the
last (rightmost) character of the string, and so negative values down to
the additive inverse of the string length are possible.

An empty string cannot be indexed. A string of length one supports index 0 and
index -1. A string of length two is indexed left to right by the values 0 and
1, and from right to left by -1 and -2.

.TP
Notes:

Direct use of chr-str is equivalent to the DWIM bracket notation except
that <str> must be a string. The following relation holds:

  (chr-str s i) --> [s i]

since [s i] <--> (ref s i), this also holds:

  (chr-str s i) --> (ref s i)

.SS Function chr-str-set

.TP
Syntax:

  (chr-str-set <str> <idx> <char>)

.TP
Description:

The chr-str function performs random access on string <str> to overwrite
the character whose position is given by integer <idx>, which must
be within range of the string. The character at <idx> is overwritten
with character <char>.

The <idx> argument works exactly as in chr-str.

The <str> argument must be a modifiable string.

.TP
Notes:

Direct use of chr-str is equivalent to the DWIM bracket notation except
that <str> must be a string. The following relation holds:

  (chr-str-set s i c) --> (set [s i] c)

since (set [s i] c) <--> (refset s i c), this also holds:

  (chr-str s i) --> (refset s i c)

.SS Function span-str

.TP
Syntax:

  (span-str <str> <set>)

.TP
Description:

The span-str function determines the longest prefix of string <str> which
consists only of the characters in string <set>, in any combination.

.SS Function compl-span-str

.TP
Syntax:

  (compl-span-str <str> <set>)

.TP
Description:

The compl-span-str function determines the longest prefix of string <str> which
consists only of the characters which do not appear in <set>, in any
combination.

.SS Function break-str

.TP
Syntax:

  (break-str <str> <set>)

.TP
Description:

The break-str function returns an integer which represents the position of the
first character in string <str> which appears in string <set>.

If there is no such character, then nil is returned.

.SH LAZY STRINGS

Lazy strings are objects that were developed for the TXR pattern matching
language, and are exposed via TXR Lisp. Lazy strings behave much like strings,
and can be substituted for strings. However, unlike regular strings, which
exist in their entirety, first to last character, from the moment they are
created, lazy strings do not exist all at once, but are created on demand.  If
character at index N of a lazy string is accessed, then characters 0 through N
of that string are forced into existence. However, characters at indices
beyond N need not necessarily exist.

A lazy string dynamically grows by acquiring new text from a list of strings
which is attached to that lazy string object.  When the lazy string is accessed
beyond the end of its hitherto materialized prefix, it takes enough strings
from the list in order to materialize the index. If the list doesn't have
enough material, then the access fails, just like an access beyond the end of a
regular string.  A lazy string always takes whole strings from the attached
list.

Lazy string growth is achieved via the lazy-str-force-upto function which
forces a string to exist up to a given character position. This function is
used internally to handle various situations.

The lazy-str-force function forces the entire string to materialize.  If the
string is connected to an infinite lazy list, this will exhaust all memory.

Lazy strings are specially recognized in many of the regular string functions,
which do the right thing with lazy strings. For instance when sub-str
is invoked on a lazy string, a special version of the sub-str logic is
used which handles various lazy string cases, and can potentially return
another lazy string. Taking a sub-str of a lazy string from character position
7 to all the way to the end does not force the entire lazy string to exist,
and in fact the operation will work on a lazy string that is infinite.

Furthermore, special lazy string functions are provided which allow programs to
be written carefully to take better advantage of lazy strings. What carefully
means is code that avoids unnecessarily forcing the lazy string.  For instance,
in many situations it is necessary to obtain the length of a string, only to
test it for equality or inequality with some number. But it is not necessary to
compute the length of a string in order to know that it is greater than some
value. Computing the length of a lazy string is bad, because it forces the
string to exist, which may not even be possible.

.SS Function lazy-str

.TP
Syntax:

  (lazy-str <string-list> [<terminator> [<limit-count>]])

.TP
Description:

The lazy-str function constructs a lazy string which draws material from
<string-list> which is a list of strings.

If the optional <terminator> argument is given, then it specifies a string
which is appended to every string from <string-list>, before that string is
incorporated into the lazy string. If <terminator> is not given,
then it defaults to the string "\en", and so the strings from
<string-list> are effectively treated as lines which get terminated by newlines
as they accumulate into the growing prefix of the lazy string.
To avoid the use of a terminator string, a null string <terminator> argument
must be explicitly passed. In that case, the lazy string grows simply
by catenating elements from <string-list>.

If the <limit-count> argument is specified, it must be a positive integer.  It
expresses a maximum limit on how many elements will be consumed from
<string-list> in order to feed the lazy string. Once that many elements are
drawn, the string ends, even if the list has not been exhausted.

.SS Function lazy-stringp

.TP
Syntax:

  (lazy-stringp <obj>)

.TP
Description:

The lazy-stringp function returns t if <obj> is a lazy
string. Otherwise it returns nil.

.SS Function lazy-str-force-upto

.TP
Syntax:

  (lazy-str-force-upto <lazy-str> <index>)

.TP
Description:

The lazy-str-force-upto function tries to instantiate the lazy string such that
the position given by <index> materializes. The <index> is a character
position, exactly as used in the chr-str function.

Some positions beyond <index> may also materialize, as a side effect.

If the string is already materialized through to at least <index>, or if it is
possible to materialize the string that far, then the value t is returned to
indicate success.

If there is insufficient material to force the lazy string through to the
<index> position, then nil is returned.

It is an error if the <lazy-str> argument isn't a lazy string.

.SS Function lazy-str-force

.TP
Syntax:

  (lazy-str-force <lazy-str>)

.TP
Description:

The <lazy-str> argument must be a lazy string. The lazy string is forced
to fully materialize.

The return value is an ordinary, non-lazy string equivalent to the fully
materialized lazy string.

.SS Function lazy-str-get-trailing-list

.TP
Syntax:

  (lazy-str-get-trailing-list <string> <index>)

.TP
Description:

The lazy-str-get-trailing-list function is a sort of inverse operation to
the lazy string from its associated list.

Firstly, the string is forced up through the position <index>.

Next, the materialized part of the string starting at position <index>,
through to the end, is split into pieces on occurrences of the terminator
character, which had been given as the <terminator> argument in the lazy-str
constructor, and defaults to the newline character.

Finally, a list is returned consisting of the pieces produced by the split,
to which is appended the remaining list of the string which has not yet been
forced to materialize.

If <index> is a position which cannot be forced, then the lazy string's
remaining list is returned, with single null string prepended to it.


.SS Functions length-str->, length-str->=, length-str-< and length-str-<=

.TP
Syntax:

  (length-str-> <string> <len>)
  (length-str->= <string> <len>)
  (length-str-< <string> <len>)
  (length-str-<= <string> <len>)

.TP
Description:

These functions compare the lengths of two strings. The following
equivalences hold, as far as the resulting value is concerned:

  (length-str-> s l) <--> (> (length-str s) l)
  (length-str->= s l) <--> (>= (length-str s) l)
  (length-str-< s l) <--> (< (length-str s) l)
  (length-str-<= s l) <--> (<= (length-str s) l)

The difference between the length-str-* functions and the equivalent forms is
that if the string is lazy, the length-str function will fully force it in
order to calculate and return its length.

These functions only force a string up to position <len>, so they are not
only more efficient, but usable on infinitely long lazy strings.

length-str cannot compute the length of a lazy string with an unbounded
length; it will exhaust all memory trying to force the string.

These functions can be used to test such as string whether it is longer
or shorter than a given length, without forcing the string beyond
that length.

.SS Function cmp-str

.TP
Syntax:

  (cmp-str <left-string> <right-string>)

.TP
Semantics:

The cmp-str function returns a negative integer if <left-string>
is lexicographically prior to <right-string>, and a positive integer
if the reverse situation is the case. Otherwise the strings are equal
and zero is returned.

If either or both of the strings are lazy, then they are only forced to the
minimum extent necessary for the function to reach a conclusion and return the
appropriate value, since there is no need to look beyond the first character
position in which they differ.

The lexicographic ordering is naive, based on the character code point
values in Unicode taken as integers, without regard for locale-specific
collation orders.

.SS Functions str=, str<, str>, str>= and str<=

.TP
Syntax:

  (str= <left-string> <right-string>)
  (str< <left-string> <right-string>)
  (str> <left-string> <right-string>)
  (str<= <left-string> <right-string>)
  (str>= <left-string> <right-string>)

.TP
Semantics:

These functions compare <left-string> and <right-string> lexicographically,
as if by the cmp-str function.

The str= function returns t if the two strings are exactly the same, character
for character, otherwise it returns nil.

The str< function returns t if <left-string> is lexicographically before
<right-string>, otherwise nil.

The str> function returns t if <left-string> is lexicographically after
<right-string>, otherwise nil.

The str< function returns t if <left-string> is lexicographically before
<right-string>, or if they are exactly the same, otherwise nil.

The str< function returns t if <left-string> is lexicographically after
<right-string>, or if they are exactly the same, otherwise nil.

.SS Function string-lt

.TP
Syntax:

  (string-lt <left-str> <right-str>)

.TP
Description:

The string-lt is a deprecated alias for str<.

.SH VECTORS

.SS Function vector

.TP
Syntax:

  (vector <length> [<initval>])

.TP
Description:

The vector function creates and returns a vector object of the specified
length.  The elements of the vector are initialized to <initval>,
or to nil if <initval> is omitted.

.SS Function vec

.TP
Syntax:

  (vec . <args>)

.TP
Description:

The vec function creates a vector out of its arguments.

.SS Function vectorp

.TP
Syntax:

  (vectorp <obj>)

.TP
Description:

The vectorp function returns t if <obj> is a vector, otherwise it returns
nil.

.SS Function vec-set-length

.TP
Syntax:

  (vec-set-length <vec> <len>)

.TP
Description:

The vec-set-length modifies the length of <vec>, making it longer or
shorter. If the vector is made longer, then the newly added elements
are initialized to nil. The <len> argument must be nonnegative.

The return value is <vec>.

.SS Function vecref

.TP
Syntax:

  (vecref <vec> <idx>)

.TP
Description:

The vecref function performs indexing into a vector. It retrieves
an element of <vec> at position <idx>, counted from zero.
The <idx> value must range from 0 to one less than the
length of the vector. The specified element is returned.

.SS Function vec-push

.TP
Syntax:

  (vec-push <vec> <elem>)

.TP
Description:

The vec-push function extends the length of a vector <vec> by one element, and
sets the new element to the value <elem>.

The previous length of the vector (which is also the position of <elem>)
is returned.

This function performs similarly to the generic function ref, except that the
first argument must be a vector.

.SS Function length-vec

.TP
Syntax:

  (length-vec <vec>)

.TP
Description:

The length-vec function returns the length of vector <vec>. It performs
similarly to the generic length function, except that the argument must
be a vector.

.SS Function size-vec

.TP
Syntax:

  (size-vec <vec>)

.TP
Description:

The size-vec function returns the number of elements for which storage
is reserved in the vector vec. 

.TP
Notes:

The length of the vector can be extended up to this size without any memory
allocation operations having to be performed.

.SS Function vector-list

.TP
Syntax:

  (vector-list <list>)

.TP
Description:

This function returns a vector which contains all of the same elements
and in the same order as list <list>.

.SS Function list-vector

.TP
Syntax:

  (list-vector <vec>)

.TP
Description:

The list-vector function returns a list of the elements of vector <vec>.

.SS Function copy-vec

.TP
Syntax:

  (copy-vec <vec>)

.TP
Description:

The copy-vec function returns a new vector object of the same length
as <vec> and containing the same elements in the same order.

.SS Function sub-vec

.TP
Syntax:

  (sub-vec <vec> [<from> [<to>]])

.TP
Description:

The sub-vec function is like the more generic function sub, except that it
operates only on vectors.

For a description of the arguments and semantics, refer to the sub function.

.SS Function replace-vec

.TP
Syntax:

  (replace-vec <vec> <item-sequence> [<from> [<to>]])

.TP
Description:

The replace-vec is like the replace function, except that the first argument
must be a vector.

For a description of the arguments and semantics, refer to the replace function.

.SS Function cat-vec

.TP
Syntax:

  (cat-vec <vec-list>)

.TP
Description:

The <vec-list> argument is a list of vectors. The cat-vec function
produces a catenation of the vectors listed in <vec-list>. It returns
a single large vector formed by catenating those vectors together in
order.

.SH SEQUENCE MANIPULATION

.SS Function seqp

.TP
Syntax:

  (seqp <object>)

.TP
Description:

The function seqp returns t if <object> is a sequence, otherwise nil.

A sequence is defined as a list, vector or string. The object nil denotes
the empty list and so is a sequence.

.SS Function length

.TP
Syntax:

  (length <sequence>)

.TP
Description:

The length function returns the number of items in <sequence>, and
returns it. <sequence> may be a hash, in which case (hash-count <sequence>) is
returned.

.SS Function empty

.TP
Syntax:

  (empty <sequence>)

.TP
Description:

Returns t if (length <sequence>) is zero, otherwise nil.

.SS Function copy

.TP
Syntax:

  (copy <sequence>)

.TP
Description:

The copy function duplicates a sequence. If <sequence> is nil, it
returns nil. If <sequence> is a list, it returns (copy-list <sequence>);
if <sequence> is a string, it returns (copy-str <sequence>);
if <sequence> is a vector, it returns (copy-vec <sequence>); and
if <sequence> is a hash, it return (copy-hash <sequence>).

Except in the case when <sequence> is nil, copy returns a value that
is distinct from (not eq to) <sequence>. This is different from
the behavior of [<sequence> 0..t] or (sub <sequence> 0 t), which recognize
that they need not make a copy of <sequence>, and just return it.

Note however, that the elements of the returned sequence may be
eq to elements of the original sequence. In other words, copy is
a deeper copy than just duplicating the <sequence> value itself,
but it is not a deep copy.

.SS Function sub

.TP
Syntax:

   (sub <sequence> [<from> [<to>]])

Description:

The sub function extracts a slice from input sequence <sequence>. The slice is
a sequence of the same type as <sequence>.

If the <from> argument is omitted, it defaults to 0.  If the <to> parameter is
omitted, it defaults to t.  Thus (sub a) means (sub a 0 t).

The following equivalence holds between the sub function and
the DWIM-bracket syntax:

  ;; from is not a list
  (sub seq from to) <--> [seq from..to]

The description of the dwim operator - in particular, the section
on Range Indexing - explains the semantics of the range specification.

If the sequence is a list, the output sequence may share substructure
with the input sequence.

.SS Function replace

.TP
Syntax:

   (replace <sequence> <replacement-sequence> [<from> [<to>]])
   (replace <sequence> <replacement-sequence> <index-list>)

.TP
Description:

The replace function has two invocation styles, distinguished by the
type of the third argument. If the third argument is a list,
then it is deemed to be the <index-list> parameter of the second form.
Otherwise, if the third argument is missing, or is not a list, then
it is deemed to be the <from> argument of the first form.

The first form of the replace function replaces a contiguous subsequence of the
<sequence> with <replacement-sequence>. The replaced subsequence may be empty,
in which case an insertion is performed. If <replacement-sequence> is empty
(for example, the empty list nil), then a deletion is performed.

If the <from> and <to> arguments are omitted, their values default
to 0 and t respectively.

The following equivalence holds between assignment to a place denoted by
DWIM bracket syntax and first form of the replace function:

  (set seq (replace seq new from to)) <--> (set [seq from..to] new)

The description of the dwim operator - in particular, the section
on Range Indexing - explains the semantics of the range specification.

This operation is destructive: it may work "in place" by modifying
the original sequence. The caller should retain the return value
and stop relying on the original input sequence.

The second form of the replace function replaces a subsequence of
elements from <sequence> given by <index-list>, with their counterparts
from <replacement-sequence>. This form of the replace function does not insert
or delete; it simply overwrites elements. If <replacement-sequence> and
<index-list> are of different lengths, then the shorter of the two determines
the maximum number of elements which are overwritten.
Furthermore, similar restrictions apply on <index-list> as under the
select function. Namely, the replacement stops when an index value
in <index-list> is encountered which is out of range for <sequence>.
Furthermore, if <sequence> is a list, then <index-list> must
be monotonically increasing.

The following equivalence holds between assignment to a place denoted by
DWIM bracket syntax and second form of the replace function:

  (set seq (replace seq new index-list)) <--> (set [seq index-list] new)

.SS Function search

.TP
Syntax:

  (search <haystack> <needle> [<testfun> [<keyfun>])

.TP
Description:

The search function determines whether the sequence <needle> occurs as substring
within <haystack>, under the given comparison function <testfun> and
key function <keyfun>.  If this is the case, then the zero-based position of
the leftmost occurrence of <key> within <haystack> is returned. Otherwise nil
is returned to indicate that <key> does not occur within <haystack>.
If <key> is empty, then zero is always returned.

The arguments <haystack> and <needle> are sequences: lists, vectors
or strings, in any combination.

If <needle> is not empty, then occurs at some position N within <haystack> if
the first element of <needle> matches the element at position N of <haystack>,
the second element of <needle> matches the element at position N+1 of
<haystack> and so forth, for all elements of <needle>. A match between elements
is determined by passing each element through <keyfun>, and then comparing
the resulting values using <testfun>.

If <testfun> is supplied, it must be a function which can be
called with two arguments. If it is not supplied, it defaults to eql.

If <keyfun> is supplied, it must be a function which can be called
with one argument. If it is not supplied, it defaults to identity.

.TP
Examples:

  ;; fails because 3.0 doesn't match 3 under the default eql function
  [search #(1.0 3.0 4.0 7.0) '(3 4)] -> nil

  ;; occurrence found at position 1: (3.0 4.0) matches (3 4) under =
  [search #(1.0 3.0 4.0 7.0) '(3 4) =] -> 1

  ;; "even odd odd odd even" pattern matches at position 2
  [search #(1 1 2 3 5 7 8) '(2 1 1 1 2) : evenp] -> 2

  ;; Case insensitive string search
  [search "abcd" "CD" : chr-toupper] -> 2

  ;; Case insensitive string search using vector of characters as key
  [search "abcd" #(#\eC #\eD) : chr-toupper] -> 2

.SS Functions ref and refset

.TP
Syntax:

  (ref <seq> <index>)
  (refset <seq> <index> <new-value>)

.TP
Description:

The ref and refset functions perform array-like indexing into sequences.
The ref function retrieves an element of <seq>, whereas refset overwrites an
element of <seq> with a new value.

The <index> argument is based from zero, and negative values are permitted,
with a special meaning as described in the Range Indexing section under the
description of the dwim operator.

The refset function returns the new value.

The following equivalences hold between ref and refset, and the DWIM
bracket syntax:

  (ref seq idx) <--> [seq idx]

  (refset seq idx new) <--> (set [seq idx] new)

The difference is that ref and refset are first class functions which
can be used in functional programming as higher order functions, whereas the
bracket notation is syntactic sugar, and set is an operator, not a function.
Therefore the brackets cannot replace all uses of ref and refset.

.SS Function update

.TP
Syntax:

  (update <sequence-or-hash> <function>)

.TP
Description:

The update function replaces each elements in a sequence, or each value
in a hash table, with the value of <function> applied to that element
or value.

The sequence or hash table is returned.

.SS Function sort

.TP
Syntax:

  (sort <sequence> <lessfun> [<keyfun>])

.TP
Description:

The sort function destructively sorts <sequence>, producing a sequence
which is sorted according to the <lessfun> and <keyfun> arguments.

The <keyfun> argument specifies a function which is applied to elements
of the sequence to obtain the key values which are then compared
using the lessfun. If <keyfun> is omitted, the identity function is used
by default: the sequence elements themselves are their own sort keys.

The <lessfun> argument specifies the comparison function which determines
the sorting order. It must be a binary function which can be invoked
on pairs of keys as produced by the key function. It must
return a non-nil value if the left argument is considered to be lesser
than the right argument. For instance, if the numeric function < is used
on numeric keys, it produces an ascending sorted order. If the function
> is used, then a descending sort is produced.

The sort function is stable for sequences which are lists. This means that the
original order of items which are considered identical is preserved.
For strings and vectors, the sort is not stable.

.SS Function uniq

.TP
Syntax:

  (uniq <sequence>)

.TP
Description:

The uniq function returns a sequence of the same kind as <sequence>, but with
duplicates removed. Elements of <sequence> are considered equal under
the equal function. The first occurrence of each element is retained,
and the subsequent duplicates of that element, of any, are suppressed,
such that the order of the elements is otherwise preserved.

.SS Function tuples

.TP
Syntax:

  (tuples <length> <sequence> [<fill-value>])

.TP
Description:

The tuples function produces a lazy list which represents a reorganization
of the elements of <sequence> into tuples of <length>, where <length>
must be a positive integer.

The length of the sequence might not be evenly divisible by the tuple length.
In this case, if a <fill-value> argument is specified, then the last tuple
is padded with enough repetitions of <fill-value> to make it have <length>
elements. If <fill-value> is not specified, then the last tuple is left
shorter than <length>.

The output of the function is a list, but the tuples themselves are sequences
of the same kind as <sequence>. If <sequence> is any kind of list, they
are lists, and not lazy lists.

.TP
Examples:

  (tuples 3 #(1 2 3 4 5 6 7 8) 0) -> (#(1 2 3) #(4 5 6) #(7 8 0))
  (tuples 3 "abc") -> ("abc")
  (tuples 3 "abcd") -> ("abc" "d")
  (tuples 3 "abcd" #\z) -> ("abc" "dzz")
  (tuples 3 (list 1 2) #\z) -> ((1 2 #\z))

.SS Function partition-by

.TP
Syntax:

  (partition-by <function> <sequence>)

.TP
Description:

If <sequence> is empty, then partition-by returns an empty list,
and <function> is never called.

Otherwise, partition-by returns a lazy list of partitions of the sequence
<sequence>.   Partitions are consecutive, non-empty sub-strings of <sequence>,
of the same kind as <sequence>.

The partitioning begins with the first element of <sequence> being is placed
into a partition.

The subsequent partitioning is done according to <function>, which is applied
to each element of <sequence>. Whenever, for the next element, the function
returns the same value as it returned for the previous element, the
element is placed into the same partition. Otherwise, the next element
is placed into, and begins, a new partition.

The return values of the calls to <function> are compared using the equal
function.

Note:

.TP
Examples:

  [partition-by identity '(1 2 3 3 4 4 4 5)] -> ((1) (2) (3 3) (4 4 4) (5))

  (partition-by (op = 3) #(1 2 3 4 5 6 7)) -> (#(1 2) #(3) #(4 5 6 7))


.SS Function make-like

.TP
Syntax:

  (make-like <list> <ref-sequence>)

.TP
Description:

The <list> argument must be a list.  If <ref-sequence> is a sequence type,
then <list> is converted to the same type of sequence and returned.
Otherwise the original <list> is returned.

Note: the make-like function is a helper which supports the development of
unoptimized versions of a generic function that accepts any type of
sequence as input, and produces a sequence of the same type as output.
The implementation of such a function can internally accumulate a list, and
then convert the resulting list to the same type as an input value
by using make-like.

.SS Function nullify

.TP
Syntax:

  (nullify <sequence>)

.TP
Description:

The nullify function returns nil if <sequence> is an empty sequence.
Otherwise it returns <sequence> itself.

Note: the nullify function is a helper to support unoptimized generic
programming over sequences.  Thanks to the generic behavior cdr, any
sequence can be traversed using cdr functions, checking for the nil
value as a terminator.  This, however, breaks for empty sequences which are not
lists, because they are not equal to nil: to car and cdr they look like
a one-element sequence containing nil. The nullify function reduces all empty
sequences to nil, thereby correcting the behavior of code which traverses
sequences using cdr, and tests for termination with nil.

.TP


.SH MATH LIBRARY

.SS Arithmetic functions +, -

.TP
Syntax:

  (+ <number>*)
  (- <number> <number>*)
  (* <number>*)

.TP
Description:

The +, - and * functions perform addition, subtraction and multiplication,
respectively.  Additionally, the - function performs additive inverse.

The + function requires zero or more arguments. When called with no
arguments, it produces 0 (the identity element for addition), otherwise it
produces the sum over all of the arguments.

Similarly, the * function requires zero or more arguments. When called
with no arguments, it produces 1 (the identity element for multiplication).
Otherwise it produces the product of all the arguments.

The semantics of - changes from subtraction to additive inverse
when there is only one argument. The argument is treated as a subtrahend,
against an implicit minuend of zero. When there are two or more
argument, the first one is the minuend, and the remaining are subtrahends.

When there are three or more operands, these operations are performed as if by
binary operations, in a left-associative way. That is to say, (+ a b c) means
(+ (+ a b) c). The sum of a b is computed first, and then this is added to c.
Similarly (- a b c) means (- (- a b) c). First, b is subtracted from a, and
then c is subtracted from that result.

The arithmetic inverse is performed as if it were subtraction from integer 0.
That is, (- x) means the same thing as (- 0 x).

The operands of +, - and * can be characters, integers (fixnum and bignum), and
floats, in nearly any combination.

If two operands have different types, then one of them is converted to the
type of the one with the higher rank, according to this ranking:
character < integer < float.  For instance if one operand is integer, and the
other float, the integer is converted to a float.

.TP
Restrictions:

Characters are not considered numbers, and participate in these operations in
limited ways. Subtraction can be used to computed the displacement between the
Unicode values of characters, and an integer displacement can be added to a
character, or subtracted from a character.  For instance (- #\e9 #\e0) is 9.  
The Unicode value of a character C can be found using (- C #\ex0): the
displacement from the NUL character.

The rules can be stated as a set of restrictions:

Two characters may not be added together.

A character may not be subtracted from an integer (which also rules out
the possibility of computing the additive inverse of a character).

A character operand may not be opposite to a floating point operand
in any operation.

A character may not be an operand of multiplication.

.SS Functions /, trunc, mod

.TP
Syntax:

  (/ [<dividend>] <divisor>)
  (trunc <dividend> <divisor>)
  (mod <dividend> <divisor>)

Description:

The arguments to these functions are numbers. Characters are not permitted.

The / function performs floating-point division. Each operands is first
converted to floating-point type, if necessary. If <dividend> is omitted,
then it is taken to be 1.0 and the function performs a reciprocal.

The trunc function performs a division of <dividend> by <divisor> whose result
is truncated to integer toward zero. If both operands are integers, then an
integer division is performed and the result is an integer. If either operand
is a floating point value,  a floating point division occurs, and the result is
truncated toward zero to a floating-point integral value.

The mod function performs a modulus operation. Firstly, the absolute value
of <divisor> is taken to be a modulus. Then a residue of <dividend>
with respect to <modulus> is calculated. The residue's sign follows
that of the sign of <divisor>. That is, it is the smallest magnitude
(closest to zero) residue of <dividend> with respect to the absolute
value of <divisor>, having the same sign as <divisor>.
If the operands are integer, the result is an integer. If either operand
is of type float, then the result is a float. The modulus operation is
then generalized into the floating point domain. For instance the
(mod 0.75 0.5) yields a residue of 0.25 because 0.5 "goes into" 0.75 only
once, with a "remainder" of 0.25.

.SS Function gcd

.TP
Syntax:

  (gcd <left> <right>)

.TP
Description:

The gcd function computes the greatest common divisor: the largest positive
integer which divides both arguments.

Operands <left> and <right> must be integers, or else an exception is thrown.

The value of (gcd 0 x) is 0 for all x, including 0.

The value of (gcd x 123) is is (abs x) for all x.

Negative operands are permitted; this operation effectively ignores sign, so
that the value of (gcd x y) is the same as (gcd (abs x) (abs y)) for all
x and y.

.SS Function abs

.TP
Syntax:

  (abs <number>)

.TP
Description:

The abs function computes the absolute value of <number>. If <number>
is positive, it is returned. If the number is negative, its additive inverse is
returned: a positive number of the same type with exactly the same magnitude.

.SS Functions floor, ceil

.TP
Syntax:

  (floor <number>)
  (ceil <number>)

.TP
Description:

The floor function returns the highest integer which does not exceed
the value of <number>. The ceiling function returns the lowest integer which
does not exceed the value of <number>.

If <number> an integer, it is simply returned.

If the argument is a float, then the value returned is a float.
For instance (floor 1.1) returns 1.0 rather than 1.

.SS Functions sin, cos, tan, asin, acos, atan, atan2

.TP
Syntax:

  (sin <radians>)
  (cos <radians>)
  (tan <radians>)
  (atan <slope>)
  (atan2 <y> <x>)
  (asin <num>)
  (acos <num>)

.TP
Description:

These trigonometric functions convert their argument to floating point and
return a float result. The sin, cos and tan functions compute the sine and
cosine and tangent of the <radians> argument which represents an angle
expressed in radians. The atan, acos and asin are their respective inverse
functions.  The <num> argument to asin and acos must be in the
range -1.0 to 1.0. The atan2 function converts the rectilinear coordinates
<x>  and <y> to an angle in polar coordinates in the range [0, 2pi).

.SS Functions exp, log, log10 and log2

.TP
Syntax:

  (exp <number>)
  (log <number>)
  (log10 <number>)
  (log2 <number>)

.TP
Description:

The exp function calculates the value of the transcendental number e raised to
the specified exponent.

The log function calculates the base e logarithm of its argument, which must
be a positive value.

The log10 function calculates the base 10 logarithm of its argument, which must
be a positive value.

The log2 function calculates the base 2 logarithm of its argument, which must
be a positive value.

Integer arguments are converted to floats.

.SS Functions expt, sqrt, isqrt

.TP
Syntax:

  (expt <base> <exponent>*)
  (sqrt <number>)
  (isqrt <integer>)

.TP
Description:

The expt function raises <base> to zero or more exponents given
by the <exponent> arguments.
(expt x) is equivalent to (expt x 1); and yields x for all x.
For three or more arguments, the operation is right associative.
That is to say, (expt x y z) is equivalent to (expt x (expt y z)) and
so forth, similarly to the way nested exponents work in standard algebraic
notation. 

Exponentiation is done pairwise using a binary operation.
If both operands to this binary operation are integers, then the
result is an integer. If either operand is a float, then the other
operand is converted to a float, and a floating point exponentiation
is performed. Exponentiation that would produce a complex number is
not supported.

The sqrt function produces a floating-point square root. The numeric
operand is converted from integer to floating-point if necessary.
Negative operands are not supported.

The isqrt function computes an integer square root: a value which is the
greatest integer that is no greater than the true square root of the input
value. The input value must be an integer.

.SS Function exptmod

.TP
Syntax:

  (exptmod <base> <exponent> <modulus>)

.TP
Description:

The exptmod function performs modular exponentiation and accepts only integer
arguments. Furthermore, <exponent> must be a non-negative and <modulus>
must be positive.

The return value is <base> raised to <exponent>, and reduced to the
least positive residue modulo <modulus>.

.SS Function cum-norm-dist

.TP
Syntax:

  (cum-norm-dist <argument>)

.TP
Description:

The cum-norm-dist function calculates an approximation to the cumulative normal
distribution function: the integral, of the normal distribution function, from
negative infinity to the <argument>.

.SS Functions n-choose-k and n-perm-k

.TP
Syntax:

  (n-choose-k <n> <k>)
  (n-perm-k <n> <k>)

.TP
Description:

The n-choose-k function computes the binomial coefficient nCk which
expresses the number of combinations of <k> items that can be chosen from
a set of <n>, where combinations are subsets.

The n-perm-k function computes nPk: the number of permutations of size <k>
that can be drawn from a set of <n>, where permutations are sequences,
whose order is significant.

The calculations only make sense when <n> and <k> are nonnegative integers, and
<k> does not exceed <n>. The behavior is not specified if these conditions
are not met.

.TP
Description:

The cum-norm-dist function calculates an approximation to the cumulative normal
distribution function: the integral, of the normal distribution function, from
negative infinity to the <argument>.


.SS Functions fixnump, bignump, integerp, floatp, numberp

.TP
Syntax:

  (fixnump <object>)
  (bignump <object>)
  (integerp <object>)
  (floatp <object>)
  (numberp <object>)

.TP
Description:

These functions test the type of <object>, returning true if it is an object
of the implied type. The fixnump, bignump and floatp functions return true if
the object is of the basic type fixnum, bignum or float.
The function integerp returns true of <object> is either a fixnum or
a bignum. The function numberp returns true if the object is either
a fixnum, bignum or float.

.SS Function zerop

.TP
Syntax:

  (zerop <number>)

.TP
Description:

The zerop function tests <number> for equivalence to zero. The argument must be
a number. It returns t for the integer value 0,  and for the floating-point
value 0.0. For other numbers, it returns nil.

.SS Functions evenp, oddp

.TP
Syntax:

  (evenp <integer>)
  (oddp <integer>)

.TP
Description:

The evenp and oddp functions require integer arguments. evenp returns
t if <integer> is even (divisible by two), otherwise it returns nil.
oddp returns t if <integer> is not divisible by two (odd), otherwise
it returns nil.

.SS Functions >, <, >=, <= and =

.TP
Syntax:

  (> <number> <number>*)
  (< <number> <number>*)
  (>= <number> <number>*)
  (<= <number> <number>*)
  (= <number> <number>*)

.TP
Description:

These relational functions compare characters and numbers for numeric equality
or inequality. The arguments must be one or more numbers or characters.

If just one argument is given, then these functions all return t.

If two arguments are given, then, they are compared as follows.
First, if the numbers do not have the same type, then the one
which has the lower ranking type is converted to the type of
the other, according to this ranking: character < integer < float.
For instance if a character and integer is compared, the character
is converted to integer. Then a straightforward numeric comparison
is applied.

Three or more arguments may be given, in which case the comparison proceeds
pairwise from left to right. For instance in (< a b c), the comparison (< a b)
is performed in isolation. If it yields false, then nil is returned, otherwise
the comparison (< b c) is performed in isolation, and if that yields false, nil
is returned, otherwise t is returned.  Note that it is possible for b to
undergo two different conversions.  For instance in (< <float> <character>
<integer>), the character will convert to a floating-point representation of
its Unicode, and if that comparison succeeds, then in the second comparison, the
character will convert to integer.

.SS Function /=

.TP
Syntax:

  (/= <number>*)

.TP
Description:

The arguments to /= may be numbers or characters.  The /= function returns t if
no two of its arguments are numerically equal. That is to say, if there exist
some a and b which are distinct arguments such that (= a b) is true, then
the function returns nil. Otherwise it returns t.

.SS Functions max and min

.TP
Syntax:

  (max <number> <number>*)
  (min <number> <number>*)

.TP
Description:

The max and min functions determine and return the highest or lowest
value from among their arguments.

The arguments must be numbers or characters.

If only a single argument is given, that value is returned.

If two arguments are given, then (max a b) is equivalent to (if (>= a b) a b),
and (min a b) is equivalent to (if (<= a b) a b). If the operands do not
have the same type, then one of them is converted to the type of the other;
however, the original unconverted values are returned. For instance
(max 4 3.0) yields the integer 4, not 4.0.

If three or more arguments are given, max and min are left-associative.
Thus (max a b c) is (max (max a b) c).

.SS Functions int-str, flo-str and num-str

.TP
Syntax:

  (int-str <string> [<radix>])
  (flo-str <string>)
  (num-str <string>)

.TP
Description:

These functions extract numbers <string>. Leading whitespace, if
any, is skipped. If no digits can be successfully extracted, then nil is
returned.  Trailing material which does not contribute to the number
is ignored.

The int-str function converts a string of digits in the specified
radix to an integer value. If the radix isn't specified, it defaults to 10.
For radices above 10, letters of the alphabet
are used for digits: A represent a digit whose value is 10, B represents 11 and
so forth until Z.  For values of radix above 36, the returned value is
unspecified. Upper and lower case letters are recognized.
Any character which is not a digit of the specified radix is regarded
as the start of trailing junk at which the extraction of the digits stops.

The flo-str function converts a floating-point decimal notation to a nearby
floating point value. The material which contributes to the value
is the longest match for optional leading space, followed by a
mantissa which consists of an optional sign followed by a mixture of at least
one digit, and at most one decimal point, optionally followed by an exponent
part denoted by the letter E or e, an optional sign and one or more optional
exponent digits.

The num-str function converts a decimal notation to either an integer as if by
a radix 10 application of int-str, or to a floating point value as if by
flo-str. The floating point interpretation is chosen if the possibly empty
initial sequence of digits (following any whitespace and optional sign) is
followed by a period, e or E.

.SS Functions int-flo and flo-int

.TP
Syntax:

  (int-flo <float>)
  (flo-int <integer>)

.TP
Description:

These functions perform numeric conversion between integer and floating point
type. The int-flo function returns an integer by truncating toward zero.
The flo-int function returns an exact floating point value corresponding to the
integer argument, if possible, otherwise an approximation using a nearby
floating point value.

.SS Functions tofloat and toint

.TP
Syntax:

  (tofloat <value>)
  (toint <value> [<radix>])

.TP
Description:

These convenience functions convert a given value to a floating-point value or
to an integer, respectively.

If a floating-point value is passed into tofloat, or an integer value into
toint, then the value is simply returned.

If <value> is a string, then it is converted by tofloat as if by the
function flo-str, and by toint as if by the function int-str.

If <value> is an integer, then it is converted by tofloat as if by
the function flo-int.

If <value> is a floating-point number, then it is converted by toint
as if by the function int-flo.

.SH BIT OPERATIONS

In TXR Lisp, similarly to Common Lisp, bit operations on integers are based
on "infinite two's-complement".  That is to say, whereas a positive
binary number can be regarded as being prefixed by an infinite stream of
zero digits (for example 1 the same as 0001 or ...00001) a negative number
in infinite two's complement can be conceptualized by an infinite prefix 
of 1 digits. So for instance the number -1 is represented by ...11111111: an
infinite half-sequence of 1 digits. Any operation which produces such an
infinite sequence gives rise to a negative number. For instance, consider the
operation of computing the bitwise complement of the number 1.   Since the
number 1 is actually ...0000001, then the complement is ...11111110.  Each
one of the 0 digits in the infinite sequence is replaced by 1, giving rise
to an infinite leading sequence of 1's.  And this means that the number
is negative, corresponding to the two's-complement representation of the
value -2.

In fact TXR Lisp's bignum integers do not use a two's complement
representation. Numbers are represented as an array which holds a pure
binary number. A separate field indicates the sign, positive or non-negative.
That negative numbers appear as two's-complement under the bit operations
is merely a carefully maintained illusion (which makes bit operations on
negative numbers more expensive).

The logtrunc function, and a feature of the lognot function, allows bit
manipulation code to be written which works with positive numbers only, even if
complements are required. The trade off is that the application has to manage
a limit on the number of bits.

.SS Functions logand, logior, logxor

.TP
Syntax:

  (logand <integer>*)
  (logior <integer>*)
  (logxor <int1> <int2>)

.TP
Description:

These operations perform the familiar bitwise and, inclusive or, and exclusive
or operations respectively. Positive values inputs are treated as
pure binary numbers.  Negative inputs are treated as infinite-bit
two's-complement.

For example (logand -2 7) produces 6. This is because -2 is ..111110 in
infinite-bit two's-complement.  Or-ing this value with 7 (111) produces
110.

The logand and logior functions are variadic, and may be called with zero, one,
two, or more input values. If logand is called with no arguments, it produces
the value -1 (all bits 1). If logior is called with no arguments it produces
zero. In the one-argument case, the functions just return their argument value.



.SS Functions logtest

.TP
Syntax:

  (logtest <int1> <int2>)

.TP
Description:

The logtest function returns true if <int1> and <int1> have bits in
common. The following equivalence holds:

  (logtest a b) <--> (not (zerop (logand a b)))

.SS Functions lognot and logtrunc

.TP
Syntax:

  (lognot <value> [<bits>])
  (logtrunc <value> <bits>)

.TP
Description:

The lognot function performs a bitwise complement of <value>. 
When the one-argument form of lognot is used, then if <value> is nonnegative,
then the result is negative, and vice versa, according to the infinite-bit
two's complement representation. For instance (lognot -2) is 1, 
and (lognot 1) is -2.

The two-argument form of lognot produces a truncated complement. Conceptually,
t a bitwise complement is first calculated, and then the resulting number is
truncated to the number of bits given by <bits>, which must be a nonnegative
integer. The following equivalence holds:

  (lognot a b) <--> (logtrunc (lognot a) b)

The logtrunc function truncates the integer <value> to the  specified number
of bits. If <value> is negative, then the two's-complement representation
is truncated. The return value of logtrunc is always a non-negative integer.

.SS Function ash

.TP
Syntax:

  (ash <value> <bits>)

.TP
Description:

The ash function shifts <value> by the specified number of <bits> producing a
new value.  If <bits> is positive, then a left shift takes place.  If <bits>
is negative, then a right shift takes place. If <bits> is zero, then
<value> is returned unaltered.  For positive numbers, a left shift by n bits is
equivalent to a multiplication by two to the power of n, or (expt 2 n).
A right shift by n bits of a positive integer is equivalent to integer
division by (expt 2 n), with truncation toward zero.
For negative numbers, the bit shift is performed as if on the two's-complement
representation. Under the infinite two's-complement representation,
a right shift does not exhaust the infinite sequence of 1 digits which
extends to the left. Thus if -4 is shifted right it becomes -2 because
the bitwise representations are ...111100 and ...11110.

.SS Function bit

.TP
Syntax:

  (bit <value> <bit>)

.TP
Description:

The bit function tests whether the integer <value> has a 1 in bit position <bit>.
The <bit> argument must be a non-negative integer. A value of zero of <bit>
indicates the least significant bit position of <value>.

The bit function has a boolean result, returning the symbol t if bit <bit>
of <value> is set, otherwise nil.

If <value> is negative, it is treated as if it had an infinite-bit two's
complement representation. For instance, if value is -2, then the bit
function returns nil for a <bit> value of zero, and t for all other values,
since the infinite bit two's complement representation of -2 is ...11110.

.SS Function mask

.TP
Syntax:

  (mask <integer>*)

.TP
Description:

The mask function takes zero or more integer arguments, and produces an integer
value which corresponds a bitmask made up of the bit positions specified by the
integer values.

If mask is called with no arguments, then the return value is zero.

If mask is called with a single argument B then the return value is the same as
that of the expression (ash 1 <value>): one shifted left by <value> bit
positions. If <value> is zero, then the result is 1; if <value> is 1, the
result is 2 and so forth.  If <value> is negative, then the result is zero.

If mask is called with two or more arguments, then the result is a bitwise of
the masks individually computed for each of the values.  

In other words, the following equivalences hold:

  (mask) == 0
  (mask a) == (ash 1 a)
  (mask a b c ...) == (logior (mask a) (mask b) (mask c) ...)

.SH EXCEPTIONS

.SS Functions throw, throwf and error

.TP
Syntax:

  (throw <symbol> <arg>*)
  (throwf <symbol> <format-string> <format-arg>*)
  (error <format-string> <format-arg>*)

.TP
Description:

These functions generate an exception. The throw and throwf functions generate
an exception identified by <symbol>, whereas error throws an exception of
type error. The call (error ...) can be regarded as a shorthand for
(throwf 'error ...).

The throw function takes zero or more additional arguments. These arguments
become the arguments of a catch handler which takes the exception. The
handler will have to be capable of accepting that number of arguments.

The throwf and error functions generate an exception which has a single
argument: a character string created by a formatted print to a string stream
using the format string and additional arguments.

.SS Operator catch

.TP
Syntax:

  (catch <try-expression>
    {(<symbol> (<arg>*) <body-form>*)}*)

.TP
Description:

The catch operator establishes an exception catching block around
the <try-expression>. The <try-expression> is followed by zero or more
catch clauses. Each catch clause consists of a symbol which denotes
an exception type, an argument list, and zero or more body forms.

If <try-expression> terminates normally, then the catch clauses
are ignored. The catch itself terminates, and its return value is
that of the <try-expression>.

If <try-expression> throws an exception which is a subtype of one or more of
the type symbols given in the exception clauses, then the first (leftmost) such
clause becomes the exit point where the exception is handled.
The exception is converted into arguments for the clause, and the clause
body is executed. When the clause body terminates, the catch terminates,
and the return value of the catch is that of the clause body.

If <try-expression> throws an exception which is not a subtype of any of
the symbols given in the clauses, then the search for an exit point for
the exception continues through the enclosing forms. The catch clauses
are not involved in the handling of that exception.

When a clause catches an exception, the number of arguments in the catch must
match the number of elements in the exception.  A catch argument list
resembles a function or lambda argument list, and may be dotted.  For instance
the clause (foo (a . b)) catches an exception subtyped from foo, with one or
more elements. The first element binds to parameter a, and the rest, if any,
bind to parameter b.  If there is only one element, b takes on the value nil.

Also see: the unwind-protect operator, and the functions throw, throwf
and error.

.SH REGULAR EXPRESSION LIBRARY

.SS Functions search-regex and range-regex

.TP
Syntax:

 (search-regex <haystack-string> <needle-regex> [ <start> [<from-end>] ])
 (range-regex <haystack-string> <needle-regex> [ <start> [<from-end>] ])

.TP
Description

The search-regex function searches through <haystack-string> starting
at position <start> for a match for <needle-regex>. If <start> is omitted,
the search starts at position 0. If <from-end> is specified, the search
proceeds in reverse, from the last position in the string, toward <start>.
This function returns nil if no match is found, otherwise it returns
a cons pair, whose car indicates the position of the match, and whose
cdr indicates the length of the match.

The range-regex function is similar to search-regex, except when
a match is found, it returns a position range, rather than a position
and length. A cons pair is returned whose car indicates the position
of the match, and whose cdr indicates the position one element past the
last character of the match. If the match is empty, the two integers
are equal.

.SS Function match-regex

.TP
Syntax:

 (match-regex <string> <regex> [<position>])

.TP
Description

The match-regex function tests whether <regex> matches at <position>
in <string>. If <position> is not specified, it is taken to be zero.
If the regex matches, then the length of the match is returned.
If it does not match, then nil is returned.

.SS Function match-regex-right

.TP
Syntax:

 (match-regex-right <string> <regex> [<end-position>])

.TP
Description

The match-regex function tests whether <string> contains a match which ends
precisely on the character just before <end-position>.  If <end-position> is
not specified, it defaults to the length of the string, and the function
performs a right-anchored regex match.

If a match is found, then the length of the match is returned, and
the matching substring is then returned.

The match must terminate just before <end-position> in the sense that
additional characters at <end-position> and beyond can no longer satisfy the
regular expression. More formally, the function searches, starting from
position zero, for positions where there occurs a match for the regular
expression, taking the longest possible match. The length of first such a match
which terminates on the character just before <end-position> is returned.
If no such a match is found, then nil is returned.

.TP
Examples:

  ;; Return matching portion rather than length thereof.

  (defun match-regex-right-substring (str reg : end-pos)
    (set end-pos (or end-pos (length str)))
    (let ((len (match-regex-right str reg end-pos)))
      (if len
        [str (- end-pos len)..end-pos]
        nil)))
     
  (match-regex-right-substring "abc" #/c/) -> ""

  (match-regex-right-substring "acc" #/c*/) -> "cc"

  ;; Regex matches starting at multiple positions, but all
  ;; the matches extend past the limit.
  (match-regex-right-substring "acc" #/c*/ 2) -> nil

  ;; If the above behavior is not wanted, then
  ;; we can extract the string up to the limiting
  ;; position and do the match on that.
  (match-regex-right-substring ["acc" 0..2] #/c*/) -> "c"

  ;; Equivalent of above call
  (match-regex-right-substring "ac" #/c*/) -> "c"


.SS Function regsub

.TP
Syntax:

  (regsub <regex> <replacement> <string>)

.TP
Description:

The regsub function searches <string> for multiple occurrences of
non-overlapping matches for <regex>.  A new string is constructed
similar to <string> but in which each matching region is replaced
with using <replacement> as follows.

The <replacement> object may be a character or a string, in which 
case it is simply taken to be the replacement for each match
of the regular expression.

The <replacement> object may be a function of one argument, in
which case for every match which is found, this function is invoked,
with the matching piece of text as an argument. The function's
return value is then taken to be the replacement text.

.TP
Examples:

  ;; match every lower case e or o, and replace by filtering
  ;; through the upcase-str function:
  
  [regsub #/[eo]/ upcase-str "Hello world!"] -> "HEllO wOrld!"

  ;; Replace Hello with Goodbye:
  (regsub #/Hello/ "Goodbye" "Hello world!") -> "Goodbye world!"

.SS Function regexp

.TP
Syntax:

  (regexp <obj>)

.TP
Description:

The regexp function returns t if <obj> is a compiled regular expression
object. For any other object type, it returns nil.

.SS Function regex-compile

.TP
Syntax:

  (regex-compile <form-or-string> [<error-stream>])

.TP
Description:

The regex compile function takes the source code of a regular expression,
expressed as a Lisp data structure representing an abstract syntax tree, or
else a regular expression specified as a character string, and compiles it to a
regular expression object.

If <form-or-string> is a character string, it is parsed to an
abstract syntax tree first, if by a call to (regex-parse <form-or-string>). 
If the parse is successful (the result is not nil) then
it is compiled by a recursive call to regex-compile.

The optional <error-stream> argument is passed down to regex-compile,
if that call takes place.

.TP
Examples:

  ;; the equivalent of #/[a-zA-Z0-9_/
  (regex-compile '(set (#\ea . #\ez) (#\eA . #\eZ) (#\e0 . #\e9) #\e_))

  ;; the equivalent of #/.*/ and #/.+/
  (regex-compile '(0+ wild))
  (regex-compile '(1+ wild))

  ;; #/a|b|c/
  (regex-compile '(or (or #\ea #\eb) #\ec))

  ;; string
  (regex-compile "a|b|c")

.SS Function regex-parse

.TP
Syntax:

  (regex-parse <string> [<error-stream>])

.TP
Description:

The regex string parses a character string which contains a regular expression
(without any surrounding / characters) and turns it into a Lisp data structure
(the abstract syntax tree representation of the regular expression).

The regular expression syntax #/RE/ produces the same structure, but as a
literal which is processed at the time TXR source code is read; the regex-parse
function performs this parsing at run-time.

If there are parse errors, the function returns nil.

The optional <error-stream> argument specifies a stream to which error messages
are sent from the parser. By default, diagnostic output goes to the *stdnull*
stream, which discards it. If <error-stream> is specified as t, then the
diagnostic output goes to the *stdout* stream.

If regex-parse returns a non-nil value, that structure is then something
which is suitable as input to regex-compile.

.SH HASHING LIBRARY

.SS Functions make-hash, hash

.TP
Syntax:

  (make-hash <weak-keys> <weak-vals> <equal-based>)
  (hash { :weak-keys | :weak-vals | :equal-based }*)

.TP
Description:

These functions construct a new hash table, using different syntax.

A hash table is an object which retains an association between pairs of
objects. Each pair consists of a key and value. Given an object which is
similar to a key in the hash table, it is possible to retrieve the
corresponding value. Entries in a hash table are not ordered in any way, and
lookup is facilitated by hashing: quickly mapping a key object to a numeric
value which is then used to index into one of many buckets where the matching
key will be found (if such a key is present in the hash table).

make-hash takes three mandatory boolean arguments. The <weak-keys>
argument specifies, whether the hash table shall have weak keys. The <weak-vals>
argument specifies whether it shall have weak values, and
<equal-based> specifies whether it is equal-based.  The hash function defaults
all three of these properties to false, and allows them to be overridden to
true by the presence of keyword arguments.

It is an error to attempt to construct an equal-based hash table which
has weak keys.

The hash function provides an alternative interface. It accepts optional
arguments which are keyword symbols. Any combination of the three symbols
:weak-keys, :weak-vals and :equal-based can be specified in any order
to turn on the corresponding properties in the newly constructed hash table.
If any of the keywords is not specified, the corresponding property defaults to
nil. 

If a hash table has weak keys, this means that from the point of view
of garbage collection, that table holds only weak references to the keys
stored in it.  Similarly, if a hash table has weak values, it means that it
holds a weak reference to each value stored. A weak reference is one
which does not prevent the reclamation of an object by the garbage
collector. That is to say, when the garbage collector discovers that the only
references to some object are weak references, then that object is considered
garbage, just as if it had no references to it. The object is reclaimed, and
the weak references "lapse" in some way, which depends on what kind they are.
Hash table weak references lapse by entry removal: if either a key or a value
object is reclaimed, then the corresponding key-value entry is erased from the
hash table.

Important to the operation of a hash table is the criterion by which keys are
considered same. By default, this similarity follows the eql function.  A hash
table will search for a stored key which is eql to the given search key.
A hash table constructed with the equal-based property compares keys using
the equal function instead.

In addition to storing key-value pairs, a hash table can have a piece of
information associated with it, called the user data.

.SS Function hash-construct

.TP
Syntax:

  (hash-construct <hash-args> <key-val-pairs>)

.TP
Description:

The hash-construct function constructs a populated hash in one step. The <hash-args>
argument specifies a list suitable as an argument list in a call to the hash function.
The <key-val-pairs> is a sequence of pairs, which are two-element lists representing
key-value pairs.

A hash is constructed as if by a call to [apply hash <hash-args>], then populated
with the specified pairs, and returned.

.SS Function hash-update

.TP
Syntax:

  (hash-update <hash> <function>)

.TP
Description:

The hash-update function replaces each values in <hash>, with the value of
<function> applied to that value.

The return value is <hash>.

.SS Function hash-update-1

.TP
Syntax:

  (hash-update-1 <hash> <key> <function> [<init>])

.TP
Description:

The hash-update-1 function operates on a single entry in the hash table.

If <key> exists in the hash table, then its corresponding value is passed
into <function>, and the return value of <function> is then installed
in place of the key's value. The value is then returned.

If <key> does not exist in the hash table, and no <init> argument is given,
then the function does nothing and returns nil.

If <key> does not exist in the hash table, and an <init> argument is given,
then <function> is applied to <init>, and then <key> is inserted into
<hash> with the value returned by <function> as the datum. This value
is also returned.

.SS Function group-by

.TP
Syntax:

  (group-by <func> <sequence> <option>*)

.TP
Description:

The group-by function produces a hash table from <sequence>, which is a
list or vector. Entries of the hash table are not elements of sequence,
but lists of elements of <sequence>. The function <func> is applied to
each element of <sequence> to compute a key. That key is used to determine
which list the item is added to in the hash table.

The trailing arguments <option>*, if any, consist of the same keywords
that are understood by the hash function, and determine the properties
of the hash.

.TP
Example:

Group the integers from 0 to 10 into three buckets keyed on 0, 1 and 2
according to the modulo 3 congruence:

  (group-by (op mod @1 3) (range 0 10)))

  -> #H(() (0 (0 3 6 9)) (1 (1 4 7 10)) (2 (2 5 8)))


.SS Functions make-similar-hash and copy-hash

.TP
Syntax:

  (make-similar-hash <hash>)
  (copy-hash <hash>)

.TP
Description:

The make-similar-hash and copy-hash functions create a new hash object based on
the existing <hash> object.

The make-similar-hash produces an empty hash table which inherits all of the
attributes of <hash>. It uses the same kind of key equality, the
same configuration of weak keys and values, and has the same user data (see
the set-hash-userdata function).

The copy-hash function is like make-similar-hash, except that instead of
producing an empty hash table, it produces one which has all the same elements
as <hash>: it contains the same key and value objects. 

.SS Function inhash

.TP
Syntax:

  (inhash <hash> <key> [<init>])

.TP
Description:

The inhash function searches hash table <hash> for <key>. 
If <key> is found, then it return the hash table's cons cell which 
represents the association between <hash> and <key>.
Otherwise, it returns nil.

If argument <init> is specified, then the function will create
an entry for <key> in <hash> whose value is that of <init>.
The cons cell representing that association is returned.

Note: for as long as the <key> continues to exist inside <hash>. modifying the
car field of the returned cons has ramifications for the logical integrity of
the hash. Modifying the cdr field has the effect of updating the association.

.SS Function gethash

.TP
Syntax:

  (gethash <hash> <key> [<alt>])

.TP
Description:

The gethash function searches hash table <hash> for key <key>. If the
key is found then the associated value is returned. Otherwise, if
the <alt> argument was specified, it is returned. If the <alt> argument
was not specified, nil is returned.

.SS Function sethash

.TP
Syntax:

  (sethash <hash> <key> <value>)

.TP
Description:

The sethash function places a value into <hash> table under the given <key>.
If a similar key already exists in the hash table, then that key's
value is replaced by <value>. Otherwise, the <key> and <value> pair is
newly inserted into <hash>.

.SS Function pushhash

.TP
Syntax:

  (pushhash <hash> <key> <element>)

.TP
Description:

The pushhash function is useful when the values stored in a hash table
are lists.  If the given <key> does not already exist in <hash>, then a list of
length one is made which contains <element>, and stored in <hash> table under
<key>.  If the <key> already exists in the hash table, then the corresponding
value must be a list. The <element> value is added to the front of that list,
and the extended list then becomes the new value under <key>.

.SS Function remhash

.TP
Syntax:

  (remhash <hash> <key>)

.TP
Description:

The remhash function searches <hash> for a key similar to the
<key>. If that key is found, then that key and its corresponding value are
removed from the hash table.

.SS Function hash-count

.TP
Syntax:

  (hash-count <hash>)

.TP
Description:

The hash-count function returns an integer representing the number of
key-value pairs stored in <hash>.

.SS Function get-hash-userdata

.TP
Syntax:

  (get-hash-userdata <hash>)

.TP
Description:

This function retrieves the user data object associated with <hash>.
The user data object of a newly created hash table is initialized to nil.

.SS Function set-hash-userdata

.TP
Syntax:

  (set-hash-userdata <hash> <object>)

.TP
Description:

The set-hash-userdata replaces, with the <object>, the user data object
associated with <hash>.

.SS Function hashp

.TP
Syntax:

  (hashp <object>)

.TP
Description:

The hashp function returns t if the <object> is a hash table,
otherwise it returns nil.

.SS Function maphash

.TP
Syntax:

  (maphash <hash> <binary-function>)

.TP
Description:

The maphash function successively invokes binary-function for each key-value
pair present in <hash>. The key and value are passed as arguments
to <binary-function>.

.SS Functions hash-eql and hash-equal

.TP
Syntax:

  (hash-eql <object>)
  (hash-equal <object>)

.TP
Description:

These functions each compute an integer hash value from the internal
representation of <object>, which satisfies the following properties.
If two objects A and B are the same under the eql function, then
(hash-eql A) and (hash-eql B) produce the same integer hash value.  Similarly,
if two objects A and B are the same under the equal function, then (hash-equal
A) and (hash-equal B) each produce the same integer hash value.  In all other
circumstances, the hash values of two distinct objects are unrelated, and
may or may not be equal.

.SS Functions hash_keys, hash_values, hash_pairs, and hash_alist

.TP
Syntax:
  (hash-keys <hash>)
  (hash-values <hash>)
  (hash-pairs <hash>)
  (hash-alist <hash>)

.TP
Description:

These functions retrieve the bulk key-value data of hash table <hash>
in various ways. hash-keys retrieves a list of the keys. hash-values
retrieves a list of the values. hash-pairs retrieves a list of pairs,
which are two-element lists consisting of the key, followed by the value.
Finally, hash-pairs retrieves the key-value pairs as a Lisp association list:
a list of cons cells whose car fields are keys, and whose cdr fields
are the values. 

These functions all retrieve the keys and values in the
same order. For example, if the keys are retrieved with hash-keys,
and the values with hash-values, then the corresponding entries from
each list correspond to the pairs in the hash table.

.SS Operator dohash

.TP
Syntax:

  (dohash (<key-var> <value-var> <hash-form> [<result-form>])
    <body-form>*)

.TP
Description:

The dohash operator iterates over a hash table. The <hash-form> expression must
evaluate to an object of hash table type. The <key-var> and <value-var>
arguments must be symbols suitable for use as variable names.
Bindings are established for these variables over the scope of the
<body-form>-s and the optional result form.

For each element in the hash table, the <key-var> and <value-var>
variables are set to the key and value of that entry, respectively,
and each <body-form>, if there are any, is evaluated.

When all of the entries of the table are thus processed, the <result-form> is
evaluated, and its return value becomes the return value of the dohash form. If
there is no <result-form>, the return value is nil.

The <result-form> and <body-form>-s are in the scope of an implicit anonymous
block, which means that it is possible to terminate the execution of
dohash early using (return) or (return <value>).

.SS Functions hash-uni, hash-diff, hash-isec

.TP
Syntax:

  (hash-uni <hash1> <hash2> [<join-func>])
  (hash-diff <hash1> <hash2>)
  (hash-isec <hash1> <hash2> [<join-func>])

.TP
Description:

These functions perform basic set operations on hash tables in a nondestructive
way, returning a new hash table without altering the inputs. The arguments
<hash1> and <hash2> must be compatible hash tables.  This means that their keys
must use the same kind of equality.

The resulting hash table inherits attributes from <hash1>, as if by the
make-similar-hash operation. If <hash1> has userdata, the resulting hash table
has the same userdata. If <hash1> has weak keys, the resulting table has weak
keys, and so forth.

The hash-uni function performs a set union. The resulting hash contains all of
the keys from <hash1> and all of the keys from <hash2>, and their corresponding
values.  If a key occurs both in <hash1> and <hash2>, then it occurs only once
in the resulting hash. In this case, if the <join-func> argument is not given
specified, value associated with this key is the one from <hash1>. If
<join-func> is specified then it is called with two arguments: the respective
data items from <hash1> and <hash2>. The return value of this function is used
as the value in the union hash.

The hash-diff function performs a set difference. First, a copy of <hash1> is
made as if by the copy-has function. Then from this copy, all keys which occur
in <hash2> are deleted.

The hash-isec function performs a set intersection. The resulting hash contains
only those keys which occur both in <hash1> and <hash2>. If <join-func> is not
specified, the values selected for these common keys are those from <hash1>.
If <join-func> is specified, then for each key which occurs in both <hash1> and
<hash2>, it is called with two arguments: the respective data items. The return
value is then used as the data item in the intersection hash.

.SH PARTIAL EVALUATION AND COMBINATORS

.SS Macros op and do

.TP
Syntax:

  (op <form>+)
  (do <form>+)

.TP
Description:

The op and do macro operators are similar.

Like the lambda operator, the op operator creates an anonymous function.
The difference is that the arguments of the function are implicit, or
optionally specified within the function body.

Also, the <form> arguments of op are implicitly turned into a DWIM expression,
which means that argument evaluation follows Lisp-1 rules.  (See the dwim
operator below).

The do operator is like the op operator with the following difference:
the <form> arguments of op are not implicitly treated as a DWIM expression,
but as an ordinary expression. In particular, this means that operator
syntax is permitted. Note that the syntax (op @1) makes sense, since
the argument can be a function, which will be invoked, but (do @1) doesn't
make sense because it will produce a Lisp-2 form like (#:arg1 ...) referring
to nonexistent function #:arg1. This is why the operator is called "do": it
requires some operation. Moreover, it can be used with imperative constructs
which are not functions, like set: like set: for instance (do set x) produces
an anonymous function which, if called with one argument, stores that argument
into x.

The argument forms are arbitrary expressions, within which a special
convention is permitted:

.IP @<num>

A number preceded by a @ is a metanumber. This is a special syntax
which denotes an argument. For instance @2 means that the second argument of
the anonymous function is to be substituted in place of the @2. If @2 is used
it means that @1 also has to appear somewhere, otherwise the op
construct is erroneous.

.IP @rest

The meta-symbol @rest indicates that any trailing arguments to the
function are to be inserted there. If the form does not contain
any @<num> syntax or @rest syntax, then @rest is implicitly
inserted.  What this means is that, for example, since the form (op foo) does
not contain any numeric positional arguments like @1, and does not contain
@rest, it is actually a shorthand for (op foo . @rest).

The actions of form may be understood by these examples, which show
how op is rewritten to lambda.  However, note that the real translator
uses generated symbols for the arguments, which are not equal to any
symbols in the program.

  (op) -> invalid

  (op +) -> (lambda rest [+ . rest])

  (op + foo) -> (lambda rest [+ foo . rest])

  (op @1 @2) -> (lambda (arg1 arg2 . rest) [arg1 arg2])

  (op @1 . @rest) -> (lambda (arg1 . rest) [arg1 . @rest])

  (op @1 @rest) -> (lambda (arg1 . rest) [arg1 @rest])

  (op @1 @2) -> (lambda (arg1 arg2 . rest) [arg1 arg2])

  (op foo @1 (@2) (bar @3)) -> (lambda (arg1 arg2 arg3 . rest) 
                                  [foo arg1 (arg2) (bar arg3)])

  (op foo @rest @1) -> (lambda (arg1 . rest) [foo rest arg1])

  (do + foo) -> (lambda rest (+ foo . rest))

  (do @1 @2) -> (lambda (arg1 arg2 . rest) (arg1 arg2))

  (do foo @rest @1) -> (lambda (arg1 . rest) (foo rest arg1))

Note that if argument @<n> appears, it is not necessary
for arguments @1 through @<n-1> to appear. The function
will have n arguments:

  (op @3) -> (lambda (arg1 arg2 arg3 . rest) [arg3])


.PP

.TP
Examples:

  ;; Take a list of pairs and produce a list in which those pairs
  ;; are reversed.

  (mapcar (op list @2 @1) '((1 2) (a b)))   ->   ((2 1) (b a))

.TP
Nested op:

The op and do operators can be nested, in any combination. This raises the
question: if a metanumber like @1 or @rest occurs in an op that is nested
within an op, what is the meaning?

A metanumber always belongs with the inner-most op or do operator. So for
instance  (op (op @1)) means that an (op @1) expression is nested
within an op expression. The @1 belongs with the inner op.

There is a way to refer to an outer op metanumber argument, we need to
add a meta for every level of escape. For example in (op (op @@1)) 
the @@1 belongs to the outer op: it is the same as @1. That is to say, 
in the expression (op @1 (op @@1)), the @1 and @@1 are the same thing:
parameter 1 of the lambda function generated by the outer op.
In the expression (op @1 (op @1)) there are two different parameters:
the first @1 is argument of the outer function, and the second @1
is the first argument of the inner function. Of course, if there
are three levels of nesting, then three metas are needed to insert
a parameter from the outermost op, into the innermost op.

.SS Macros ap, ip, ado and ido.

.TP
Syntax:

  (ap <form>+)
  (ip <form>+)
  (ado <form>+)
  (ido <form>+)

.TP
Description:

The ap macro is based on the op macro and has identical argument
conventions.

The ap macro analyzes its arguments and produces a function, in exactly the
same same way as the op macro.   It then returns a different one-argument
function which accepts a list, and calls that function, applying the
list as arguments.

In other words, the following equivalence holds:

  (ap form ...) <--> (apf (op form ...))

The ap macro nests properly with op and do, in any combination, in regard
to the @@n notation.

The ip macro is very similar to the ap macro, except that it is based
on the semantics of the function iapply rather than apply, according
to the following equivalence:

  (ip form ...) <--> (ipf (op form ...))

The ado and ido macros is related to do macro in the same way that ap and ip
are related to op. They produce a one-argument function is produced which works
as if by applying its arguments to the function generated by do,
according to the following equivalence:

  (ado form ...) <--> (apf (do form ...))

  (ido form ...) <--> (ipf (do form ...))

See also: the apf and ipf functions.

.SS Macro ret

.TP
Syntax:

  (ret <form>)

.TP
Description:

The ret macro's argument is treated similarly to the arguments of the op
operator, except that the first form of the op operator denotes
a function to be called where as the one and only argument form of the
ret operator denotes a value.

The ret macro produces a function which takes any number of arguments,
and returns the value specified by <form>.

The following equivalence holds:

  (ret x) <--> (op identity (progn @rest x))

where the @rest parameter is mentioned for its side effect of making
op generate a function which accepts any number of arguments.

The expression (ret @2) returns a function similar to
(lambda (x y . z) y).

The expression (ret 42) returns a function similar to
(lambda (. rest) 42).

.SS Function chain

.TP
Syntax:

   (chain <func>*)

.TP
Description:

The chain function accepts zero or more functions as arguments, and returns
a single function, called the chained function, which represents the chained
application of those functions, in left to right order.

If chain is given no arguments, then it returns a variadic function which
ignores all of its arguments and returns nil.

Otherwise, the first function may accept any number of arguments. The second
and subsequent functions, if any, must accept one argument.

The chained function can be called with an argument list which is acceptable
to the first function. Those arguments are in fact passed to the first
function. The return value of that call is then passed to the second
function, and the return value of that call is passed to the third function
and so on. The final return value is returned to the caller.

.TP
Example:

  (call [chain + (op * 2)] 3 4) -> 14

In this example, a two-element chain is formed from the + function
and the function produced by (op * 2) which is a one-argument
function that returns the value of its argument multiplied by two.
(See the definition of the op operator).

The chained function is invoked using the call function, with the arguments 3
and 4. The chained evaluation begins by passing 3 and 4 to the + function,
which yields 7.  This 7 is then passed to the (op * 2) doubling function,
resulting in 14.

A way to write the above example without the use of the DWIM brackets and the
op operator is this:

  (call (chain (fun +) (lambda (x) (* 2 x))) 3 4)

.SS Function juxt

.TP
Syntax:

  (juxt <func>*)

.TP
Description:

The juxt function accepts a variable number of arguments which are functions.
It combines these into a single function which, when invoked, passes its arguments
to each of the functions, and collects the results into a list. The results

Note: the juxt function can be understood in terms of the following reference
implementation:

  (defun juxt (funcs)
    (lambda (. args)
      (mapcar (lambda (fun)
                (apply fun args))
              funcs)))

.TP
Example:

   ;; separate list (1 2 3 4 5 6) into lists of evens and odds, which end up
   ;; juxtaposed in the output list:

   [(op [juxt keep-if remove-if] evenp) '(1 2 3 4 5 6)] -> ((2 4 6) (1 3 5))

   ;; call several functions on 1, collecting their results:
   [[juxt (op + 1) (op - 1) evenp sin cos] 1]'
   -> (2 0 nil 0.841470984807897 0.54030230586814)

.SS Functions andf and orf

.TP
Syntax:

  (andf <func>*)
  (orf <func>*)

.TP
Description:

The andf and orf functions are the functional equivalent of the and and or
operators. These functions accept multiple functions and return a new function
which represents the logical combination of those functions.

The input functions should have the same arity. Or, rather, there should exist
some common argument arity with which they can all be invoked. The resulting
combined function is then callable with that many arguments.

The andf operator returns a function which combines the input functions with
short-circuiting logical conjunction. The resulting function passes its
arguments to the functions successively, in left to right order. As soon as any
of the functions returns nil, then nil is returned immediately, and the
remaining functions are not called.  Otherwise, if none of the functions return
nil, then the value returned by the last function is returned. If the list of
functions is empty, then t is returned.  That is, (andf) returns a function
which accepts any arguments, and returns t.

The orf operator combines the input functions with a short-circuiting logical
disjunction. The function produced by orf passes its arguments down to the
functions successively, in left to right order.  As soon as any function
returns a non-nil value, that value is returned and the remaining functions are
not called. If all functions return nil, then nil is returned. The expression
(orf) returns a function which accepts any arguments and returns nil.


.SS Functions iff and iffi

.TP
Syntax:

  (iff <cond-func> <then-func> [<else-func>])
  (iffi <cond-func> <then-func> [<else-func>])

.TP
Description:

The iff function is the functional equivalent of the if operator. It accepts
functional arguments and returns a function.

The resulting function takes its arguments and applies them to <cond-func>.  If
<cond-func> yields true, then the arguments are passed to <then-func> and the
resulting value is returned. Otherwise the arguments are passed to <else-func> 
and the resulting value is returned.

If <then-func> needs to be called, but is nil, then nil is returned
immediately.  Likewise, if <else-func> needs to be called, but is omitted or
nil, then nil is returned.

The iffi function differs from iff only in the defaulting behavior with respect
to the <else-func> argument. The following equivalences hold:

  (iffi a b c)   <--> (iff a b c)

  (iffi a b)     <--> (iff a b identity)

  (iffi a b nil) <--> (iff a b identity)

The iffi function defaults to the identity function when <else-func> is
omitted or nil, and therefore is useful in situations when one value is to be
replaced with another one when the condition is true, otherwise left alone.

.SS Functions tf and nilf

.TP
Syntax:

  (tf <arg>*)
  (nilf <arg>*)

.TP
Description:

The tf and nilf functions take zero or more arguments, and ignore them.
The tf function returns t, and the nilf function returns nil.

.TP
Example:

  ;; tf and nilf are useful when functions are chained together.
  ;; test whether (trunc n 2) is odd.

  (defun trunc-n-2-odd (n)
    [[chain (op trunc @1 2) [iff oddp tf nilf]] n)

In this example, two functions are chained together, and n is passed
through the chain such that it is first divided by two via the
function denoted by (op trunc @1 2) and then the result is passed into the
function denoted by [iff oddp tf nilf]. The iff function passes its
argument into oddp, and if oddp yields true, it passes the same argument to tf.
Here tf proves its utility by ignoring that value and returning t.
If the argument (the divided value) passed into iff is even, then
iff passes it into the nilf function, which ignores the value and
returns nil.

.SS Function retf

.TP
Syntax:

  (retf <value>)

.TP
Description:

The retf function returns a function. That function can take zero or
more arguments. When called, it ignores its arguments and returns <value>.

See also: the ret macro.

.TP
Example:

  ;; the function returned by (retf 42) ignores 1 2 3 and returns 42.
  (call (retf 42) 1 2 3) -> 42

.SS Functions apf and ipf

.TP
Syntax:

  (apf <function>)
  (ipf <function>)

.TP
Description:

The apf function returns a one-argument function which accepts
a list. When the function is called, it treats the list as
argument which are applied to <function> as if by apply. It returns whatever
<function> returns.

The ipf function is similar to apf, except that the returned
function applies arguments as if by iapply rather than apply.

See also: the ap macro.

.TP
Example:

  ;; Function returned by [apf +] accepts (1 2 3) list and
  ;; applies it to +, as if (+ 1 2 3) were called.

  (call [apf +] '(1 2 3)) -> 6

.SH INPUT AND OUTPUT (STREAMS)

TXR Lisp supports input and output streams of various kinds, with
generic operations that work across the stream types.

In general, I/O errors are usually turned into exceptions. When the description
of error reporting is omitted from the description of a function, it can be
assumed that it throws an error.

.SS Special variables *stdout*, *stddebug*, *stdin*, *stderr* and *stdnull*

These variables hold predefined stream objects. The *stdin*, *stdout* and
*stderr* streams closely correspond to the underlying operating system streams.
Various I/O functions require stream objects as arguments.

The *stddebug* stream goes to the same destination as *stdout*, but is
a separate object which can be redirected independently, allowing debugging
output to be separated from normal output.

The *stdnull* stream is a special kind of stream called a null stream.
This stream is not connected to any device or file.  It is similar to
the /dev/null device on Unix, but does not involve the operating system.

.SS Function format

.TP
Syntax:

  (format <stream-designator> <format-string> <format-arg>*)

.TP
Description:

The format function performs output to a stream given by <stream-designator>,
by interpreting the actions implicit in a <format-string>, incorporating
material pulled from additional arguments given by <format-arg>*. Though the
function is simple to invoke, there is complexity in format string language,
which is documented below.

The <stream-designator> argument can be a stream object, or one of the values t
and nil. The value t serves as a shorthand for *stdout*. The value nil
means that the function will send output into a newly instantiated string
output stream, and then return the resulting string.

.TP
Format string syntax:

Within <format-string>, most characters represent themselves. Those
characters are simply output. The character ~ (tilde) introduces formatting
directives, which are denoted by a letter. 

The special sequence ~~ (tilde-tilde) codes a single tilde. Nothing is
permitted between the two tildes.

The syntax of a directive is generally as follows:

  ~[<width>[,<precision>]]<letter>

The <letter> is a single alphabetic character which determines the
general action of the directive. The optional width and precision
can be numeric digits, or special codes documented below. 

.TP
width

The width specifier consists of an optional < (left angle bracket) character,
followed by an optional width specification.

If the < character is present, then the printing will be left-adjusted within
this field. Otherwise it will be right-adjusted by default.  

The width can be specified as a decimal integer, or as the character *. The *
notation means that instead of digits, the value of the next argument is
consumed, and expected to be an integer which specifies the width. If that
integer value is negative, then the field will be left-adjusted.  
If the value is positive, but the < character is present in the width
specifier, then the field is left adjusted also.

.TP
precision

The precision specifier consists of an optional combination of the
special leading characters 0 (the "leading zero flag"), + (print a sign for
positive values") or space (print a space in place of a positive sign),
followed by a specification of the precision value, which is either a decimal
integer that does not begin with a zero digit, or the * character.

The precision field's components have a meaning which depends on the type of
object printed and the conversion specifier.

For integer arguments, the precision value specifies the minimum number of digits
to print.  If the precision field has a leading zero flag, then the integer is
padded with zeros to the required number of digits, otherwise the number is
padded with spaces instead of zeros.  If zero or space padding is present, and
a leading positive or negative sign must be printed, then it is placed before
leading zeros, or after leading spaces, as the case may be.

For floating-point values, the meaning of the precision value depends on which
specific conversion specifier (f, e, a or s) is used. The details are
documented in the description of each of these, below. The leading zero flag is
ignored for floating-point values regardless of the conversion specifier.

For integer or floating-point arguments, if the precision specifier has a + sign
among the special characters, then a + sign is printed for positive numbers. If
the precision specifier has a leading space instead of a + sign, then the +
sign is rendered as a space for positive numbers. If there is no leading space
or +, then a sign character is omitted for positive numbers. Negative
numbers are unconditionally prefixed with a - sign.

For all other objects, the precision specifies the maximum number of characters
to print.  The object's printed representation is crudely truncated at that
number of characters.

.TP
Format directives:

Format directives are case sensitive, so that for example ~x and ~X have a
different effect, and ~A doesn't exist whereas ~a does. They are:

.IP a
Prints any object in an aesthetic way, as if by the pprint function.
The aesthetic notation violates read-print consistency: this notation
is not necessarily readable if it is implanted in TXR source code.
The field width specifier is honored, including the left-right adjustment
semantics. 

When this specifier is used for floating-point values, the precision specifies
the maximum number of total significant figures, which do not include any
digits in the exponent, if one is printed. Numbers are printed in exponential
notation if their magnitude is small, or else if their exponent exceeds their
precision. (If the precision is not specified, then it defaults to the
system-dependent number of digits in a floating point value, derived from the C
language DBL_DIG constant.) Floating point values which are integers are
printed without a trailing .0 (point zero). 

.IP s
Prints any object in a standard way, as if by the print function.  Objects for
which read-print consistency is possible are printed in a way such that
if their notation is implanted in TXR source, they are readable.
The field width specifier is honored, including the left-right adjustment
semantics. The precision field is treated very similarly to the ~a
format directive, except that non-exponentiated floating point numbers that
would be mistaken for integers include a trailing ".0" for the sake read-print
consistency. Objects truncated by precision may not have read-print
consistency. For instance, if a string object is truncated, it loses its
trailing closing quote, so that the resulting representation is no longer
a properly formed string object.

.IP x
Requires an argument of character or integer type. The integer value or
character code is printed in hexadecimal, using lower-case letters
for the digits "a" through "f". Width and precision semantics
are as described for the "a" format directive, for integers.

.IP X
Like the "x" directive, but the digits "a" through "f" are rendered
in upper case.

.IP o
Like the "x" directive, but octal is used instead of hexadecimal.

.IP f
The "f" directive prints numbers in a fixed point decimal notation, with
a fixed number of digits after the decimal point. It requires a numeric
argument. (Unlike "x", "X" and "o", characters are not permitted).
The precision specifier gives the number of digits past the decimal point.
The number is rounded off to the specified precision, if necessary.
Furthermore, that many digits are always printed, regardless of the actual
precision of the number or its type.  If it is omitted, then the default value
is three: three digits past the decimal point. A precision of zero means no
digits pas the decimal point, and in this case the decimal point is suppressed
(regardless of whether the numeric argument is floating-point or integer).  

.IP e
The "e" directive prints numbers in exponential notation. It requires
a numeric argument. (Unlike "x", "X" and "o", characters are not permitted).
The precision specifier gives the number of digits past the decimal point
printed in the exponential notation, not counting the digits in the exponent.
Exactly that many digits are printed, regardless of the precision of the
number.  If the precision is omitted, then the number of digits after the
decimal point is three. If the precision is zero, then a decimal portion is
truncated off entirely, including the decimal point.

.PP

.SS Functions print, pprint, prinl, pprinl, tostring, tostringp

.TP
Syntax:

  (print <obj> [<stream>])
  (pprint <obj> [<stream>])
  (prinl <obj> [<stream>])
  (pprinl <obj> [<stream>])
  (tostring <obj>)
  (tostringp <obj>)

.TP
Description:

The print and pprint functions render a printed character representation of the
<obj> argument into <stream>. If a stream argument is not supplied, then 
the destination is the stream currently stored in the *stdout*
variable. The print function renders in a way which strives for read-print
consistency: an object is printed in a notation which is recognized as
a similar object of the same kind when it appears in TXR source code.
The pprint function ("pretty print") does not strive for read-print consistency.
For instance it prints a string object simply by dumping its characters, rather
than by adding the surrounding quotes and rendering escape syntax for
special characters. Both functions return <obj>.

The prinl and pprinl functions are like print and pprint, except
that they issue a newline character after printing the object.
These functions also return <obj>.

The tostring and tostringp functions are like print and pprint, but
they do not accept a stream argument, instead printing to a freshly
instantiated string stream, and returning the resulting string.

The following equivalences hold between calls to the format function
and calls to these functions:

  (format stream "~s" obj)  <-->  (print obj stream)
  (format t "~s" obj)       <-->  (print obj)
  (format t "~s\en" obj)     <-->  (prinl obj)
  (format nil "~s" obj)     <-->  (tostring obj)

For pprint, tostringp and pprinl, the equivalence is produced by using "~a" in
format rather than "~s".

Note: for characters, the print function behaves as follows: most control
characters in the Unicode C0 and C1 range are rendered using the #\ex notation,
using two hex digits. Codes in the range D800 to DFFF, and the codes
FFFE and FFFF are printed in the #\exNNNN with four hexadecimal digits, and
character above this range are printed using the same notation, but with six
hexadecimal digits. Certain characters in the C0 range are printed using
their names such as #\enul and #\ereturn, which are documented
in the Character Literals section not far from the start of this document.
The DC00 character is printed as #\epnul.  All other characters are printed as
#\e<char>, where <char> is the actual character.

Caution: read-print consistency is affected by trailing material. If additional
digits are printed immediately after a number without intervening whitespace,
they extend that number. If hex digits are printed after the character x,
which is rendered as #\ex, they look like a hex character code.

.SS Function streamp

.TP
Syntax:

  (streamp <obj>)

.TP
Description:

The streamp function returns t if <obj> is any type of stream.
Otherwise it returns nil.

.SS Function real-time-stream-p

.TP
Syntax:

  (real-time-stream-p <obj>)

.TP
Description:

The real-time-streamp-p function returns t if <obj> is a stream marked as
"real-time".  If <obj> is not a stream, or not a stream marked as "real-time",
then it returns nil.

Note: the expression (real-time-stream-p S) is almost like
(stream-get-prop S :real-time), except the latter requires S to be a stream.

Only certain kinds of streams accept the real-time attribute: file streams and
tail streams. This attribute controls the semantics of the application of
lazy-stream-cons to the stream.  For a real-time stream, lazy-stream-cons
returns a stream with "naive" semantics which returns data as soon as it is
available, at the cost of generating spurious nil item when the stream
terminates. The application has to recognize and discard that nil item.
The ordinary lazy streams read ahead by one line and suppress this extra
item, so their representation is more accurate.

Streams connected to TTY devices (devices which for which the isatty function
reports true) are marked as real-time. This is only supported on platforms that
have an isatty function.


.SS Function make-string-input-stream

.TP
Syntax:

  (make-string-input-stream <string>)

.TP
Description:

This function produces an input stream object. Character read operations on the
stream object read successive characters from <string>. Output
operations and byte operations are not supported.

.SS Function make-string-byte-input-stream

.TP
Syntax:

  (make-string-byte-input-stream <string>)

.TP
Description:

This function produces an input stream object. Byte read operations on
this stream object read successive byte values obtained by encoding
<string> into UTF-8. Character read operations are not supported, and neither
are output operations.

.SS Function make-string-output-stream

.TP
Syntax:

  (make-string-output-stream)

.TP
Description:

This function, which takes no arguments, creates a string output stream.
Data sent to this stream is accumulated into a string object.
String output streams supports both character and byte output operations. 
Bytes are assumed to represent a UTF-8 encoding, and are decoded in order
to form characters which are stored into the string. 

If an incomplete UTF-8 code is output, and a character output operation then
takes place, that code is assumed to be terminated and is decoded as invalid
bytes.  The UTF-8 decoding machine is reset and ready for the start of a new
code.

The get-string-from-stream function is used to retrieve the accumulated
string.

If the null character is written to a string output stream, either via
a character output operation or as a byte operation, the resulting string
will appear to be prematurely terminated. TXR strings cannot contain null
bytes.

.SS Function get-string-from-stream

.TP
Syntax:

  (get-string-from-stream <stream>)

.TP
Description:

The <stream> argument must be a string output stream. This function finalizes
the data sent to the stream and retrieves the accumulated character string.

If a partial UTF-8 code has been written to <stream>, and then this
function is called, the byte stream is considered complete and the partial
code is decoded as invalid bytes.

After this function is called, further output on the stream is not possible.

.SS Function make-strlist-output-stream

.TP
Syntax:

  (make-strlist-output-stream)

.TP
Description:

This function is closely analogous to make-string-output-stream. However,
instead of producing a string, it produces a list of strings. The
data is broken into multiple strings by newline characters written
to the stream. Newline characters do not appear in the string list. Also, byte
output operations are not supported.

.SS Function get-list-from-stream

.TP
Syntax:

  (get-list-from-stream <stream>)

.TP
Description:

This function returns the string list which has accumulated inside
a string output stream given by <stream>. The string output stream is
finalized, so that further output is no longer possible.

.SS Function close-stream

.TP
Syntax:

  (close-stream <stream> [<throw-on-error-p>])

.TP
Description:

The close-stream function performs a close operation on <stream>,
whose meaning is depends on the type of the stream. For some types of streams,
such as string streams, it does nothing. For streams which are connected
to operating system files or devices, will perform a close of the underlying
file descriptor, and dissociate that descriptor from the stream. Any buffered
data is flushed first.

The function returns a boolean true value if the close has occurred without
errors, otherwise nil.

For most streams, "without errors" means that any buffered output data is
flushed successfully.

For command and process pipes (see open-command and open-process), success also
means that the process terminates normally, with a successful error code, or an
unsuccessful one. An abnormal termination is considered an error, as
as is the inability to retrieve the termination status, as well as the situation
that the process continues running in spite of the close attempt.
Detecting these situations is platform specific.

If the <throw-on-error-p> argument is specified, and isn't nil, then the
function throws an exception if an error occurs during the close operation
instead of returning nil.

.SS Functions get-line, get-char and get-byte

.TP
Syntax:

  (get-line [<stream>])
  (get-char [<stream>])
  (get-byte [<stream>])

.TP
Description:

These fundamental stream functions perform input.  The <stream> argument
is optional. If it is specified, it should be an input stream which supports
the given operation. If it is not specified, then the *stdin* 
stream is used.

The get-char function pulls a character from a stream which supports character
input.  Streams which support character input also support the get-line
function which extracts a line of text delimited by the end of the stream or a
newline character and returns it as a string. (The newline character does not
appear in the string which is returned). 

Character input from streams based on bytes requires UTF-8 decoding, so that
get-char actually may read several bytes from the underlying low level
operating system stream.

The get-byte function bypasses UTF-8 decoding and reads raw bytes from
any stream which supports byte input. Bytes are represented as integer
values in the range 0 to 255.

Note that if a stream supports both byte input and character input, then mixing
the two operations will interfere with the UTF-8 decoding.

These functions return nil when the end of data is reached.  Errors are
represented as exceptions.

See also: get-lines

.SS Function get-string

.TP
Syntax:

  (get-string [<stream> [<count>]])

.TP
Description:

The get-string function reads characters from a stream, and assembles them into
a string, which is returned. If the <stream> argument is omitted, then the
*stdin* stream is used.

If the <count> argument is missing, then all of the characters from the
stream are read and assembled into a string.

If present, the <count> argument should be a positive integer indicating
a limit on how many characters to read. The returned string will be no
longer than <count>, but may be shorter.

.SS Functions unget-char and unget-byte

.TP
Syntax:

  (unget-char <char> [<stream>])
  (unget-byte <byte> [<stream>])

.TP
Description:

These character put back, into a stream, a character or byte which was
previously read.  The character or byte must match the one which was most
recently read. If the <stream> argument is omitted, then the *stdin*
stream is used.

If the operation succeeds, the byte or character value is returned.
A nil return indicates that the operation is unsupported.

Some streams do not support these operations; some support
only one of them.   In general, if a stream supports get-char,
it supports unget-char, and likewise for get-byte and unget-byte.

Space is available for only one character or byte of pushback.

Pushing both a byte and a character, in either order, is  also unsupported.
Pushing a byte and then reading a character, or pushing a character and
reading a byte, are also unsupported mixtures of operations.

If the stream is binary, then pushing back a byte decrements its position,
except if the position is already zero. At that point, the position becomes
indeterminate.

.SS Functions put-string, put-line, put-char and put-byte

.TP
Syntax:

  (put-string <string> [<stream>])
  (put-line [<string> [<stream>]])
  (put-char <char> [<stream>])
  (put-byte <byte> [<stream>])

.TP
Description:

These functions perform output on an output stream. The <stream> argument
must be an output stream which supports the given operation. If it is omitted,
then *stdout* is used.

The put-char function writes a character given by <char> to a stream. If the
stream is based on bytes, then the character is encoded into UTF-8 and multiple
bytes are written. Streams which support put-char also support put-line, and
put-string.

The put-string function writes the characters of a string out to
the stream as if by multiple calls to put-char. The <string> argument
may be a symbol, in which case its name is used as the string.

The put-line function is like put-string, but also writes an additional newline
character. The string is optional in put-line, and defaults to the empty
string.

The put-byte function writes a raw byte given by the <byte> argument
to <stream>, if <stream> supports a byte write operation. The byte
value is specified as an integer value in the range 0 to 255.

.SS Functions put-strings and put-lines

.TP
Syntax:

  (put-strings <sequence> [<stream>]])
  (put-lines <sequence> [<stream>]])

.TP
Description:

These functions assume <sequence> to be a sequence of strings, or of
symbols, or a mixture thereof. These strings are sent to the stream.  The
<stream> argument must be an output stream.  If it is omitted, then *stdout* is
used.

The put-strings function iterates over <sequence> and writes each element
to the stream as if using the put-string function.

The put-lines function iterates over <sequence> and writes each element
to the stream as if using the put-line function.

Both functions return t.

.SS Function flush-stream

.TP
Syntax:

  (flush-stream <stream>)

.TP
Description:

This function is meaningful for output streams which accumulate data
which is passed on to the operating system in larger transfer units.
Calling this function causes all accumulated data inside <stream> to be passed
to the operating system. If called on streams for which this function is not
meaningful, it does nothing.

.SS Function seek-stream

.TP
Syntax:

  (seek-stream <stream> <offset> <whence>)

.TP
Description:

The seek-stream function is meaningful for file streams. It changes the
current read/write position within <stream>.  It can also be used
to determine the current position: see the notes about the
return value below. 

The <offset> argument is a positive or negative integer which gives a
displacement that is measured from the point identified by the <whence>
argument.

Note that for text files, there isn't necessarily a 1:1 correspondence between
characters and positions due to line-ending conversions and conversions
to and from UTF-8.

The <whence> argument is one of three keywords: :from-start, :from-current
and :from-end. These denote the start of the file, the current position
and the end of the file.

If <offset> is zero, and <whence> is :from-current, then
seek-stream returns the current absolute position within the
stream, if it can successfully obtain it. Otherwise, it
returns t if it is successful.

If a character has been successfully put back into a text stream with
unget-char and is still pending, then the position value is unspecified. If a
byte has been put back into a binary stream with unget-byte, and the previous
position wasn't zero, then the position is decremented by one.

On failure, it throws an exception of type stream-error.

.SS Functions stream-get-prop and stream-set-prop

.TP
Syntax:

  (stream-get-prop <stream> <indicator>)
  (stream-set-prop <stream> <indicator> <value>)

.TP
Description:

These functions get and set properties on a stream. Only certain properties
are meaningful with certain kinds of streams, and the meaning depends on
the stream. If two or more stream types support a property of the same name, it
is expected that the property has the same or very similar meaning for both
streams to the maximum extent that similarity is possible possible.

The stream-set-prop function sets a property on a stream. The <indicator>
argument is a symbol, usually a keyword symbol, denoting the property,
and <value> is the property value. If the stream understands and accepts the
property, the function returns t. Otherwise it returns nil.

The stream-get-prop function inquires about the value of a property on a
stream. If the stream understands the property, then it returns its current
value.  If the stream does not understand a property, nil is returned, which is
also returned if the property exists, but its value happens to be nil. 

Properties are currently used for marking certain streams as "real-time" (see
the stream-real-time-p function above), and also for setting the priority at
which messages are reported to syslog by the *stdlog* stream (see *stdlog*
in the UNIX SYSLOG section).

If <stream> is a catenated stream (see the function make-catenated-stream)
then these functions transparently operate on the current head stream of the
catenation.

.SS Function make-catenated-stream

.TP
Syntax:

  (make-catenated-stream <stream>*)

.TP
Description

The make-catenated-stream function takes zero or more arguments which
are input streams of the same type.

A catenated stream does not support seeking operations or output,
regardless of the capabilities of the streams in the list.

If the stream list is not empty, then the leftmost element of the
list is called the head stream.

The get-char, get-byte, get-line, unget-char and unget-byte delegate
to the corresponding operations on the head stream, if it exists.
If the stream list is empty, they return nil to the caller.

The a get-char, get-byte or get-line operation on the head stream yields nil,
and there are more lists in the stream, then the stream is removed from the
list, and the next stream, if any, becomes the head list. The operation is then
tried again.  If any of these operations fail on the last list, it is not
removed from the list, so that a stream remains in place which can take
the unget-char or unget-byte operations.

In this manner, the catenated streams appear to be a single stream.

Note that the operations can fail due to being unsupported. It is
the caller's responsibility to make sure all of the streams in the list
are compatible with the intended operations.

If the stream list is empty then an empty catenated stream is produced.
Input operations on this stream yield nil, and the unget-char
and unget-byte operations throw an exception.

.SS Functions open-files and open-files*

.TP
Syntax:

  (open-files <path-list> [<alternative-stream>])
  (open-files* <path-list> [<alternative-stream>])

.TP
Description:

The open-files and open-files* functions create a list of streams by invoking
the open-file function on each element of <path-list>. These streams are turned
into a catenated stream as if applied as arguments to make-catenated-stream.

The effect is that multiple files appear to be catenated together into a single
input stream.

If the optional <alternative-stream> argument is supplied, then if <path-list>
is empty, that argument is returned instead of an empty catenated stream.

The difference between open-files and open-files* is that open-files creates all of the
streams up-front. So if any of the paths cannot be opened, the operation throws.
The open-files* variant is lazy: it creates a lazy list of streams out of the
path list. The streams are opened as needed: before the second stream is opened,
the program has to read the first stream to the end, and so on.

.TP
Example:

Collect lines from all files that are given as arguments on the command line. If
there are no files, then read from standard input:

   @(next @(open-files *args* *stdin*))
   @(collect)
   @line
   @(end)

.SS Function abs-path-p

.TP
Syntax:

  (abs-path-p <path>)

.TP
Description:

The abs-path-function whether the argument <path> is an absolute path.
If this is true, it returns t, otherwise nil.

An absolute path is a string which either begins with a slash or backslash
character, or which begins with an alphanumeric word, followed by a colon,
followed by a slash or backslash.

Examples of absolute paths:

  /etc

  c:/tmp

  ftp://user@server

  disk0:/home

  Z:\eUsers

Examples of strings which are not absolute paths.

  (the empty string)
  .
  abc
  foo:bar/x
  $:\eabc

.SS Function read

.TP
Syntax:

   (read [ <source> [<error-stream>] ])
   (lisp-parse <source> [<error-stream>]) ;; obsolescent synonym for read

.TP
Description:

The read function converts text denoting TXR Lisp structure, into the
corresponding data structure. The <source> argument may be either a character
string, or a stream.  If it is omitted, then *stdin* is used as the stream.

The source must provide the text representation of one complete TXR Lisp object.

Multiple calls to read on the same stream will extract successive objects
from the stream. To parse successive objects from a string, it is necessary
to convert it to a string stream.

The optional <error-stream> argument can be used to specify a stream to which
parse errors diagnostics are sent. If absent, the diagnostics are suppressed.

If there are parse errors, the function returns nil; otherwise, it returns the
parsed data structure.

.SH FILESYSTEM ACCESS

.SS Function stat

.TP
Syntax:

  (stat <path>)

.TP
Description:

The stat function inquires the filesystem about the existence of an object
denoted by the string <path>. If the object is not found or cannot be
accessed, an exception is thrown.

Otherwise information is retrieved about the object. The information takes the
form of a property list in which keyword symbols denote numerous properties.
An example such property list is (:dev 2049 :ino 669944 :mode 16832 :nlink 23
:uid 500 :gid 500 :rdev 0 :size 12288 :blksize 4096 :blocks 24 :atime
1347933533 :mtime 1347933534 :ctime 1347933534)

These properties correspond to the similarly-named entries of the struct stat
structure in POSIX. For instance, the :dev property has the same value 
as the st_dev field.

.SS Special variables s-ifmt s-iflnk s-ifreg s-ifblk ... s-ixoth

The following variables exist, having integer values. These are bitmasks
which can be applied against the value given by the :mode property
in the property list returned by the function stat: s-ifmt, s-ifsock, s-iflnk,
s-ifreg, s-ifblk, s-ifdir, s-ifchr, s-ififo, s-isuid, s-isgid, s-isvtx,
s-irwxu, s-irusr, s-iwusr, s-ixusr, s-irwxg, s-irgrp, s-iwgrp, s-ixgrp,
s-irwxo, s-iroth, s-iwoth and s-ixoth.

These variables correspond to the C constants S_IFMT, S_IFLNK, S_IFREG
and so forth.

The logtest function can be used to test these against values of mode.
For example (logtest mode s-irgrp) tests for the group read permission.

.SS Function open-directory

.TP
Syntax:

  (open-directory <path>)

.TP
Description:

The open-directory function tries to create a stream which reads the
directory given by the string argument <path>. If a filesystem object exists
under the path, is accessible, and is a directory, then the function
returns a stream. Otherwise, a file error exception is thrown.

The resulting stream supports the get-line operation. Each call to the
get-line operation retrieves a string representing the next directory
entry. The value nil is returned when there are no more directory entries.
The . and .. entries in Unix filesystems are not skipped.

.SS Function open-file

.TP
Syntax:

  (open-file <path> [<mode-string>])

.TP
Description:

The open-file function creates a stream connected to the file
which is located at the given <path>, which is a string.

The <mode-string> argument is a string which uses the same
conventions as the mode argument of the C language fopen function.
The mode string determines whether the stream is an input stream
or output stream. Note that the "b" mode is not supported.
Whether a stream is text or binary depends on which operations
are invoked on it.

If the <mode-string> argument is omitted, the mode "r" is used.

.SS Function open-tail

.TP
Syntax:

  (open-tail <path> [ [<mode-string>] <seek-to-end-p> ])

.TP
Description:

The open-tail function creates a tail stream connected to the file which is
located at the given <path>.  The <mode-string> argument is a string which uses
the same conventions as the mode argument of the C language fopen function.
If it is missing, it defaults to "r".  Note that the "b" mode is not supported.
Whether a stream is text or binary depends on which operations are invoked on
it. 

The <seek-to-end-p> argument is a boolean which determines whether the initial
read/write position is at the start of the file, or just past the end.
It defaults to nil.  This argument only makes a difference if the file exists
at the time open-tail is called. If the file does not exist, and is later
created, then the tail stream will follow that file from the beginning.  In
other words, <seek-to-end-p> controls whether the tail stream reads all the
existing data in the file, if any, or whether it reads only newly added data
from approximately the time the stream is created.

A tail stream has special semantics with regard to reading at the end
of file. A tail stream never reports an end-of-file condition; instead
it polls the file until more data is added. Furthermore, if the file
is truncated, or replaced with a smaller file, the tail stream follows
this change: it automatically opens the smaller file and starts reading from
the beginning (the <seek-to-end-p> flag only applies to the initial open).
In this manner, a tail stream can dynamically growing rotating log files.

Caveat: since a tail stream can re-open a new file which has the same
name as the original file, it will do the wrong thing if the program
changes the current working directory, and the path name is relative.

.SS Function remove-path

.TP
Syntax:

  (remove-path <path>)

.TP
Description:

The remove-path function tries to remove the filesystem object named
by <path>, which may be a file, directory or something else.

If successful, it returns t.

A failure to remove the object results in an exception of type file-error.

.SS Function rename-path

.TP
Syntax:

  (rename-path <from-path> <to-path>)

.TP
Description:

The remove-path function tries to rename filesystem path <from-path>, which may
refer to a file, directory or something else, to the path <to-path>.

If successful, it returns t.

A failure to rename path results in an exception of type file-error.


.TP
Description:

.SH COPROCESSES

.SS Functions open-command, open-process

.TP
Syntax:

  (open-command <system-command> [<mode-string>])
  (open-process <program> <mode-string> [<argument-strings>])

.TP
Description:

These functions spawn external programs which execute concurrently
with the TXR program. Both functions return a unidirectional stream for
communicating with these programs: either an output stream, or an input
stream, depending on the contents of <mode-string>.

In open-command, the <mode-string> argument is optional, defaulting to
the value "r" if it is missing.

The open-command function accepts, via the <system-command> string parameter, a
system command, which is in a system-dependent syntax. On a POSIX system, this
would be in the POSIX Shell Command Language.

The open-process function specifies a program to invoke via the <command>
argument. This is subject to the operating system's search strategy.
On POSIX systems, if it is an absolute or relative path, it is treated as
such, but if it is a simple base name, then it is subject to searching
via the components of the PATH environment variable. If open-process
is not able to find <program>, or is otherwise unable to execute
the program, the child process will exit, using the value of errno
as its exit status. This value can be retrieved via close-stream.

The <mode-string> argument is compatible with the convention used by the POSIX
popen function.

The <argument-strings> argument is a list of strings which specifies additional
optional arguments to be passed passed to the program. The <program> argument
becomes the first argument, and <argument-strings> become the second and
subsequent arguments. If <argument-strings> is omitted, it defaults to empty.

If a coprocess is open for writing (<mode-string> is specified as "w"), then
writing on the returned stream feeds input to that program's standard input
file descriptor. Indicating the end of input is performed by closing the
stream.

If a coprocess is open for reading (<mode-string> is specified as "r"), then
the program's output can be gathered by reading from the returned stream.
When the program finishes output, it will close the stream, which can be
detected as normal end of data.

If a coprocess terminates abnormally or unsuccessfully, an exception is raised.

.SH SYMBOLS AND PACKAGES

A package is an object which serves as a container of symbols.  

A symbol which exists inside a package is said to be interned in that package.
A symbol can be interned in at most one package at a time.

string, but not necessarily unique. A symbol name is unique within a package,
however: two symbols cannot be in the same package if they have the same name.
Moreover, a symbol cannot exist in more than one package at at time, although
it can be relocated from one package to another.  Symbols can exist which are
not in packages: these are called uninterned symbols.

Packages are held in a global list which can be used to search for a package by
name. The find-package function performs this lookup.  A package may be
deleted from the list with the delete-package function, but it continues
to exist until the program loses the last reference to that package.

.SS Special variables *user-package*, *keyword-package*, *system-package*

These variables hold predefined packages. The *user-package* is the one
in which symbols are read when a TXR program is being scanned.
The *keyword-package* holds keyword symbols, which are printed with
a leading colon. The *system-package* is for internal symbols, helping
the implementation avoid name clashes with user code in some situations.

.SS Function make-sym

.TP
Syntax:

  (make-sym <name>)

Description:

The make-sym function creates and returns a new symbol object. The argument
<name>, which must be a string, specifies the name of the symbol.  The symbol
does not belong to any package (it is said to be "uninterned").

Note: an uninterned symbol can be interned into a package with the rehome-sym
function. Also see the intern function.

.SS Function gensym

.TP
Syntax:

  (gensym [<prefix>])

Description

The gensym function is similar to make-sym. It creates and returns a new
symbol object. If the <prefix> argument is omitted, it defaults to "g".
Otherwise it must be a string.

The difference between gensym and make-sym is that gensym creates the name
by combining the prefix with a numeric suffix.

The numeric suffix is a decimal digit string, taken from the value of
the variable *gensym-counter*, after incrementing it.

Note: the variation in name is not the basis of the uniqueness of gensym; the
basis of its uniqueness is that it is a freshly instantiated object. make-sym
also returns unique symbols even if repeatedly called with the same string.

.SS Special variable *gensym-counter*

This variable is initialized to 0. Each time the gensym function is called,
it is incremented. The incremented value forms the basis of the numeric
suffix which gensym uses to form the name of the new symbol.

.SS Function make-package

.TP
Syntax:

  (make-package <name>)

.TP
Description:

The make-package function creates and returns a package named <name>, where
<name> is a string. It is an error if a package by that name exists already.

.SS Function packagep

.TP
Syntax:

  (packagep <obj>)

.TP
Description:

The packagep function returns t if <obj> is a package, otherwise it returns
nil.

.SS Function find-package

.TP
Syntax:

  (find-package <name>)

.TP
Description:

The argument <name> should be a string. If a package called <name> exists,
then it is returned. Otherwise nil is returned.

.SS Function intern

.TP
Syntax:

  (intern <name> [<package>])

.TP
Description:

The argument <name> should be a symbol. The optional argument <package>
should be a package. If <package> is not supplied, then the value
taken is that of *user-package*.

The intern function searches <package> for a symbol called <name>.
If that symbol is found, it is returned. If that symbol is not found, 
then a new symbol called <name> is created and inserted into <package>,
and that symbol is returned. In this case, the package becomes the
symbol's home package.

.SS Function rehome-sym

.TP
Syntax:

  (rehome-sym <symbol> [<package>])

.TP
Description:

The arguments <symbol> and <package> must be a symbol and package object,
respectively. If <package> is not given, then it defaults to the value of
*user-package*.

The rehome-sym function moves <symbol> into <package>. If <symbol>
is already in a package, it is first removed from that package.
If a symbol of the same name exists in <package> that symbol is first removed
from <package>.

.SS Function symbolp

.TP
Syntax:

  (symbolp <obj>)

.TP
Description:

The symbolp function returns t if <obj> is a symbol, otherwise it returns
nil.

.SS Function symbol-name

.TP
Syntax:

  (symbol-name <symbol>)

.TP
Description:

The symbol-name function returns the name of <symbol>.

.SS Function symbol-package

.TP
Syntax:

  (symbol-package <symbol>)

.TP
Description:

The symbol-package function returns the home package of <symbol>.

.SS Function packagep

.TP
Syntax:

  (packagep <obj>)

.TP
Description:

The packagep function returns t if <obj> is a package, otherwise it returns
nil.

.SS Function keywordp

.TP
Syntax:

  (keywordp <obj>)

.TP
Description:

The keywordp function returns t if <obj> is a keyword symbol, otherwise it
returns nil.


.SH PSEUDO-RANDOM NUMBERS

.SS Special variable *random-state*

The *random-state* variable holds an object which encapsulates the state
of a pseudo-random number generator. This variable is the default argument for
the random-fixnum and random functions, so that programs can be written
which are not concerned about the management of random state.

However, programs can create and manage random states, making it possible to
obtain repeatable sequences of pseudo-random numbers which do not interfere
with each other. For instance objects or modules in a program can have their
own independent streams of random numbers which are repeatable, independently
of other modules making calls to the random number functions.

When TXR starts up, the *random-state* variable is initialized with
a newly created random state object, which is produced as if by
the call (make-random-state 42).

.SS Function make-random-state

.TP
Syntax:

  (make-random-state [<seed>])

.TP
Description:

The make-random-state function creates and returns a new random state,
an object of the same kind as what is stored in the *random-state* variable.

The seed, if specified, must be an integer value.

Note that the sign of the seed is ignored, so that negative seed
values are equivalent to their additive inverses.

If the seed is not specified, then make-random-state produces a seed based 
on some information in the process environment, such as current
time of day. It is not guaranteed that two calls to (make-random-state nil)
that are separated by less than some minimum increment of real time produce
different seeds.  The minimum time increment depends on the platform, but on any
given platform, it is the platform's smallest available time increment, or a
microsecond, whichever is longer.

Of course, it is not guaranteed that any two calls to make-random-state produce
different values under any circumstances, due to possible collisions; however,
time differences smaller than the minimum increment may predictably produce
identical values.

For instance, on a platform with a nanosecond-resolution real-time clock,
the minimum time increment is a microsecond. Calls to make-random-state
closer together than a microsecond may predictably produce the same seed.

In a platform with a millisecond-resolution real-time clock, the minimum
time increment is a millisecond. Calls to make-random-state less than
a millisecond apart may predictably produce the same seed.

.SS Function random-state-p

.TP
Syntax:

  (random-state-p <obj>)

.TP
Description:

The random-state-p function returns t if <obj> is a random state, otherwise it
returns nil.

.SS Functions random-fixnum, random and rand

.TP
Syntax:

  (random-fixnum [<random-state>])
  (random <random-state> <modulus>)
  (rand <modulus> [<random-state>])

.TP
Description:

All three functions produce pseudo-random numbers, which are positive integers.

The numbers are obtained from a WELLS 512 pseudo-random number generator, whose
state is stored in the random state object.

The random-fixnum function produces a random fixnum integer: a reduced range
integer which fits into a value that does not have to be heap-allocated.

The random and rand functions produce a value in the range [0, modulus).  They
differ only in the order of arguments. In the rand function, the random state
object is the second argument and is optional. If it is omitted, the global
*random-state* object is used.

.SH TIME

.SS Functions time and time-usec

.TP
Syntax:

  (time)
  (time-usec)

.TP
Description:

The time function returns the number of seconds that have elapsed since
midnight, January 1, 1970, in the UTC timezone.

The time-usec function returns a cons cell whose car field holds the seconds
measured in the same way, and whose cdr field extends the precision by giving
number of microseconds as an integer value between 0 and 999999.

.SS Functions time-string-local and time-string-utc

.TP
Syntax:

  (time-string-local <time> <format>)
  (time-string-utc <time> <format>)

.TP
Description:

These functions take the numeric time returned by the time function,
and convert it to a textual representation in a very flexible way, according to
a detailed format string.

The time-string-local function converts the time to the local timezone of
the host system. The time-string-utc function produces time in UTC.

The <format> argument is a string, and follows exactly the same conventions as
the format string of the C library function strftime.

The <time> argument is an integer representing seconds obtained from the
time function or from the time-usec function.

.SS Functions time-fields-local and time-fields-utc

.TP
Syntax:

  (time-fields-local <time>)
  (time-fields-utc <time>)

.TP
Description:

These functions take the numeric time returned by the time function,
and convert it to a list of seven fields.

The time-string-local function converts the time to the local timezone of
the host system. The time-string-utc function produces time in UTC.

The fields returned as a list are six integers, and a boolean value.
The six integers represent the year, month, day, hour, minute and second.
The boolean value indicates whether daylight savings time is in effect
(always nil in the case of time-fields-utc).

The <time> argument is an integer representing seconds obtained from the
time function or from the time-usec function.

.SS Functions make-time and make-time-utc

.TP
Syntax:

  (make-time <year> <month> <day> <hour> <minute> <second> <dst-advice>)
  (make-time-utc <year> <month> <day> <hour> <minute> <second> <dst-advice>)

.TP
Description

The make-time function returns a time value, similar to the one returned by the
time function.  The time value is constructed not from the system clock, but
from a date and time specified as arguments. The <year> argument is a
calendar year, like 2013. The <month> argument ranges from 1 through 12.
These arguments represent a local time, in the current time zone.

The <dst-advice> argument specifies whether the time is expressed in
daylight savings time (DST). It takes on these values: nil, the keyword :auto,
or any other value which denotes boolean true.

If <dst-advice> is t, then the time is assumed to be expressed in DST.
If the argument is nil, then the time is assumed not to be in DST.
If <dst-advice> is :auto, then the function tries to determine whether
DST is in effect in the current time zone for the specified date and time.

The make-time-utc function is similar to make-time, except that
it treats the time as UTC rather than in the local time zone. 
The <dst-advice> argument is supported by make-time-utc for function
call compatibility with make-time. It may or may not have any effect
on the output (since the UTC zone by definition doesn't have daylight
savings time).

.SH ENVIRONMENT VARIABLES AND COMMAND LINE

.SS Special variables *args* and *args-full*

The *args* variable holds a list of strings representing the remaining
arguments which follow any options processed by the txr executable, and the
script name.

The *args-full* variable holds the original, complete list of arguments passed
from the operating system.

Note: the *args* variable is nil during the processing of the command line,
so TXR Lisp invoked using the -p or -e option cannot use it.

.SS Function env

.TP
Syntax:

  (env)

.TP
Description:

The env function retrieves the list of environment variables. Each
variable is represented by a single entry in the list: a string which
contains an = (equal) character somewhere, separating the variable name
from its value.

See also: the env-hash function.

.SS Function env-hash

Syntax:

  (env-hash)

.TP
Description:

The env-hash function constructs and returns an :equal-based hash.  The hash is
populated with the environment variables, represented as key-value pairs. 

.SH UNIX PROGRAMMING

.SS Function errno

.TP
Syntax:

  (errno [<new-errno>])

.TP
Description:

These functions retrieves the current value of the C library error variable
errno.  If the argument <new-errno> is present and is not nil, then it
specifies a value which is stored into errno.  The value returned is the prior
value.

.SS Function exit

.TP
Syntax:

  (exit <status>)

.TP
Description:

The exit function terminates the entire process (running TXR image), specifying
the termination status to the operating system. Values of <status> may be nil,
t, or integer values.  The value nil corresponds to the C constant
EXIT_FAILURE, and t corresponds to EXIT_SUCCESS. These are platform-independent
indicators of failed or successful termination. The numeric value 0 also
indicates success.

.SS Function usleep

.TP
Syntax:

  (usleep <usec>)

.TP
Description:

The usleep function suspends the execution of the program for at least
<usec> microseconds.

The return value is t if the sleep was successfully executed. A nil
value indicates premature wakeup or complete failure.

Note: the actual sleep resolution is not guaranteed, and depends on granularity
of the system timer.  Actual sleep times may be rounded up to the nearest 10
millisecond multiple on a system where timed suspensions are triggered by a 100
Hz tick.

.SS Function mkdir

.TP
Syntax:

  (mkdir <path> [<mode>])

.TP
Description:

Try to create the directory named <path> using the POSIX mkdir function.
An exception of type file_error is thrown if the function fails. Returns
t on success.

The <mode> argument specifies the request numeric permissions
for the newly created directory. If omitted, the requested permissions are
#o777 (511): readable and writable to everyone. The requested permissions
are subject to umask.

.SS Function chdir

.TP
Syntax:

  (chdir <path>)

.TP
Description:

This changes the current working directory to <path>, and returns t,
or else throws an exception of type file-error.

.SS Function pwd

.TP
Syntax:

  (pwd)

.TP
Description:

This function retrieves the current working directory. 
If the underlying getcwd system call fails with an errno other than ERANGE,
an exception will be thrown.

.SS Functions getpid and getppid

.TP
Syntax:

  (getpid)
  (getppid)

.TP
Description:

These functions retrieve the current proces ID and the parent process ID
respectively. They are wrappers for the POSIX functions getpid and getppid.

.SS Function daemon

.TP
Syntax:

  (daemon <nochdir-p> <noclose-p>)

.TP
Description:

This is a wrapper for the Unix function daemon of BSD origin. 

It returns t if successful, nil otherwise, and the errno
variable is set in that case.

.SS Functions makedev, minor, major

.TP
Syntax:

  (makedev <minor> <major>)
  (minor <dev>)
  (major <dev>)

.TP
Description:

The parameters <minor>, <major> and <dev> are all integers.  The makedev
function constructs a combined device number from a minor and major pair (by
calling the Unix makedev function).  This device number is suitable as an
argument to the mknod function (see below). Device numbers also appear as :dev
property returned by the stat function.

The minor and major functions extract the minor and major device number
from a combined device number.

.SS Function mknod

.TP
Syntax:

  (mknod <path> <mode> [<dev>])

.TP
Description:

The mknod function tries to create an entry in the filesystem: a file,
FIFO, or a device special file, under the name <path>. If it is successful,
it returns t, otherwise it throws an exception of type file-error.

The <mode> argument is a bitwise "or" combination of the requested permissions,
and the type of object to create: one of the constants s-ifreg, s-ififo,
s-ifchr or s-ifblk or s-ifsock. The permissions are subject to the umask.

If a block or character special device (s-ifchr or s-ifblk) is being
created, then the <dev> argument specifies the major and minor numbers
of the device. A suitable value can be constructed from a major and minor
pair using the makedev function.

.TP
Example:

   ;; make a character device (8, 3) called /dev/foo
   ;; requesting rwx------ permissions

   (mknod "dev/foo" (logior #o700 s-ifchr) (makedev 8 3))

.SS Functions symlink and link

.TP
Syntax:

  (symlink <target> <path>)
  (link <target> <path>)

.TP
Description:

The symlink function creates a symbolic link called <path> whose contents
are the absolute or relative path <target>. <target> does not actually have
to exist.

The link function creates a hard link. The object at <target> is installed
into the filesystem at <path> also.

If these functions succeed, they return t. Otherwise they throw an exception
of type file-error.

.SS Function readlink

.TP
Syntax:

  (readlink <path>)

.TP
Description:

If <path> names a filesystem object which is a symbolic link, the readlink
function reads the contents of that symbolic link and returns it
as a string.  Otherwise, it fails by throwing an exception of type file-error.

.SS Functions sh and run

.TP
Syntax:

  (sh <system-command>)
  (run <program> [<argument-list>])

.TP
Description:

The sh function executes <system-command> using the system command interpreter.
The run function spawns a <program>, searching for it using the
system PATH.  Using either method, the executed process receives environment
variables from the parent.

TXR blocks until the process finishes executing. If the program terminates
normally, then its integer exit status is returned. The value zero indicates
successful termination.

The return value nil indicates an abnormal termination, or the inability
to run the process at all.

In the case of the run function, if the child process is created successfully
but the program cannot be executed, then the exit status will be an errno value
from the failed exec attempt.

.SH UNIX SIGNAL HANDLING

On platforms where certain advanced features of POSIX signal handling are
available at the C API level, TXR exposes signal-handling functionality.

A TXR program can install a TXR Lisp function (such as an anonymous lambda,
or the function object associated with a named function) as the handler for
a signal.

When that signal is delivered, TXR will intercept it with its own safe,
internal handler, mark the signal as deferred (in a TXR sense) and then
dispatch the lambda at a convenient time.

Handlers currently are not permitted to interrupt the execution of most TXR
internal code.  Immediate, asynchronous execution of handlers is currently
enabled only while TXR is blocked on I/O operations or sleep on a tail stream.
Additionally, the sig-check function can be used to dispatch and clear deferred
signals. These handlers are then safely called if they were subroutines of
sig-check, and not asynchronous interrupts.

.SS Special variables sig-hup, sig-int, sig-quit, sig-ill, sig-trap, sig-abrt, sig-bus, sig-fpe, sig-kill, sig-usr1, sig-segv, sig-usr2, sig-pipe, sig-alrm, sig-term, sig-chld, sig-cont, sig-stop, sig-tstp, sig-ttin, sig-ttou, sig-urg, sig-xcpu, sig-xfsz, sig-vtalrm, sig-prof, sig-poll, sig-sys, sig-winch, sig-iot, sig-stkflt, sig-io, sig-lost and sig-pwr

.TP
Description:

These variables correspond to the C signal constants SIGHUP, SIGINT and so forth. 
The variables sig-winch, sig-iot, sig-stkflt, sig-io, sig-lost and sig-pwr may not be
available since a system may lack the corresponding signal constants. See notes
for the log log-authpriv below. The remaining signal constants are described in
the Single Unix Specification and are expected by TXR to be present.

The highest signal number is 31.


.SS Functions set-sig-handler and get-sig-handler

.TP
Syntax:

  (set-sig-handler <signal-number> <handling-spec>)
  (get-sig-handler <signal-number>)

.TP
Description:

The set-sig-handler function is used to specify the handling for a signal, such
as the installation of a handler function. It updates the signal handling for
a signal whose number is <signal-number> (usually one of the constants like
sig-hup, sig-int and so forth), and returns the previous value.  The
get-sig-handler function returns the current value.

The <signal-number> must be an integer the range 1 to 31.

Initially, all 31 signal handling specifications are set to the value t.

The <handling-spec> parameter may be a function. If a function is specified,
then the signal is enabled and connected to that function until another
call to set-sig-handler changes the handling for that signal.

If <handling-spec> is the symbol nil, then the function previously associated
with the signal, if any, is removed, and the signal is disabled. For a signal
to be disabled means that the signal is set to the SIG_IGN disposition (refer to
the C API).

If <handling-spec> is the symbol t, then the function previously associated
with the signal, if any, is removed, and the signal is set to its default
disposition. This means that it is set to SIG_DFL (refer to the C API).
Some signals terminate the process in their default disposition.

Note that the certain signals like sig-quit and sig-kill cannot be handled.
Please observe the signal documentation in the IEEE POSIX standard, and your
platform.

A signal handling function must take two arguments. It is of the form:

  (lambda (signal async-p) ...)

The signal argument is an integer indicating the signal number for which the
handler is being invoked. The asyncp-p argument is a boolean value, nil or t.
If it is t, it indicates that the handler is being invoked
asynchronously - directly in a signal handling context.  If it is nil, then it
is a deferred call.  Handlers may do more things in a deferred call, such
as terminate by throwing exceptions, and perform I/O.

The return value of a handler is normally ignored. However if it invoked
asynchronously (the async-p argument is true), then if the handler returns
a true value (any value other than nil), the handler is understood as
requesting that it be deferred. This means that the signal will be marked
as deferred, and handler will be called one more time again at some later
time in a deferred context (async-p nil). This is not guaranteed, however;
it's possible that another signal will arrive before that happens,
possibly resulting in an async call.

If a handler is invoked synchronously, then its return value is ignored.

In the current implementation, signals do not queue. If a signal is delivered
to the process again, while it is marked as deferred, it simply stays deferred;
there is no counter associated with a signal, only a boolean flag.

.SS The sig-check function

.TP
Syntax:

  (sig-check)

.TP
Description:

The sig-check function tests whether any signals are deferred, and for each
deferred signal in turn, it executes the corresponding handler.  For a signal to
be deferred means that the signal was caught by an internal handler in TXR and
the event was recorded by a flag.  If a handler function is removed while a
signal is deferred, the deferred flag is cleared for that signal.

Calls to the sig-check function may be inserted into CPU-intensive code that
has no opportunity to be interrupted by signals, because it doesn't invoke any
I/O functions.

.SS The kill function

.TP
Syntax:

  (kill <process-id> [<signal>])

.TP
Description:

The kill function is used for sending a signal to a process group or process.
It is a wrapper for the POSIX kill function.

If the <signal> argument is omitted, it defaults to the same value as sig-term.

.SH UNIX ITIMERS

Itimers can be used in combination with signal handling to execute asynchronous
actions. Itimers deliver one-time or periodic signals. For more information,
consult the POSIX specification.

.SS Variables itimer-real, itimer-virtual and itimer-prof

.TP
Description:

These variables correspond to the POSIX constants ITIMER_REAL, ITIMER_VIRTUAL
and ITIMER_PROF. Thir values are suitable as the <timer> argument of
the getitimer and setitimer functions.

.SS Functions getitimer and setitimer

.TP
Syntax:

  (getitimer <timer>)
  (setitimer <timer> <interval> <value>)

.TP
Description

The getitimer function returns the current value of the specified timer,
which must be itimer-real, itimer-virtual or itimer-prof.

The current value consists of a list of two integer values, which
represents microseconds. The first value is the timer interval,
and the second value is the timer's current value.

The setitimer function also retrieves the specified timer, exactly
as getitimer. In addition, it stores a new value in the timer,
which is given by the two arguments, expressed in microseconds.

.SH UNIX SYSLOG

On platforms where a Unix-like syslog API is available, TXR exports this
interface. TXR programs can configure logging via the openlog function,
control the logging mask via setlogmask and generate logs via syslog,
or using special syslog streams.

.SS Special variables log-pid, log-cons, log-ndelay, log-odelay, log-nowait and log-perror

These variables take on the values of the corresponding C preprocessor
constants from the <syslog.h> header: LOG_PID, LOG_CONS, etc. These
integer values represent logging options used in the option argument to the
openlog function.

Note: LOG_PERROR is not in POSIX, and so log-perror might not be available.
See notes about LOG_AUTHPRIV in the next section.

.SS Special variables log-user, log-daemon, log-auth and log-authpriv

These variables take on the values of the corresponding C preprocessor
constants from the <syslog.h> header: LOG_USER, LOG_DAEMON, LOG_AUTH
and LOG_AUTHPRIV.  These are the integer facility codes specified in the
openlog function.

Note: LOG_AUTHPRIV is not in POSIX, and so log-authpriv might not be available.
For portability use code like (of (symbol-value 'log-authpriv) 0) to
evaluate to 0 if log-authpriv doesn't exist, or else check for its
existence using (boundp 'log-authpriv).

.SS Special variables log-emerg, log-alert, log-crit, log-err, log-warning, log-notice, log-info and log-debug

These variables take on the values of the corresponding C preprocessor
constants from the <syslog.h> header: LOG_EMERG, LOG_ALERT, etc.
These are the integer priority codes specified in the syslog call.

.SS The *stdlog* special variable holds a special kind of stream: a syslog
stream.  Each newline-terminated line of text sent to this stream becomes a log
message. 

The stream internally maintains a priority value that is applied
when it generates messages. By default, this value is that of log-info.
The stream holds the priority as the value of the :prio property,
which may be changed with the stream-set-prop function.

The latest priority value which has been configured on the stream is used
at the time the newline character is processed and the log message
is generated, not necessarily the value which was in effect at the time the
accumulation of a line began to take place.

Note that messages generated via the openlog function are not newline
terminated; this is a convention of the syslog stream. The newline characters
written to the syslog stream are only used to recognize the message framing,
and are not sent to syslog.

Multiple lines can be written to the stream in a single operation, and
these result in multiple syslog messages.

.SS The openlog function

.TP
Syntax:

  (openlog <id-string> [ <options> [<facility>] ])

.TP
Description:

The openlog TXR Lisp function is a wrapper for the openlog C function, and the
arguments have the same semantics. It is not necessary to use openlog in order
to call the syslog function or to write data to *stdlog*. The call is necessary
in order to override the default identifying string, to set options, such
as having the PID (process ID) recorded in log messages, and to specify the facility.

The <id-string> argument is mandatory.

The <options> argument is a bitwise mask (see the logior function) of option
values such as log-pid and log-cons. If it is missing, then a value of 0 is
used, specifying the absence of any options.

The <facility> argument is one of the values log-user, log-daemon or log-auth.
If it is missing, then log-user is assumed.

.SS The closelog function

.TP
Syntax:

  (closelog)

.TP
Description:

The closelog function is a wrapper for the C function closelog.

.SS The setlogmask function

.TP
Syntax:

  (setlogmask <bitmask-integer>)

.TP
Description:

The setlogmask function interfaces to the corresponding C function, and has the
same argument and return value semantics. The argument is a mask of priority
values to enable. The return value is the prior value. Note that if the
argument is zero, then the function doesn't set the mask to zero; it only
returns the current value of the mask.

Note that the priority values like log-emerg and log-debug are integer
enumerations, not bitmasks. These values cannot be combined directly to create
a bitmask. Rather, the mask function should be used on these values.

.TP
Example:

  ;; Enable LOG_EMERG and LOG_ALERT messages, suppressing all others
  (setlogmask (mask log-emerg log-alert))


.SS The syslog function

.TP
Syntax:

  (syslog <priority> <format> <format-arg>*)

.TP
Description:

This function is the interface to the syslog C function. The printf formatting
capabilities of the function are not used; it follows the conventions of the
TXR Lisp format function instead. Note in particular that the %m convention
for interpolating the value of strerror(errno) is currently not supported.

.SH WEB PROGRAMMING SUPPORT

.SS Functions url-encode and url-decode

.TP
Syntax:

   (url-encode <string> [<space-plus-p>])
   (url-decode <string> [<space-plus-p>])

.TP
Description:

These functions convert character strings to and from a form which is suitable 
for embedding into the request portions of URL syntax.

Encoding a string for URL use means identifying in it certain characters that
might have a special meaning in the URL syntax and representing it using
"percent encoding": the percent character, followed by the ASCII value of the
character.  Spaces and control characters are also encoded, as are all byte
values greater than or equal to 127 (7F hex).  The printable ASCII characters
which are percent-encoded consist of this set:

  :/?#[]@!$&'()*+,;=%

More generally, strings can consists of Unicode characters, but the URL
encoding consists only of printable ASCII characters. Unicode characters in the
original string are encoded by expanding into UTF-8, and applying
percent-encoding the UTF-8 bytes, which are all in the range 0x80-0xFF.

Decoding is the reverse process: reconstituting the UTF-8 byte sequence
specified by the URL-encoding, and then decoding the UTF-8 sequence into the
string of Unicode characters.

There is an additional complication: whether or not to encode spaces as plus,
and to decode plus characters to spaces. In encoding, if spaces are not encoded
to the plus character, then they are encoded as %20, since spaces are reserved
characters that must be encoded. In decoding, if plus characters are not
decoded to spaces, then they are left alone: they become plus characters in the
decoded string.

The url-encode function performs the encoding process. If the space-plus-p
argument is omitted or specified as nil, then spaces are encoded as %20.
If the argument is a value other than nil, then spaces are encoded as the
character + (plus).

The url-decode function performs the decoding process. If the space-plus-p
argument is omitted or specified as nil, then + (plus) characters in the
encoded data are retained as + characters in the decoded strings. Otherwise,
plus characters are converted to spaces.

.SS Functions html-encode and html-decode

.TP
Syntax:

   (html-encode <text-string>)
   (html-decode <html-string>)

.TP
Description:

The html-encode and decode functions convert between an HTML and raw
representation of of text. 

The html-encode function returns a string which is based on the content of
<text-string>, but in which all characters which have special meaning in HTML
have been replaced by special HTML codes for representing those characters.
The returned string is the HTML-encoded verbatim representation of
<text-string>.

The html-decode function converts <html-string>, which may contain HTML
character encodings, into a string which contains the characters represented
by those encodings.

The function composition (html-decode (html-encode text)) returns a string
which is equal to text.

The reverse composition (html-encode (html-decode html)) does not necessarily
return a string equal to text.

For instance if html is the string "<p>Hello, world&#33;</p>",
then html-decode produces "<p>Hello, world!</p>". Then, html-encode
produces "&lt;p&gt;Hello, world!&lt;/p&gt;".

.SH FILTER MODULE

The filter module provides a trie (pronounced "try") data structure,
which is suitable for representing dictionaries for efficient filtering.
Dictionaries are unordered collections of keys, which are strings, which 
have associated values, which are also strings.  A trie can be used to filter
text, such that keys appearing in the text are replaced by the corresponding
values. A trie supports this filtering operation by providing an efficient
prefix-based lookup method which only looks at each input character ones, and
which does not require knowledge of the length of the key in advance.

.SS Function make-trie

.TP
Syntax:

  (make-trie)

.TP
Description:

This function creates an empty trie. There is no special data type for
a trie; a trie is some existing type such as a hash table.

.SS Function trie-add

.TP
Syntax:

  (trie-add <trie> <key> <value>)

.TP
Description:

The trie-add function adds the string <key> to the trie, associating
it with <value>. If <key> already exists in <trie>, then the value
is updated with <value>.

The <trie> must be a trie that has not been compressed with trie-compress.

A trie can contain keys which are prefixes of other keys. For instance
it can contain "dog" and "dogma". When a trie is used for matching
and substitution, the longest match is used. If the input presents
the text "doggy", then the match is "dog".  If the input is "dogmatic",
then "dogma" matches.


.SS Function trie-compress

.TP
Syntax:

   (trie-compress <trie>)

.TP
Description:

The trie-compress function changes the representation of <trie> to
a representation which occupies less space and supports faster lookups.
The new representation is returned. 

The compressed representation of a trie does not support the trie-add function.

This function destructively manipulates <trie>, and may return an object
that is the same object as <trie>, or it may return a different object,
while at the same time still modifying the internals of <trie>.
Consequently, the program should not retain the input object <trie>,
but use the returned object in its place.

.SS Function trie-lookup-begin

.TP
Syntax:

  (trie-lookup-begin <trie>)

.TP
Description:

The trie-lookup-begin function returns a context object for performing
an open-coded lookup traversal of a trie. The <trie> argument
is expected to be a trie that was created by the make-trie function.

.SS Function trie-lookup-feed-char

.TP
Syntax:

  (trie-lookup-feed-char <trie-context> <char>)

.TP
Description:

The trie-lookup-feed-char function performs a one character step in a trie
lookup. The <trie-context> argument must be a trie contxt returned
by trie-lookup-begin, or by some previous call to trie-lookup-feed-char.
The <char> argument is the character to search for.

If the lookup is successful (the match through the trie can continue
with the given character) then a new trie context object is returned.
The old trie context remains valid.

If the lookup is unsuccessful, nil is returned.

Note: determining whether a given string is stored in a trie can be
performed looking up every character of the string successively
with trie-lookup-feed-char, using the newly returned context
for each successive operation. If every character is found, it means
that either that exact string is found in the trie, or a prefix.
The ambiguity can be resolved by testing whether the trie has a value
at the last node using tree-value-at. For instance, if "catalog"
is inserted into an empty trie with value "foo", then "cat" will look up
successfully, being a prefix of "catalog"; however, the value at "cat" is nil.

.SS Function tree-value-at

.TP
Syntax:

  (trie-value-at <trie-context>)

.TP
Description:

The trie-value-at function returns the value stored at the node in
in the trie given by <trie-context>. Nodes which have not been given
a value hold the value nil.

.SS Function filter-string-tree

.TP
Syntax:

  (filter-string-tree <filter> <obj>)

.TP
The filter-string-tree a tree structure similar to <obj>, in which all of the
string atoms have been filtered through <filter>.

The <obj> argument is a string tree structure: either the symbol nil, denoting
an empty structure; a string; or a list of tree structures. If <obj> is
nil, then filter-string-tree returns nil.

The <filter> argument is a filter: it is either a trie, a function, or nil.
If <filter> is nil, then filter-string-trie just returns <obj>.

If <filter> is a function, it must be a function that can be called
with one argument. The strings of the string tree are filtered by passing
each one into the function and substituting the return value into the
corresponding place in the returned structure.

Otherwise if <filter> is a trie, then this trie is used for filtering,
the string elements similarly to a function. For each string, a new
string is returned in which occurrences of the keys in the trie are
replaced by the values in the trie.

.SS Function filter-equal

.TP
Syntax:

  (filter-equal <filter-1> <filter-2> <obj-1> <obj-2>)

.TP
Description:

The filter-equal function tests whether two string trees are equal
under the given filters. 

The precise semantics can be given by this expression:

  (equal (filter-string-tree <filter-1> <obj-1>)
         (filter-string-tree <filter-2> <obj-2>)) 

The string tree <obj-1> is filtered through <filter-1>, as if
by the filter-string-tree function, and similarly, <obj-2> is
filtered through <filter-2>. The resulting structures are compared
using equal, and the result of that is returned.

.SH ACCESS TO TXR PATTERN LANGUAGE FROM LISP

.SS Function match-fun

.TP
Syntax:

  (match-fun <name> <args> <input> <files>)

.TP
Description:

The match-fun function invokes a txr pattern function whose name is
given by the <name>, which must be a symbol. 

The <args> argument is a list of expressions. The expressions may be symbols
which will be interpreted as pattern variables, and may be bound or unbound.
If they are not symbols, then they are treated as expressions (of the
pattern language, not TXR Lisp) and evaluated accordingly.

The <input> argument is a list of strings, which may be lazy. It represents the
lines of the text stream to be processed.

The <files> argument is a list of filename specifications, which follow
the same conventions as files given on the TXR command line. If the pattern
function uses the @(next) directive, it can process these additional files.

The match-fun function's return value falls into three cases. If there is a
match failure, it returns nil. Otherwise it returns a cons cell. The car field
of the cons cell holds the list of captured bindings. The cdr of the cons cell
is one of two values. If the entire input was processed, the cdr field holds
the symbol t. Otherwise it holds another cons cell whose car is the remainder
of the list of lines which were not matched, and the cdr is the line number.

.TP
Example:

  @(define foo (x y))
  @x:@y
  @line
  @(end)
  @(do
     (format t "~s\en"
               (match-fun 'foo '(a b) '("alpha:beta" "gamma" "omega") nil)))

  Output:
  (((a . "alpha") (b . "beta")) ("omega") . 3)

In the above example, the pattern function foo is called with arguments (a b).
These are unbound variables, so they correspond to parameters x and y
of the function. If x and y get bound, those values propagate to a and b.
The data being matched consists of the lines "alpha:beta", "gamma" and
"omega".  Inside foo, x and y bind to "alpha" and "beta", and then the
line variable binds t "gamma". The input stream is left with "omega".

Hence, the return value consists of the bindings of x and y transferred to a
and b, and the second cons cell giving information about the rest of the
stream: it is the part starting at "omega", which is line 3. Note that the
binding for for line variable does not propagate out of the pattern function
foo; it is local inside it. 

.SH QUOTE/QUASIQUOTE OPERATOR SYNTAX

.SS Operator quote

.TP
Syntax:

  (quote <form>)

.TP
Description:

The quote operator, when evaluated, suppresses the evaluation of <form>,
and instead returns <form> itself as an object. For example, if <form>
is a symbol, then <form> is not evaluated to the symbol's value; rather
the symbol itself is returned.

Note: when the quote syntax '<form> is used it is translated to
(quote <form>).

.TP
Example:

  (quote a) ;; yields a

  (quote (+ 2 2)) ;; yields (+ 2 2), not 4.

.SS Macro qquote

.TP
Syntax:

  (qquote <form>)

.TP
Description:

The qquote (quasi-quote) macro operator implements a notation for convenient
list construction.  If <form> is an atom, or a list structure which
does not contain any unquote or splice operators, then (qquote <form>)
is equivalent to (quote <form>).

If <form>, however, is a list structure which contains unquote or splice
operators, then the substitutions implied by those operators are performed
on <form>, and the qquote operator returns the resulting structure.
Note: how the qquote operator actually works is that it is compiled into
code: a Lisp expression which computes the resulting structure when evaluated.

A qquote can contain another qquote. If an unquote or splice operator occurs
within a nested qquote, it belongs to that qquote, and not to the outer one.

However, an unquote operator which occurs inside another one belongs one level
higher. For instance in (qquote (qquote (unquote (unquote x)))), 
the leftmost qquote belongs with the rightmost unquote, and the inner
qquote and unquote belong together. When the outer qquote is evaluated,
it will insert the x, resulting in the value (qquote (unquote <val-x>)).
where <val-x> represents the object which is the value of variable x. If this
resulting qquote value is evaluated again as Lisp syntax, then it
will yield <val-val-x>, where <val-val-x> denotes the value of <val-x>
when <val-x> is treated as a Lisp expression and evaluated.

.TP
Examples:

  (qquote a) -> a

  (qquote (a b c)) -> (a b c)

  (qquote (1 2 3 (unquote (+ 2 2) (+ 2 3)))) -> (1 2 3 4 (+ 2 3))

  (qquote (unquote (+ 2 2))) -> 4

In the second-to-last example, the 1 2 3 and the (+ 2 3) were taken verbatim.
But the (unquote (+ 2 2)) operator caused the evaluation of (+ 2 2) and the
substitution of the resulting value.

The last example shows that <form> can itself be an unquote operator.
However, note: (quote (splice <form>)) is not valid.

Note: a way to understand the nesting behavior is a model of quasi-quote
expansion which recursively compiles any nested quasi quotes first, and then
treats the result of their expansion. For instance, in the processing of
(qquote (qquote (unquote (unquote x)))), the quote operator
finds the internal (qquote ...) and compiles it to code. During that recursive
compilation, the syntax (unquote (unquote x)) is encountered.
The inner quote processes the outer unquote which belongs to it,
and the (unquote x) becomes material embedded in the compilation,
which will then be found when the outer quasiquote takes the inner
compilation and processes its interior.

.TP
Dialect note:

In Lisp dialects which have a published quasiquoting operator syntax, there is
the expectation that the quasiquote read syntax corresponds to it. That is to
say, that for instance the read syntax ^(a b ,c) is translated to
(qquote b (unquote c)).

In TXR Lisp, this is not true! Although ^(b b ,c) is translated to a
quasiquoting macro, it is an internal one, not based on the public qquote,
unquote and splice symbols.

This idea exists for hygiene. The quasiquote read syntax is not confused
by the presence of the symbols qquote, unquote or splice in the template,
since it doesn't treat them specially.

This also allows programmers to use the quasiquote read syntax to construct
quasiquote macros. For instance

  ^(qquote (unquote ,x)) ;; does not mean ^^,x 

To the quasiquote reader, the qquote and unquote symbols mean nothing special,
and so this syntax simply means that if the value of x is foo, the result will
be (qquote (unquote foo)).

The form's expansion is actually this:

  (sys:qquote (qquote (unquote (sys:unquote x))))

the sys:qquote macro recognizes sys:unquote embedded in the form, and
the other symbols not in the sys: package are just static template material.

.SS Operator unquote

.TP
Syntax:

  (qquote (... (unquote <form>) ...))

  (qquote (unquote <form>))

.TP
Description:

The unquote operator is not an operator per se. The unquote symbol has no
binding in the global environment. It is a special syntax that is recognized
within a qquote form, to indicate forms within the quasiquote which are to be
evaluated and inserted into the resulting structure.

The variant (qquote (unquote <form>)) is equivalent to <form>: the
qquote and unquote "cancel out".

Nesting of qquotes and unquotes is explained in the qquote operator.

.SS Operator splice

.TP
Syntax:

  (qquote (... (splice <form>) ...))

.TP
Description:

The splice operator is not an operator per se. The splice symbol has no
binding in the global environment. It is a special syntax that is recognized
within a qquote form, to indicate forms within the quasiquote which are to be
evaluated and inserted into the resulting structure.

The variant (qquote (unquote <form>)) is not permitted and raises
an exception if evaluated. The splice syntax must occur within a list,
and not in the dotted position.

The splice form differs from unquote in that (splice <form>)
requires that <form> must evaluate to a list. That list is 
integrated into the surrounding list. 

Nesting of qquotes and unquotes is explained in the qquote operator.

.SH MACROS

TXR Lisp supports structural macros. TXR's model of macroexpansion is that TXR
Lisp code is processed in two phases: the expansion phase and the evaluation
phase. The expansion phase is invoked on Lisp code early during the processing
of source code. For instance when a TXR File containing a @(do ...) directive
is loaded, expansion of the Lisp forms are its arguments takes place during the
parsing of the entire source file, and is complete before any of the code in
that file is executed. If and when the @(do ...) form is later executed,
the expanded forms are evaluated.

TXR Lisp also supports symbol macros, which are symbolic forms that stand
for forms, with which they are replaced at macro expansion time.

When Lisp data is processed as code by the eval function, it is first expanded,
and so processed in its entirety in the expansion phase. Then it is processed
in the evaluation phase.

.SS Macro parameter lists.

TXR macros support destructuring, similarly to Common Lisp macros.
This means that macro parameter lists are like function argument lists,
but support nesting. A macro parameter list can specify a nested parameter
list in every place where a function argument list allows only a parameter
name. For instance, consider this macro parameter list:

  ((a (b c)) : (c frm) ((d e) frm2 de-p) . g)

The top level of this list has four elements: the mandatory parameter (a (b
c)), the optional parameter c (with default init form frm), the optional
parameter (d e) with default init form frm2 and presence-indicating variable
de-p, and the parameter g which captures trailing arguments.

Note that some of the parameters are compounds: (a (b c)) and (d e).
These compounds express nested macro parameter lists.

Macro parameter lists match a similar tree structure to their own.
For instance a mandatory parameter (a (b c)) matches a structure like
(1 (2 3)), such that the parameters a, b and c will end up bound
to 1, 2, and 3, respectively.

The binding strictness is relaxed for optional parameters. If (a (b c))
is optional, and the argument is, say, (1), then a gets 1, and b and c
receive nil. 

Macro parameter lists also support two special keywords, namely :env and :whole.

The parameter list (:whole x :env y) will bind parameter x to the entire
macro form, and y will bind parameter y to the macro environment.
(Note: Macro environments currently do not do anything in TXR Lisp; this
functionality is for future expansion.)   The :whole and :env notation
can occur anywhere in a macro parameter list.

.SS Operator macro-time

.TP
Syntax:

  (macro-time {<form>}*)

.TP
Description:

The macro-time operator has a syntax similar to a progn form. The forms are
evaluated from left to right, and the resulting value is that of the last form.

The special behavior of macro-time is that the evaluation takes place during
the expansion phase, rather than during the evaluation phase.

During the expansion phase, all macro-time expressions which occur in a context
that calls for evaluation are evaluated, and replaced by their quoted values.
For instance (macro-time (list 1 2 3)) evaluates (list 1 2 3) to the object (1
2 3) and the entire macro-time form is replaced by the quoted list '(1 2 3).
If the form is evaluated again at evaluation-time, the resulting value will be
that of the quote.

macro-time forms do not see the surrounding lexical environment; the see only
global function and variable bindings and macros.

Note 1: macro-time is intended for defining helper functions and variables that
are used by macros. A macro cannot "see" a defun function or defvar variable
because defun and defvar forms are evaluated at evaluation time, which occurs
after expansion time.  The macro-time operator hoists the evaluation of these
forms to macro-expansion time. 

Note 2: defmacro forms are implicitly in macro-time; they do not have to
be wrapped with the macro-time operator. The macro-time operator doesn't have
to be used in programs whose macros do not make references to variables
or functions.

.SS Operator defmacro

.TP
Syntax:

  (defmacro <name> (<param>* [: <opt-param>*] [. <rest-param>]) <body-form>*)

.TP
Description:

The defmacro operator is evaluated at expansion time. It defines a 
macro-expander function under the name <name>, effectively creating
a new operator. 

Note that the parameter list is a macro parameter list, and not a
function parameter list. This means that each <param> can have not
only the syntax <symbol> but it can itself be a parameter list.
The corresponding argument is then treated as an argument list.
Similarly, each symbol in the <opt-param> syntax can be an argument list.

This nesting can be carried to an arbitrary depth.

A macro is called like any other operator, and resembles a function.  Unlike in
a function call, the macro receives the argument expressions themselves, rather
than their values.  Therefore it operates on syntax rather than on values.
Also, unlike a function call, a macro call occurs in the expansion phase,
rather than the evaluation phase. 

The return value of the macro is is the macro expansion. It is substituted in
place of the entire macro call form. That form is then expanded again;
it may itself be another macro call, or contain more macro calls.

.TP
Examples:

   ;; A macro to swap two places, such as variables.
   ;; (swap x y) will now exchange the contents of x and y.

   (defmacro swap (a b)
     (let ((temp (gensym)))
       ^(let ((,temp ,a))
          (set ,a ,b)
          (set ,b ,temp))))


   ;; dolist macro similar to Common Lisp's:
   ;;
   ;; The following will print 1, 2 and 3 on separate lines:
   ;; and return 42.
   ;;
   ;; (dolist (x '(1 2 3) 42)
   ;;   (format t "~s\en"))

   (defmacro dolist ((var list : result) . body)
     (let ((i (my-gensym)))
       ^(for ((i ,list)) (i ,result) ((set i (cdr i)))
          (let ((,var (car i)))
            ,*body))))

.SS Operator macrolet

.TP
Syntax:

  (macrolet ({(<name> <macro-style-params> <macro-body-form>*)}*)
     <body-form>*)

.TP
Description:

The macrolet binding operator extends the macro-time lexical environment
by making zero or more new local macros visible.  

The operator symbol is followed by a list of macro definitions.
Each definition is a form which begins with a name, followed by a macro
parameter list, and zero or more forms. These macro definitions are similar
to those globally defined by the defmacro operator, except that they
are in a local environment, and do not capture any regular lexical scope.

The macro definitions are followed by optional forms. 

The macros thus defined are visible to the <body-form>-s.

Forms inside the macro definitions such as the <macro-body-form>-s,
and initializer forms appearing in <macro-style-params> are subject
to macro-expansion in a scope in which none of the new macros being
defined are yet visible. Once the macro definitions are themselves
macro-expanded, they are placed into a new macro environment, which
is then used for macro expanding the <body-form>-s.

A macrolet form is fully processed in the expansion phase of a form, and is
effectively replaced by progn form which contains expanded versions of
<body-forms>-s, only. This expanded structure shows no evidence that any
macrolet forms ever existed in it. Therefore, it is impossible for the code
evaluated in the bodies and parameter lists of macrolet macros to have any
visibility to any surrounding lexical variable bindings, which are only
instantiated in the evaluation phase, after expansion is done.

.SS Function macro-form-p

.TP
Syntax:

  (macro-form-p <obj> [<env>])

.TP
Description:

The macro-form-p function returns t if <obj> represents the syntax of
a form which is a macro form: either a compound macro or a symbol macro.
Otherwise it returns nil.

A macro form will transform under macroexpand-1 or macroexpand; an object
which isn't a macro form will not undergo expansion.

The optional <env> parameter is a macroexpansion environment. 
A macroexpansion environment is passed down to macros and can be received
via their special :env parameter.  A macro can use this environment to
determine whether a piece of syntax <obj> is a macro form in that
environment.

.TP
Example:

  ;; macro which translates form to the form 'yes if it is a macro
  ;; form, otherwise to the form 'no.

  (defmacro global (:env menv form)
   (if (macro-form-p form menv)
    ''yes ''no)) 

  (macrolet ((local ()))
    (global (local)))    ;; yields yes

  (global (local))       ;; yields no


During macroexpansion, the global macro is handed the environment which
it receives via :env menv.  When the macro is invoked within the macrolet,
this environment includes the macro-time lexical scope in which the
local macro is defined. So when global checks whether the argument form
(local) is a macro, the conclusion is yes: the (local) form is a macro
call in that environment: macro-form-p yields t.  When (global (local)) is
invoked outside of the macrolet, no local macro is visible, and so macro-form-p
yields nil.

.SS Functions macroexpand-1 and macroexpand

.TP
Syntax:

  (macroexpand-1 <obj> [<env>])
  (macroexpand <obj> [<env>])

.TP
Description:

If <obj> is a macro form (an object for which macro-form-p returns t),
these functions expand the macro form and return the expanded form.
Otherwise, they return <obj>.

macroexpand-1 performs a single expansion, expanding just the macro
that is referenced by the symbol in the first position of <obj>,
and returns the expansion. That expansion may itself be a macro form.

macroexpand performs an expansion, like macroexpand-1. If the result is
a macro form, then it expands that form, and keeps repeating this process
until the expansion yields a non-macro-form. That non-macro-form is then
returned.

The optional <env> parameter is a macroexpansion environment. 
A macroexpansion environment is passed down to macros and can be received
via their special :env parameter. The environment they receive is their
lexically apparent macro-time environment in which local macros may be
visible.  A macro can use this environment to "manually" expand some
form in the context of that environment.

.TP
Example:

  ;; (foo x) expands x, and if x begins with a number, it removes 
  ;; the number and returns the resulting form. Otherwise, it
  ;; returns the entire form.

  (defmacro rem-num (:env menv some-form)
    (let ((expanded (macroexpand some-form menv)))
      (if (numberp (car expanded))
        (cdr expanded)
        some-form)))

  ;; The following yields (42 a).

  (macrolet ((foo () '(1 list 42))
             (bar () '(list 'a)))
    (list (rem-num (foo)) (rem-num (bar)))))

The rem-num macro is able to expand the (foo) and (bar) forms it receives as
the some-form argument, using the local macro that is lexically apparent
where those forms are passed, and is correctly able to work with the
expansions (1 list 42) and (list 'a) to produce (list 42) and (list 'a)
which evaluate to 42 and a respectively.

.SS Operator defsymacro

.TP
Syntax:

  (defsymacro <sym> <form>)

.TP
Description:

The defsymacro operator binds a symbol macro in the global environment.
A defsymacro form is implicitly executed at expansion time, and thus need
not be wrapped in a macro-time form.

The visibility of a symbol macro binding for <sym> specifies that occurrences
of <sym> in program code which are to be evaluated, or which denote places
which are the targets of assignments, are subject to a replacement by <form>.

The replacement <form> is then subject to further expansion, if possible.
It may be a compound form which is a macro call, or another symbol that
has a symbol macro binding.

Note: if a symbol macro expands to itself directly, expansion stops. However,
if a symbol macro expands to itself through a chain of expansions,
an infinite expansion time loop results.

.SS Operator symacrolet

.TP
Syntax:

  (symacrolet ({(<sym> <form>)}*) <body-form>*)

.TP
Description:

The symacrolet operator binds local, lexically scoped macros that are
similar to the global symbol macros introduced by defsymacro.

Each <sym> in the bindings list is bound to its corresponding form, creating a
new extension of the expansion-time lexical macro environment.

Each <body-form> is subsequently macro-expanded in this new environment
in which the new symbol macros are visible.

Note: ordinary lexical bindings such as those introduced by let or by
function parameters lists shadow symbol macros. If a symbol X is bound
by both a macrolet and a let, then a body which is enclosed by both
constructs will see whichever of the two bindings is innermost,
even though the bindings are active in completely separate phases of
processing. 

.SS Operator tree-bind

.TP
Syntax:

  (tree-bind <macro-style-params> <expr> <form>*)

.TP
Description:

The tree-bind operator evaluates <expr>, and then uses the
resulting value as a counterpart to a macro-style parameter list.
If the value has a tree structure which matches the parameters,
then those parameters are established as bindings, and the
<form>-s, if any, are evaluated in the scope of those bindings.  The value
of the last <form> is returned. If there are no forms,
nil is returned.

Note: this operator throws an exception if there is a mismatch
between the parameters and the value of <expr>.

.SS Operator tree-case

.TP
Syntax:

  (tree-case <expr> { (<macro-style-params> <form>*) }*)

.TP
Description:

The tree case operator evaluates <expr> and matches it against a succession
of zero or more cases. Each case defines a pattern match, expressed as a macro
style parameter list <macro-style-params>. 

If the object produced by <expr> matches <macro-style-params>, then the
parameters are bound, becoming local variables, and the <form>-s, if any, are
evaluated in order in the environment in which those variables are visible. 

If there are forms, the value of the last <form> becomes the result value of
the case, otherwise the result value of the case is nil.

If the result value of a case is the object : (the colon symbol), then
processing continues with the next case. Otherwise the evaluation of tree-case
terminates, returning the result value.

If the value of <expr> does not match the <macro-style-params> parameter
list, then the usual exception is thrown; instead, processing continues
with the next case.

If no cases match, then tree-case terminates, returning nil.

.SS
Example:

   ;; reverse function implemented using tree-case

   (defun tb-reverse (obj)
     (tree-case obj
       (() ())      ;; the empty list is just returned
       ((a) obj)    ;; one-element list just returned (unnecessary case)
       ((a . b) ^(,*(tb-reverse b) ,a)) ;; car/cdr recursion
       (a a)))     ;; atom is just returned

Note that in this example, the atom case is placed last, because an
argument list which consists of a symbol is a "catch all" match
that matches any object. We know that it matches an atom, because
the previous (a . b) case matches conses. In general, the order of the cases in
tree-case is important. Also note that the one-element case can be
removed.

.SH DEBUGGING FUNCTIONS

.SS Functions source-loc and source-loc-str

.TP
Syntax:

  (source-loc <form>)
  (source-loc-str <form>)

.TP
Description:

These functions map an expression in a txr program to the file name and
line number of the source code where that form came from.o

The source-loc function returns the raw information as a cons cell
whose car/cdr consist of the line number, and file name.

The source-loc-str function formats the information as a string.

If <form> is not a piece of the program source code that was constructed by the
TXR parser, then source-loc returns nil, and source-loc-str returns a string
whose text says that source location is not available.

.SS Function rlcp

.TP
Syntax:

  (rlcp <dest-form> <source-form>)

The rlcp function copies the source code location info (rl = read location)
from the <source-form> object to the <dest-form> object. These objects
are pieces of list-based syntax.

Note: the function is intended to be used in macros. If a macro transforms
<source-form> to <dest-form>, this function can be used to propagate the
source code location info also, so that when the TXR Lisp evaluator
encounters errors in transformed code, it can give diagnostics which refer
to the original untransformed source code.

.SH PROFILING

.SS Operator prof

.TP
Syntax:

  (prof <form>*)

.TP
Description:

The prof operator evaluates the enclosed forms from left to right similarly
to progn, while determining the memory allocation requests and time
consumed by the evaluation of the forms.  

If there are no forms, the prof operator measures the smallest measurable
operation of evaluating nothing and producing nil.

If the evaluation terminates normally (not abruptly by a non-local
control transfer), then prof yields a list consisting of:

  (<value> <malloc-bytes> <gc-bytes> <milliseconds>)

where <values> is the value returned by the rightmost <form>, or nil if there
are no forms, <malloc-bytes> is the total number of bytes of all malloc
requests (or at least those known to the TXR runtime, such as those of all
internal objects), <gc-bytes> is the total number of bytes drawn from the
garbage-collected heaps, and <milliseconds> is the total processor time
consumed over the execution of those forms.

Notes:

The bytes allocated by the garbage collector from malloc to create
heap areas are not counted as <malloc-bytes>. <malloc-bytes> includes storage
such as the space used for dynamic strings, vectors and bignums (in addition to
their gc-heap allocated nodes), and the various structures used by the cobj
type objects such as streams and hashes. Objects in external libraries that use
uninstrumented allocators are not counted: for instance the C FILE * streams.

.SS Macro pprof

.TP
Syntax:

  (pprof <form>*)

.TP
Description:

The pprof (pretty-printing prof) macro is similar to progn. It evaluates forms,
and returns the rightmost one, or nil if there are no forms.

Over the evaluation of the forms, it counts memory allocations, and measures
CPU time. If the forms terminate normally, then just prior to returning,
pprof prints these statistics are printed in a concise report on the
*std-output* stream, prior to returning the value or nil.

The pprof macro relies on the prof operator.

.SH MODULARIZATION

.SS Special variable *self-path*

This variable holds the invocation path name of the TXR program.

.SH DEBUGGER

.B TXR
has a simple, crude, built-in debugger. The debugger is invoked by adding
the -d command line option to an invocation of txr.
In this debugger it is possible to step through code, set breakpoints,
and examine the variable binding environment.

Prior to executing any code, the debugger waits at the txr> prompt,
allowing for the opportunity to set breakpoints.

Help can be obtained with the h or ? command.

Whenever the program stops at the debugger, it prints the Lisp-ified
piece of syntax tree that is about to be interpreted.
It also shows the context of the input being matched.

The s command can be used to step into a form; n to step over.
Sometimes the behavior seems counter-intuitive. For instance stepping
over a @(next) directive actually means skipping everything which follows
it. This is because the query material after a @(next) is actually child
nodes in the abstract syntax tree node of the next directive.

.SS Sample Session

Here is an example of the debugger being applied to a web scraping program
which connects to a US NAVY clock server to retrieve a dynamically-generated
web page, from which the current time is extracted, in various time zones.
The handling of the web request is done by the wget command; the txr
query opens a wget command as and scans the body of the HTTP response containing
HTML. This is the code, saved in a file called navytime.txr:

  @(next `!wget -c http://tycho.usno.navy.mil/cgi-bin/timer.pl -O - 2> /dev/null`)
  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final"//EN>
  <html>
  <body>
  <TITLE>What time is it?</TITLE>
  <H2> US Naval Observatory Master Clock Time</H2> <H3><PRE>
  @(collect :vars (MO DD HH MM SS (PM "  ") TZ TZNAME))
  <BR>@MO. @DD, @HH:@MM:@SS @(maybe)@{PM /PM/} @(end)@TZ@/\et+/@TZNAME
  @  (until)
  </PRE>@/.*/
  @(end)
  </PRE></H3><P><A HREF="http://www.usno.navy.mil"> US Naval Observatory</A>

  </body></html>
  @(output)
  @  (repeat)
  @MO-@DD @HH:@MM:@SS @PM @TZ
  @  (end)
  @(end)

This is the debug session:

  $ txr -d navytime.txr
  stopped at line 1 of navytime.txr
  form: (next (sys:quasi "!wget -c http://tycho.usno.navy.mil/cgi-bin/timer.pl -O - 2> /dev/null"))
  depth: 1
  data (nil):
  nil

The user types s to step into the (next ...) form.

  txr> s
  stopped at line 2 of navytime.txr
  form: (sys:text "<!DOCTYPE" (#<sys:regex: 95e4590> 1+ #\espace) "HTML" (#<sys:regex: 95e4618> 1+ #\espace) "PUBLIC" (#<sys:regex: 95e46a8> 1+ #\espace) "\e"-//W3C//DTD" (#<sys:regex: 95e4750> 1+ #\espace) "HTML" (#<sys:regex: 95e47d8> 1+ #\espace) "3.2" (#<sys:regex: 95e4860> 1+ #\espace) "Final\e"//EN>")
  depth: 2
  data (1):
  "<!DOCTYPE HTML PUBLIC \e"-//W3C//DTD HTML 3.2 Final\e"//EN>"
  txr> s

The current form now is a sys:text form which is an internal representation of
a block of horizontal material. The pattern matching is in vertical mode at
this point, and so the line of data is printed without an indication of
character position. 

  stopped at line 2 of navytime.txr
  form: (sys:text "<!DOCTYPE" (#<sys:regex: 95e4590> 1+ #\espace) "HTML" (#<sys:regex: 95e4618> 1+ #\espace) "PUBLIC" (#<sys:regex: 95e46a8> 1+ #\espace) "\e"-//W3C//DTD" (#<sys:regex: 95e4750> 1+ #\espace) "HTML" (#<sys:regex: 95e47d8> 1+ #\espace) "3.2" (#<sys:regex: 95e4860> 1+ #\espace) "Final\e"//EN>")
  depth: 3
  data (1:0):
  "" . "<!DOCTYPE HTML PUBLIC \e"-//W3C//DTD HTML 3.2 Final\e"//EN>"

The user types s to step in.

  txr> s
  stopped at line 2 of navytime.txr
  form: "<!DOCTYPE"
  depth: 4
  data (1:0):
  "" . "<!DOCTYPE HTML PUBLIC \e"-//W3C//DTD HTML 3.2 Final\e"//EN>"

Now, the form about to be processed is the first item of the (sys:text ...),
a the string "<!DOCTYPE". 

The input is shown broken into two quoted strings with a dot in between.
The dot indicates the current position. The left string is empty, meaning
that this is the leftmost position. The programmer steps:

  txr> s
  stopped at line 2 of navytime.txr
  form: (#<sys:regex: 95e4590> 1+ #\espace)
  depth: 4
  data (1:9):
  "<!DOCTYPE" . " HTML PUBLIC \e"-//W3C//DTD HTML 3.2 Final\e"//EN>"

Control has now passed to the second element of the (sys:text ...),
a regular expression which matches one or more spaces, generated by
a single space in the source code according to the language rules.

The input context shows that "<!DOCTYPE" was matched in the input, and the
position moved past it.

  txr> s
  stopped at line 2 of navytime.txr
  form: "HTML"
  depth: 4
  data (1:10):
  "<!DOCTYPE " . "HTML PUBLIC \e"-//W3C//DTD HTML 3.2 Final\e"//EN>"

Now, the regular expression has matched and moved the position past
the space; the facing input is now "HTML ...".

The programmer then repeats the s command by hitting Enter.

  txr> 
  stopped at line 2 of navytime.txr
  form: (#<sys:regex: 95e4618> 1+ #\espace)
  depth: 4
  data (1:14):
  "<!DOCTYPE HTML" . " PUBLIC \e"-//W3C//DTD HTML 3.2 Final\e"//EN>"
  txr>
  stopped at line 2 of navytime.txr
  form: "PUBLIC"
  depth: 4
  data (1:15):
  "<!DOCTYPE HTML " . "PUBLIC \e"-//W3C//DTD HTML 3.2 Final\e"//EN>"
  txr>
  stopped at line 2 of navytime.txr
  form: (#<sys:regex: 95e46a8> 1+ #\espace)
  depth: 4
  data (1:21):
  "<!DOCTYPE HTML PUBLIC" . " \e"-//W3C//DTD HTML 3.2 Final\e"//EN>"
  txr>
  stopped at line 2 of navytime.txr
  form: "\e"-//W3C//DTD"
  depth: 4
  data (1:22):
  "<!DOCTYPE HTML PUBLIC " . "\e"-//W3C//DTD HTML 3.2 Final\e"//EN>"
  txr>
  stopped at line 2 of navytime.txr
  form: (#<sys:regex: 95e4750> 1+ #\espace)
  depth: 4
  data (1:34):
  "<!DOCTYPE HTML PUBLIC \e"-//W3C//DTD" . " HTML 3.2 Final\e"//EN>"

It is not evident from the session transcript, but during interactive use,
the input context appears to be animated. Whenever the programmer hits
Enter, the new context is printed and the dot appears to advance.

Eventually the programmer becomes bored and place a breakpoint on line 15,
where the @(output) block begins, and invokes the c command to continue the
execution:

  txr> b 15
  txr> c
  stopped at line 15 of navytime.txr
  form: (output (((repeat nil (((sys:var MO nil nil) "-" (sys:var DD nil nil) " " (sys:var HH nil nil) ":" (sys:var MM nil nil) ":" (sys:var SS nil nil) " " (sys:var PM nil nil) " " (sys:var TZ nil nil))) nil nil nil nil nil nil))))
  depth: 2
  data (16):
  ""

The programmer issues a v command to take a look at the variable bindings,
which indicate that the @(collect) has produced some lists.

  txr> v
  bindings:
  0: ((PM "  " "PM" "PM" "PM" "PM" "PM" "PM") (TZNAME "Universal Time" "Eastern Time" "Central Time" "Mountain Time" "Pacific Time" "Alaska Time" "Hawaii-Aleutian Time") (TZ "UTC" "EDT" "CDT" "MDT" "PDT" "AKDT" "HAST") (SS "35" "35" "35" "35" "35" "35" "35") (MM "32" "32" "32" "32" "32" "32" "32") (HH "23" "07" "06" "05" "04" "03" "01") (DD "30" "30" "30" "30" "30" "30" "30") (MO "Mar" "Mar" "Mar" "Mar" "Mar" "Mar" "Mar"))

Then a continue command, which finishes the program, whose output appears:

  txr> c
  Mar-30 23:22:52    UTC
  Mar-30 07:22:52 PM EDT
  Mar-30 06:22:52 PM CDT
  Mar-30 05:22:52 PM MDT
  Mar-30 04:22:52 PM PDT
  Mar-30 03:22:52 PM AKDT
  Mar-30 01:22:52 PM HAST

.SH APPENDIX A: NOTES ON EXOTIC REGULAR EXPRESSIONS

Users familiar with regular expressions may not be familiar with the complement
and intersection operators, which are often absent from text processing tools
that support regular expressions.  The following remarks are offered in hope
that they are of some use.

.SS Equivalence to Sets

Regexp intersection is not essential; it may be obtained from complement and
union as follows, since De Morgan's law applies to regular expression algebra:
(R1)&(R2) = ~(~(R1)|~(R2)). (The complement of the union of the complements of
R1 and R2 constitutes the intersection.) This law works because the regular
expression operators denote set operations in a straightforward way. A regular
expression denotes a set of strings (a potentially infinite one) in a condensed
way. The union of two regular expressions R1 | R2 denotes the union of the set
of texts denoted by R1 and that denoted by R2. Similarly R1 & R2 denotes a set
intersection, and ~R denotes a set complement. Thus algebraic laws
that apply to set operations apply to regular expressions. It's useful to keep
in mind this relationship between regular expressions and sets in understanding
intersection and complement.

Given a finite set of strings, like the set { "abc", "def" }, which corresponds
to the regular expression (abc|def), the complement is the set which contains
an infinite number of strings: it consists of all possible strings except "abc"
and "def". It includes the empty string, all strings of length 1, all strings
of length 2, all strings of length 3 other than "abc" and "def", all strings of
length 4, etc.  This means that a "harmless looking" expression like ~(abc|def)
can actually match arbitrarily long inputs.

.SS Set Difference

How about matching only three-character-long strings other than "abc" or "def"?
To express this, regex intersection can be used: these strings are the
intersection of the set of all three-character strings, and the set of all
strings which are not "abc" or "def". The straightforward set-based reasoning
leads us to this: ...&~(abc|def).   This A&~B idiom is also called set
difference, sometimes notated with a minus sign: A-B (which is not
supported in 
.B TXR
regular expression syntax).  Elements which are in the set A, but not B, are
those elements which are in the intersection of A with the complement of B.
This is similar to the arithmetic rule A - B = A + -B: subtraction is
equivalent to addition of the additive inverse. Set difference is a useful
tool: it enables us to write a positive match which captures a more general set
than what is intended (but one whose regular expression is far simpler
than a positive match for the exact set we want), then we can
intersect this over-generalized set with the complemented set of
another regular expression which matches the particulars that we wish excluded.

.SS Expressivity versus Power

It turns out that regular expressions which do not make use of the
complement or intersection operators are just as powerful as expressions
that do. That is to say, with or without these operators, regular expressions
can match the same sets of strings (all regular languages).  This means that
for a given regular expression which uses intersection and complement, it is
possible to find a regular expression which doesn't use these operators, yet
matches the same set of strings.  But, though they exist, such equivalent
regular expressions are often much more complicated, which makes them difficult
to design.  Such expressions do not necessarily
. B express
what it is they match; they merely capture the equivalent set. They
perform a job, without making it obvious what it is they do.  The use of
complement and intersection leads to natural ways of expressing many kinds of
matching sets, which not only demonstrate the power to carry out an operation,
but also easily express the concept.

.SS Example: Matching C Language Comments

For instance, using complement, we can write a straightforward regular
expression which matches C language comments. A C language
comment is the digraph /*, followed by any string which does not contain the
closing sequence */, followed by that closing sequence.
Examples of valid comments are /**/, /* abc */ or /***/. But C
comments do not nest (cannot contain comments), so that 
/* /* nested */ */ actually consists of the comment /* /* nested */,
which is followed by the trailing junk */.
Our simple characterization of interior part of a C comment as a string
which does not contain the terminating digraph makes use of the
complement, and can be expressed using the complemented regular expression like
this: (~.*[*][/].*).  That is to say, strings which contain */ are matched by
the expression .*[*][/].*: zero or more arbitrary characters, followed by
*/, followed by zero or more arbitrary characters. Therefore, the complement of
this expression matches all other strings: those which do not contain */.
These strings up the inside of a C comment between the /* and */.

The equivalent simple regex is quite a bit more complicated.
Without complement, we must somehow write a positive match for all strings such
that we avoid matching */. Obviously, sequences of characters other than *
are included: [^*]*.   Occurrences of * are also allowed, but only if followed
by something other than a slash, so let's include this via union:

  ([^*]|[*][^/])*. 

Alas, already, we have a bug in this expression. The
subexpression [*][^/] can match "**", since a * is not a /.  If the next
character in the input is /, we missed a comment close.  To fix the problem we
revise to this: 

  ([^*]|[*][^*/])*

(The interior of a C language comment is a any
mixture of zero or more non-asterisks, or digraphs consisting of an asterisk
followed by something other than a slash or another asterisk).  Oops, now we
have a problem again. What if two asterisks occur in a comment?  They are not
matched by [^*], and they are not matched by [*][^*/]. Actually, our regex must
not simply match asterisk-non-asterisk digraphs, but rather sequences of one or
more asterisks followed by a non-asterisk: 

  ([^*]|[*]*[^*/])*

This is still not right, because, for instance, it fails to match the interior
of a comment which is terminated by asterisks, including the simple test cases
where the comment interior is nothing but asterisks.  We have no provision in
our expression for this case; the expression requires all runs of asterisks to
be followed by something which is not a slash or asterisk. The way to fix this
is to add on a subexpression which optionally matches a run of zero or more
interior asterisks before the comment close: 

  ([^*]|[*]*[^*/])*[*]*

Thus our the semi-final regular expression is

  [/][*]([^*]|[*]*[^*/])*[*]*[*][/]

(A C comment is an interior string enclosed in /* */, where this interior part
consists of a mixture of non-asterisk characters, as well as runs of asterisk
characters which are terminated by a character other than a slash, except for
possibly one rightmost run of asterisks which extends to the end of the
interior, touching the comment close. Phew!) One final simplification is
possible: the tail part [*]*[*][/]  can be reduced to [*]+[/] such that the
final run of asterisks is regarded as part of an extended comment terminator
which consists of one or more asterisks followed by a slash.   The regular
expression works, but it's cryptic; to someone who has not developed it, it
isn't obvious what it is intended to match.  Working out complemented matching
without complement support from the language is not impossible, but it may be
difficult and error-prone, possibly requiring multiple iterations of
trial-and-error development involving numerous test cases, resulting in an
expression that doesn't have a straightforward relationship to the original
idea.

.SS The Non-Greedy Operator

The non-greedy operator % is actually defined in terms of a set difference,
which is in turn based on intersection and complement. The uninteresting case
(R%) where the right operand is empty reduces to (R*): if there is no trailing
context, the non-greedy operator matches R as far as possible, possibly to the
end of the input, exactly like the greedy Kleene.  The interesting case (R%T)
is defined as a "syntactic sugar" for the equivalent expression
((R*)&(~.*(T&.+).*))T   which means: match the longest string which is matched
by R*, but which does not contain a non-empty match for T; then, match T.  This
is a useful and expressive notation. With it, we can write the regular
expression for matching C language comments simply like this: [/][*].%[*][/]
(match the opening sequence /*, then match a sequence of zero or more
characters non-greedily, and then the closing sequence */.  With the non-greedy
operator, we don't have to think about the interior of the comment as set of
strings which excludes */.  Though the non-greedy operator appears expressive,
its apparent simplicity may be deceptive.  It looks as if it works "magically"
by itself; "somehow" this .% "knows" only to consume enough characters so that
it doesn't swallow an occurrence of the trailing context. Care must be taken
that the trailing context passed to the operator really is the correct text
that should be excluded by the non-greedy match. For instance, take the
expression .%abc.  If you intend the trailing context to be merely a, you must
be careful to write (.%a)bc. Otherwise the trailing context is abc, and this
means that the .% match will consume the longest string that does not contain
"abc", when in fact what was intended was to consume the longest string that
does not contain a. The change in behavior of the % operator upon modifying the
trailing context is not as intuitive as that of the * operator, because the
trailing context is deeply involved in its logic.  For single-character
trailing contexts, it may be a good idea to use a complemented character class
instead. That is to say, rather than (.%a)bc, consider [^a]*abc. The set of
strings which don't contain the character a is adequately expressed by [^a]*.
